{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/meadow/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/meadow/source/css/iconfont.css","path":"css/iconfont.css","modified":0,"renderable":1},{"_id":"themes/meadow/source/css/mdui.min.v0.4.3.css","path":"css/mdui.min.v0.4.3.css","modified":0,"renderable":1},{"_id":"themes/meadow/source/css/mdui.min.v0.4.3.css.map","path":"css/mdui.min.v0.4.3.css.map","modified":0,"renderable":1},{"_id":"themes/meadow/source/css/mdui.min.v1.0.0.css","path":"css/mdui.min.v1.0.0.css","modified":0,"renderable":1},{"_id":"themes/meadow/source/icons/favicon.ico","path":"icons/favicon.ico","modified":0,"renderable":1},{"_id":"themes/meadow/source/css/mdui.min.v1.0.0.css.map","path":"css/mdui.min.v1.0.0.css.map","modified":0,"renderable":1},{"_id":"themes/meadow/source/icons/avatar.gif","path":"icons/avatar.gif","modified":0,"renderable":1},{"_id":"themes/meadow/source/js/mdui.min.v0.4.3.js","path":"js/mdui.min.v0.4.3.js","modified":0,"renderable":1},{"_id":"themes/meadow/source/js/mdui.min.v0.4.3.js.map","path":"js/mdui.min.v0.4.3.js.map","modified":0,"renderable":1},{"_id":"themes/meadow/source/js/meadow.js","path":"js/meadow.js","modified":0,"renderable":1},{"_id":"themes/meadow/source/js/mdui.min.v1.0.0.js","path":"js/mdui.min.v1.0.0.js","modified":0,"renderable":1},{"_id":"themes/meadow/source/js/mdui.min.v1.0.0.js.map","path":"js/mdui.min.v1.0.0.js.map","modified":0,"renderable":1},{"_id":"themes/meadow/source/fonts/roboto/Roboto-Black.woff","path":"fonts/roboto/Roboto-Black.woff","modified":0,"renderable":1},{"_id":"themes/meadow/source/fonts/roboto/Roboto-Black.woff2","path":"fonts/roboto/Roboto-Black.woff2","modified":0,"renderable":1},{"_id":"themes/meadow/source/fonts/roboto/Roboto-Bold.woff","path":"fonts/roboto/Roboto-Bold.woff","modified":0,"renderable":1},{"_id":"themes/meadow/source/fonts/roboto/Roboto-BlackItalic.woff","path":"fonts/roboto/Roboto-BlackItalic.woff","modified":0,"renderable":1},{"_id":"themes/meadow/source/fonts/roboto/Roboto-BlackItalic.woff2","path":"fonts/roboto/Roboto-BlackItalic.woff2","modified":0,"renderable":1},{"_id":"themes/meadow/source/fonts/roboto/Roboto-Bold.woff2","path":"fonts/roboto/Roboto-Bold.woff2","modified":0,"renderable":1},{"_id":"themes/meadow/source/fonts/roboto/Roboto-Light.woff","path":"fonts/roboto/Roboto-Light.woff","modified":0,"renderable":1},{"_id":"themes/meadow/source/fonts/roboto/Roboto-BoldItalic.woff","path":"fonts/roboto/Roboto-BoldItalic.woff","modified":0,"renderable":1},{"_id":"themes/meadow/source/fonts/roboto/Roboto-BoldItalic.woff2","path":"fonts/roboto/Roboto-BoldItalic.woff2","modified":0,"renderable":1},{"_id":"themes/meadow/source/fonts/roboto/Roboto-Light.woff2","path":"fonts/roboto/Roboto-Light.woff2","modified":0,"renderable":1},{"_id":"themes/meadow/source/fonts/roboto/Roboto-LightItalic.woff","path":"fonts/roboto/Roboto-LightItalic.woff","modified":0,"renderable":1},{"_id":"themes/meadow/source/fonts/roboto/Roboto-Medium.woff","path":"fonts/roboto/Roboto-Medium.woff","modified":0,"renderable":1},{"_id":"themes/meadow/source/fonts/roboto/Roboto-LightItalic.woff2","path":"fonts/roboto/Roboto-LightItalic.woff2","modified":0,"renderable":1},{"_id":"themes/meadow/source/fonts/roboto/Roboto-Medium.woff2","path":"fonts/roboto/Roboto-Medium.woff2","modified":0,"renderable":1},{"_id":"themes/meadow/source/fonts/roboto/Roboto-MediumItalic.woff","path":"fonts/roboto/Roboto-MediumItalic.woff","modified":0,"renderable":1},{"_id":"themes/meadow/source/fonts/roboto/Roboto-MediumItalic.woff2","path":"fonts/roboto/Roboto-MediumItalic.woff2","modified":0,"renderable":1},{"_id":"themes/meadow/source/fonts/roboto/Roboto-Regular.woff2","path":"fonts/roboto/Roboto-Regular.woff2","modified":0,"renderable":1},{"_id":"themes/meadow/source/fonts/roboto/Roboto-Regular.woff","path":"fonts/roboto/Roboto-Regular.woff","modified":0,"renderable":1},{"_id":"themes/meadow/source/fonts/roboto/Roboto-RegularItalic.woff","path":"fonts/roboto/Roboto-RegularItalic.woff","modified":0,"renderable":1},{"_id":"themes/meadow/source/fonts/roboto/Roboto-RegularItalic.woff2","path":"fonts/roboto/Roboto-RegularItalic.woff2","modified":0,"renderable":1},{"_id":"themes/meadow/source/fonts/roboto/Roboto-Thin.woff","path":"fonts/roboto/Roboto-Thin.woff","modified":0,"renderable":1},{"_id":"themes/meadow/source/fonts/roboto/Roboto-ThinItalic.woff","path":"fonts/roboto/Roboto-ThinItalic.woff","modified":0,"renderable":1},{"_id":"themes/meadow/source/fonts/roboto/Roboto-Thin.woff2","path":"fonts/roboto/Roboto-Thin.woff2","modified":0,"renderable":1},{"_id":"themes/meadow/source/fonts/roboto/Roboto-ThinItalic.woff2","path":"fonts/roboto/Roboto-ThinItalic.woff2","modified":0,"renderable":1}],"Cache":[{"_id":"source/About-me/index.md","hash":"bdd50ca8bc5a0929c716cb6062d03aac63fb86b0","modified":1616339997227},{"_id":"source/_posts/IDEApush到github被拒绝的问题.md","hash":"387b272ebcd5e7464fe741be3e6bae36d5a1e33c","modified":1617029075959},{"_id":"source/_posts/sptingboot集成mybatis.md","hash":"67d7897e14760271d384d72e49e0730104ddd726","modified":1618151699138},{"_id":"source/_posts/Postons.md","hash":"08d50cf61a50bd4cb85418b32f02f7857a6f8015","modified":1623398100142},{"_id":"source/_posts/泥鳅.md","hash":"745355d8eb6f9549aef38690e804ede50cd400d0","modified":1623223118407},{"_id":"themes/meadow/.gitattributes","hash":"38d287cd5bebd7ae7a481a751417dbed6d35c004","modified":1622815351241},{"_id":"themes/meadow/languages/zh-CN.yml","hash":"6ea5c442674098d947bcba89f78fcefc4d763bb0","modified":1622815351241},{"_id":"themes/meadow/README.md","hash":"6fec37756e2262b22f1728f7b555a1f98463984e","modified":1622815351241},{"_id":"themes/meadow/languages/en.yml","hash":"81ae86203870165bcad70cd3f3dfb1b27dbd7b92","modified":1622815351241},{"_id":"themes/meadow/_config.yml","hash":"5265bcea86b5790196976b00566ba3e2aecb7b2d","modified":1622815351241},{"_id":"themes/meadow/layout/category.ejs","hash":"6d0e873f0909676e28f59ad555992791522f4840","modified":1622815351271},{"_id":"themes/meadow/layout/index.ejs","hash":"82a97dda77a3a03c1ebb353a25cda1045e9cf7ee","modified":1622815351271},{"_id":"themes/meadow/layout/archive.ejs","hash":"6433e5b310945c1a6dcd7a602ff295ce2d1a1b79","modified":1622815351271},{"_id":"themes/meadow/layout/layout.ejs","hash":"2e0b6785bfc80345117523c9d1163b297caa81f2","modified":1622815351271},{"_id":"themes/meadow/layout/post.ejs","hash":"9f916bc8338279f5f845d942fc14b480482e6e16","modified":1622815351271},{"_id":"themes/meadow/layout/page.ejs","hash":"e666c75c90e2e136879e3e9446a66b312b5cdd1e","modified":1622815351271},{"_id":"themes/meadow/layout/tag.ejs","hash":"d950c1ab3c962d780e32e7fd632c4ded7e23f3fe","modified":1622815351271},{"_id":"themes/meadow/LICENSE","hash":"3c1857af501da6d9e80179a05a9c2352f45d4e7c","modified":1622815351241},{"_id":"themes/meadow/source/css/main.styl","hash":"3129d8609e0269ec47f3e98e6172d62118d97c7c","modified":1622815351281},{"_id":"source/_posts/关于对floyd算法的质疑.md","hash":"92dc5fb804fbb3350c5cd91cf267d60c6999946c","modified":1618678004255},{"_id":"themes/meadow/source/icons/favicon.ico","hash":"fb79fb50e5a9da722f4de142a45c996ef437476d","modified":1622815351321},{"_id":"source/_posts/在O-logn-的复杂度下两数组的混合中位数.md","hash":"cd60e8ec8d5b28b35fe46258ec3834f88657bc2d","modified":1618638814414},{"_id":"themes/meadow/source/css/iconfont.css","hash":"8268b1456e8548a7628004ab7d763e8dcad68674","modified":1622815351281},{"_id":"themes/meadow/source/icons/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1622815351311},{"_id":"themes/meadow/source/js/mdui.min.v0.4.3.js","hash":"9a0619bbda818a6b566f72a2f313e8ae1b883d5a","modified":1622815351321},{"_id":"themes/meadow/layout/_partial/article.ejs","hash":"5efe8933c8aa341222f15cd5e0c3f6930d2e9ff0","modified":1622815351251},{"_id":"themes/meadow/layout/_adsense/footer.ejs","hash":"1d64c019eab8d68be033bc4a0d74b005b8fe4b29","modified":1622815351241},{"_id":"themes/meadow/layout/_partial/bodyload.ejs","hash":"5756943f2b5871e8e6083a58bec6c83ded9bf010","modified":1622815351251},{"_id":"themes/meadow/layout/_adsense/sidebar.ejs","hash":"ced3c5f3adcc307d657072f1cf37bb6422321585","modified":1622815351251},{"_id":"themes/meadow/layout/_adsense/banner.ejs","hash":"16066c42d668c8af77a751526f465946611181d9","modified":1622815351241},{"_id":"themes/meadow/layout/_partial/footer.ejs","hash":"c7c1aa4865a8845732c683431fa5020e48964984","modified":1622815351251},{"_id":"themes/meadow/layout/_partial/head.ejs","hash":"5d24021970d3aca2205fa9876c07f29181c2c029","modified":1622815351251},{"_id":"themes/meadow/layout/_partial/headload.ejs","hash":"4aec9983156b3f7bf9417e8d33b0db54c1ced7ed","modified":1622815351251},{"_id":"themes/meadow/layout/_partial/header.ejs","hash":"d0a47f273e3b9b3496049f9bb02ffa8e6e78123b","modified":1622815351251},{"_id":"themes/meadow/layout/_partial/pagination.ejs","hash":"3a46cd753076e88828346389e48d353dbc0e5980","modified":1622815351251},{"_id":"themes/meadow/layout/_partial/sidebar.ejs","hash":"9af6840f749907ba4de1e667dc497ef051fdb514","modified":1622815351261},{"_id":"themes/meadow/source/css/_partial/post.styl","hash":"e2692a989ce736172514b8dc0e2798accb9c7bb2","modified":1622815351271},{"_id":"themes/meadow/source/js/meadow.js","hash":"aeed9fa28ad119ee4c4edb2c399bbcdf84805806","modified":1622815351321},{"_id":"themes/meadow/source/css/_partial/search.styl","hash":"8e0bf924f0af39792d4846d9cad196016230639e","modified":1622815351271},{"_id":"themes/meadow/source/css/_partial/highlight.styl","hash":"475c8bd64ab87cf957d8f11c5adba7163c8b45f1","modified":1622815351271},{"_id":"themes/meadow/source/fonts/roboto/Roboto-Black.woff2","hash":"36dd174e41242ff6318083409f7e6c700b25eba2","modified":1622815351291},{"_id":"themes/meadow/source/css/_partial/page.styl","hash":"19dc6d27283ad509ffc5b90491754eed1f70f857","modified":1622815351271},{"_id":"themes/meadow/source/css/_partial/sidebar.styl","hash":"fc0c737fe24175081c1f47417c89be69f552d905","modified":1622815351281},{"_id":"themes/meadow/source/fonts/roboto/Roboto-Bold.woff2","hash":"9074123ec9d4d6a7e21c2bee3f0110ca9a73733d","modified":1622815351291},{"_id":"themes/meadow/source/fonts/roboto/Roboto-Light.woff2","hash":"df835660087fc7421a7667d8b68d759e0e1dbbf8","modified":1622815351301},{"_id":"themes/meadow/source/fonts/roboto/Roboto-Medium.woff2","hash":"9f358fd5f441565282b54e8dc072a7d68f71a2fc","modified":1622815351301},{"_id":"themes/meadow/source/fonts/roboto/Roboto-Regular.woff2","hash":"a18bcf95ada923da31f176137b8add02b0ba60f3","modified":1622815351311},{"_id":"themes/meadow/layout/_partial/post/post-share.ejs","hash":"dc881daf56ea6f4ef8d029aa76019dd6a76ee800","modified":1622815351261},{"_id":"themes/meadow/layout/_partial/page/categories.ejs","hash":"0ecfbb477f63d02297dab02f170ae778be6e5e50","modified":1622815351251},{"_id":"themes/meadow/layout/_partial/page/tags.ejs","hash":"4119201c15f48ed0775fbfb42964c203a7c5ad09","modified":1622815351251},{"_id":"themes/meadow/layout/_partial/page/collapse.ejs","hash":"333c6e0b7ad3a1eb08dce92b50e33b670ea77081","modified":1622815351251},{"_id":"themes/meadow/layout/_partial/post/post-header.ejs","hash":"51ac7398b26898627b21dd2101fc7f4f69a33f32","modified":1622815351251},{"_id":"themes/meadow/source/fonts/roboto/Roboto-Thin.woff2","hash":"0592332e221316fd8331110568df461e87689cca","modified":1622815351311},{"_id":"themes/meadow/layout/_plugin/analytics/baidu-analytics.ejs","hash":"3a945c492862264b9e7cd8f9584a3a1e98635f72","modified":1622815351261},{"_id":"themes/meadow/layout/_partial/post/post-tag.ejs","hash":"1a804fad651015ffc23640c20b3e3bba5cffa297","modified":1622815351261},{"_id":"themes/meadow/layout/_plugin/analytics/cnzz-analytics.ejs","hash":"4cd9b1845eae8e95f18865fd754b00eca5711d64","modified":1622815351261},{"_id":"themes/meadow/layout/_plugin/comment/changyan.ejs","hash":"b3a28ac1f177b61aebd341229b66666b8c082a5e","modified":1622815351261},{"_id":"themes/meadow/layout/_plugin/analytics/google-analytics.ejs","hash":"22ac48b05a43ad8475dee37941876bbe73f8b99b","modified":1622815351261},{"_id":"themes/meadow/layout/_plugin/analytics/tencent-analytics.ejs","hash":"a0a4e7c67028a354f267577ab2113cc4d9f36476","modified":1622815351261},{"_id":"themes/meadow/layout/_plugin/comment/livere.ejs","hash":"01c17bf42d2e2526d04c5c84b25aeb118431943c","modified":1622815351261},{"_id":"themes/meadow/layout/_plugin/comment/index.ejs","hash":"06162aa02ece76f43fa2f588b7d8381fe7512bbd","modified":1622815351261},{"_id":"themes/meadow/layout/_plugin/comment/gitalk.ejs","hash":"8cf21012c8c9c728063c8b51e95737bb0d2ecd6d","modified":1622815351261},{"_id":"themes/meadow/layout/_plugin/comment/disqus.ejs","hash":"f7c0ff05ef958cf24b226d25f0c4310683d4a54b","modified":1622815351261},{"_id":"themes/meadow/layout/_plugin/comment/valine.ejs","hash":"e0fb21c23df72a8ef14680c1c6e3bb8b23334cbb","modified":1622815351261},{"_id":"themes/meadow/layout/_plugin/math/mathjax.ejs","hash":"2d568afb78c41642f9dec8b03456243341ea19d4","modified":1622815351271},{"_id":"themes/meadow/layout/_plugin/math/katex.ejs","hash":"32c19e5886ce2454272037b018bb80e1841f97e7","modified":1622815351271},{"_id":"themes/meadow/source/js/mdui.min.v1.0.0.js","hash":"6a084e757718fa0a1f48f2ea968d8060b40127d5","modified":1622815351321},{"_id":"themes/meadow/source/fonts/roboto/Roboto-Bold.woff","hash":"274d0176d3b2e324111d0f836625960bdf24a29a","modified":1622815351291},{"_id":"themes/meadow/source/fonts/roboto/Roboto-Black.woff","hash":"100a2d03d89a0e3e027a1500e4f4d715d1ed52a0","modified":1622815351291},{"_id":"themes/meadow/source/fonts/roboto/Roboto-BlackItalic.woff","hash":"d2f8acc7e66ff51cc180bd998056e68dec30b8c6","modified":1622815351291},{"_id":"themes/meadow/source/fonts/roboto/Roboto-BlackItalic.woff2","hash":"45dc6a6ae29b2522ac98fc130d300d1c3ceee9b4","modified":1622815351291},{"_id":"themes/meadow/source/fonts/roboto/Roboto-Light.woff","hash":"d6d654d36c6cf9053675860d00125d6c543560d8","modified":1622815351301},{"_id":"themes/meadow/source/fonts/roboto/Roboto-BoldItalic.woff2","hash":"99eaed1b19b50aeb3866d9ce568c290d15c965fb","modified":1622815351301},{"_id":"themes/meadow/source/fonts/roboto/Roboto-BoldItalic.woff","hash":"83739a927323a1c00a5e61ef6da84fff9e15fbc8","modified":1622815351291},{"_id":"themes/meadow/source/fonts/roboto/Roboto-LightItalic.woff","hash":"184f1fc46df99866d5dbe03b57f3f6d9b9981ea0","modified":1622815351301},{"_id":"themes/meadow/source/fonts/roboto/Roboto-LightItalic.woff2","hash":"d72aa4d470b5923b3f614dd8ca25fd230dda8206","modified":1622815351301},{"_id":"themes/meadow/source/fonts/roboto/Roboto-MediumItalic.woff2","hash":"2fbd77f1d63c3d339167aa754e716451d129e23f","modified":1622815351311},{"_id":"themes/meadow/source/fonts/roboto/Roboto-MediumItalic.woff","hash":"b1afeefecbee33ad50452ce3f728dfcf781c9d49","modified":1622815351301},{"_id":"themes/meadow/source/fonts/roboto/Roboto-Medium.woff","hash":"d3564215ac8f29bbf8c3d0602e1299ebcbe26ea9","modified":1622815351301},{"_id":"themes/meadow/source/fonts/roboto/Roboto-RegularItalic.woff2","hash":"bd9360a27d99a093c2f06857c21fd6e98b57a8c0","modified":1622815351311},{"_id":"themes/meadow/source/fonts/roboto/Roboto-RegularItalic.woff","hash":"f3c32fd38c2f5fe34e54bdab2f238e469f48501a","modified":1622815351311},{"_id":"themes/meadow/source/fonts/roboto/Roboto-Regular.woff","hash":"db6450746e5df1eb0636bc84f21aae94e1cafea4","modified":1622815351311},{"_id":"themes/meadow/source/fonts/roboto/Roboto-Thin.woff","hash":"2d1c0c4d3ff8f91941499790d4fd63866e7c4852","modified":1622815351311},{"_id":"themes/meadow/source/fonts/roboto/Roboto-ThinItalic.woff","hash":"ea71e1a7f20df5de8048e06c70d0b756b83f867e","modified":1622815351311},{"_id":"themes/meadow/source/fonts/roboto/Roboto-ThinItalic.woff2","hash":"cf2e6e6e462a4ff1c980d2c0fdc7b9675a30c82b","modified":1622815351311},{"_id":"themes/meadow/source/css/mdui.min.v0.4.3.css","hash":"202c70d2d5d5a27b9c862992e3fe2932770aaf75","modified":1622815351281},{"_id":"themes/meadow/source/js/mdui.min.v0.4.3.js.map","hash":"7a92572e30f7b9bd09350efb04fd21f7b6230177","modified":1622815351321},{"_id":"themes/meadow/source/css/mdui.min.v1.0.0.css","hash":"5536f2d3270b74ee3b270281f08a3823494551ce","modified":1622815351281},{"_id":"themes/meadow/source/js/mdui.min.v1.0.0.js.map","hash":"29dbca6a99d7798fb46dcec4c9632e5c0ead4319","modified":1622815351321},{"_id":"themes/meadow/source/css/mdui.min.v0.4.3.css.map","hash":"925eb00f83a5d7b19304a426ea574dd4de69acd1","modified":1622815351281},{"_id":"themes/meadow/source/css/mdui.min.v1.0.0.css.map","hash":"96acfc653f0205b4127c309bab1c1d8f5180fd77","modified":1622815351291},{"_id":"source/_posts/Postons/Potions(Hard_version).png","hash":"33ffe55a747ea25b14fcda469327c8213ee6716a","modified":1623219774511},{"_id":"source/_posts/images/Week1/蚯蚓.png","hash":"ca8c6144b63833bd2ef91950ddd1bde12a7d06a5","modified":1623218201803},{"_id":"public/About-me/index.html","hash":"478760ed1e54f8bf12803efb0a8afa32b3c27c89","modified":1623226610249},{"_id":"public/2021/06/09/泥鳅/index.html","hash":"eeee4a703dfda36ef46ffd9c606dea36a5b528b9","modified":1623226610249},{"_id":"public/2021/06/09/Postons/index.html","hash":"f46ddfdcc5c3d30ef06d0e18ab9f22d17a6eded1","modified":1623399223425},{"_id":"public/2021/04/18/关于对floyd算法的质疑/index.html","hash":"6bfd68955d024c8caa3b49bd9feee056217923a6","modified":1623226610249},{"_id":"public/2021/04/10/在O-logn-的复杂度下两数组的混合中位数/index.html","hash":"5e3eb45978af89908415f88d60a1f4f8c2168c8a","modified":1623226610249},{"_id":"public/categories/ACM/index.html","hash":"009aaecb0a7cb459ba5af8aa6c9baac698ddbfc3","modified":1623226610249},{"_id":"public/categories/算法/index.html","hash":"2342d22996a0022bab9f78fbf19139e7822a3525","modified":1623226610249},{"_id":"public/categories/Diary/index.html","hash":"c874691bdda36c78743472b7f77c9ebe97c1547c","modified":1623226610249},{"_id":"public/archives/index.html","hash":"e393bc45a8e1b84fc07d4cf35724386f68623580","modified":1624462386851},{"_id":"public/archives/2021/index.html","hash":"e393bc45a8e1b84fc07d4cf35724386f68623580","modified":1624462386851},{"_id":"public/archives/2021/03/index.html","hash":"86fc0f39460fd59bcb902492915990ea2fe55539","modified":1624462386851},{"_id":"public/archives/2021/04/index.html","hash":"7bf74d2061f84253ef7b71cea39b68d87d1e9953","modified":1624462386851},{"_id":"public/archives/2021/06/index.html","hash":"287501c6e29f599a820dfde527777c020f7e6b33","modified":1624462386851},{"_id":"public/tags/反悔/index.html","hash":"be90283fdb3708de37bd464669ef93b37f02d878","modified":1623226610249},{"_id":"public/tags/贪心/index.html","hash":"2126b2b67bb5f95092496fd07ebd98b70074066f","modified":1623226610249},{"_id":"public/tags/优先队列/index.html","hash":"244d0ebe262ed5d0d6693486b6739369e1ae8d75","modified":1623226610249},{"_id":"public/tags/JAVA/index.html","hash":"a91fc4da6f2c3e72fa16690268540f861667e206","modified":1623226610249},{"_id":"public/tags/动态规划/index.html","hash":"b0019eb12934712cba1d45ed2d5916e79aa4dd59","modified":1623226610249},{"_id":"public/tags/SptingBoot/index.html","hash":"04165583dd637a5bcbaa3441961335360592c41e","modified":1623226610249},{"_id":"public/tags/数据库/index.html","hash":"0ef4172c666161aa7cbd1b272276760fa0051342","modified":1623226610249},{"_id":"public/tags/数学/index.html","hash":"707004562ead1afec1a28d717fdf0b711602a826","modified":1623226610249},{"_id":"public/tags/队列/index.html","hash":"1fd14e00d5576d54893a6d1665ebd391646fc6dd","modified":1623226610249},{"_id":"public/tags/分治法/index.html","hash":"3d851181432f7822d58f9e9c9c84412b5f9ff79c","modified":1623226610249},{"_id":"public/2021/03/30/sptingboot集成mybatis/index.html","hash":"e6a945955f13d3763ab976768389fccef7fd836d","modified":1623226610249},{"_id":"public/2021/03/22/IDEApush到github被拒绝的问题/index.html","hash":"d7a4c6686d78bd911bf5db6c6d72a4875c70ea25","modified":1623226610249},{"_id":"public/index.html","hash":"759815feae36e7ccbcdbd07735c780b6c09701d5","modified":1624462386851},{"_id":"public/icons/favicon.ico","hash":"fb79fb50e5a9da722f4de142a45c996ef437476d","modified":1623226610249},{"_id":"public/icons/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1623226610249},{"_id":"public/fonts/roboto/Roboto-Black.woff2","hash":"36dd174e41242ff6318083409f7e6c700b25eba2","modified":1623226610249},{"_id":"public/fonts/roboto/Roboto-Bold.woff2","hash":"9074123ec9d4d6a7e21c2bee3f0110ca9a73733d","modified":1623226610249},{"_id":"public/fonts/roboto/Roboto-Light.woff2","hash":"df835660087fc7421a7667d8b68d759e0e1dbbf8","modified":1623226610249},{"_id":"public/fonts/roboto/Roboto-Medium.woff2","hash":"9f358fd5f441565282b54e8dc072a7d68f71a2fc","modified":1623226610249},{"_id":"public/fonts/roboto/Roboto-Regular.woff2","hash":"a18bcf95ada923da31f176137b8add02b0ba60f3","modified":1623226610249},{"_id":"public/fonts/roboto/Roboto-Thin.woff2","hash":"0592332e221316fd8331110568df461e87689cca","modified":1623226610249},{"_id":"public/css/main.css","hash":"d063752e4b7ebdae407436daa696bb1235fa6cc1","modified":1623226610249},{"_id":"public/js/meadow.js","hash":"3fdfab667c0697354fc1ef96f6bc89d7331e404c","modified":1623226610249},{"_id":"public/css/iconfont.css","hash":"a8d1c687062f7f2adbdb5e4bdd8b53107047e23a","modified":1623226610249},{"_id":"public/js/mdui.min.v0.4.3.js","hash":"f64fd49e8cc1bb0679dd00cd1f11e9d111aac826","modified":1623226610249},{"_id":"public/js/mdui.min.v1.0.0.js","hash":"178ecc7437f1ec342762b0da74cbde3dd10342cd","modified":1623226610249},{"_id":"public/css/mdui.min.v0.4.3.css","hash":"7356f5d95c9d90254ea074ecaecae24e6a5a124e","modified":1623226610249},{"_id":"public/css/mdui.min.v1.0.0.css","hash":"5da28cd08e3bd4f759ee947e7e302e35a53831c2","modified":1623226610249},{"_id":"public/fonts/roboto/Roboto-Black.woff","hash":"100a2d03d89a0e3e027a1500e4f4d715d1ed52a0","modified":1623226610249},{"_id":"public/fonts/roboto/Roboto-Bold.woff","hash":"274d0176d3b2e324111d0f836625960bdf24a29a","modified":1623226610249},{"_id":"public/fonts/roboto/Roboto-BlackItalic.woff","hash":"d2f8acc7e66ff51cc180bd998056e68dec30b8c6","modified":1623226610249},{"_id":"public/fonts/roboto/Roboto-BlackItalic.woff2","hash":"45dc6a6ae29b2522ac98fc130d300d1c3ceee9b4","modified":1623226610249},{"_id":"public/fonts/roboto/Roboto-Light.woff","hash":"d6d654d36c6cf9053675860d00125d6c543560d8","modified":1623226610249},{"_id":"public/fonts/roboto/Roboto-BoldItalic.woff","hash":"83739a927323a1c00a5e61ef6da84fff9e15fbc8","modified":1623226610249},{"_id":"public/fonts/roboto/Roboto-BoldItalic.woff2","hash":"99eaed1b19b50aeb3866d9ce568c290d15c965fb","modified":1623226610249},{"_id":"public/fonts/roboto/Roboto-Medium.woff","hash":"d3564215ac8f29bbf8c3d0602e1299ebcbe26ea9","modified":1623226610249},{"_id":"public/fonts/roboto/Roboto-LightItalic.woff","hash":"184f1fc46df99866d5dbe03b57f3f6d9b9981ea0","modified":1623226610249},{"_id":"public/fonts/roboto/Roboto-LightItalic.woff2","hash":"d72aa4d470b5923b3f614dd8ca25fd230dda8206","modified":1623226610249},{"_id":"public/fonts/roboto/Roboto-MediumItalic.woff","hash":"b1afeefecbee33ad50452ce3f728dfcf781c9d49","modified":1623226610249},{"_id":"public/fonts/roboto/Roboto-MediumItalic.woff2","hash":"2fbd77f1d63c3d339167aa754e716451d129e23f","modified":1623226610249},{"_id":"public/fonts/roboto/Roboto-RegularItalic.woff","hash":"f3c32fd38c2f5fe34e54bdab2f238e469f48501a","modified":1623226610249},{"_id":"public/fonts/roboto/Roboto-RegularItalic.woff2","hash":"bd9360a27d99a093c2f06857c21fd6e98b57a8c0","modified":1623226610249},{"_id":"public/fonts/roboto/Roboto-Regular.woff","hash":"db6450746e5df1eb0636bc84f21aae94e1cafea4","modified":1623226610249},{"_id":"public/fonts/roboto/Roboto-Thin.woff","hash":"2d1c0c4d3ff8f91941499790d4fd63866e7c4852","modified":1623226610249},{"_id":"public/fonts/roboto/Roboto-ThinItalic.woff","hash":"ea71e1a7f20df5de8048e06c70d0b756b83f867e","modified":1623226610249},{"_id":"public/fonts/roboto/Roboto-ThinItalic.woff2","hash":"cf2e6e6e462a4ff1c980d2c0fdc7b9675a30c82b","modified":1623226610249},{"_id":"public/js/mdui.min.v0.4.3.js.map","hash":"7a92572e30f7b9bd09350efb04fd21f7b6230177","modified":1623226610249},{"_id":"public/js/mdui.min.v1.0.0.js.map","hash":"29dbca6a99d7798fb46dcec4c9632e5c0ead4319","modified":1623226610249},{"_id":"public/css/mdui.min.v0.4.3.css.map","hash":"925eb00f83a5d7b19304a426ea574dd4de69acd1","modified":1623226610249},{"_id":"public/css/mdui.min.v1.0.0.css.map","hash":"96acfc653f0205b4127c309bab1c1d8f5180fd77","modified":1623226610249},{"_id":"public/2021/06/09/Postons/Potions(Hard_version).png","hash":"33ffe55a747ea25b14fcda469327c8213ee6716a","modified":1623226610249},{"_id":"source/_posts/数据备份.md","hash":"889ea265d42011107f91d5458a938b85c69c940d","modified":1623399212887},{"_id":"source/_posts/数据备份/backUp.png","hash":"7591cff1c6a13315edb921cec93ef64d8781ae75","modified":1623398000042},{"_id":"public/categories/div1/index.html","hash":"6ccfe9ef7f54d49f4bd463a487b49c49e82a23a7","modified":1623399223425},{"_id":"public/2021/06/11/数据备份/index.html","hash":"880931aa2721a141ad069a647da2e9e1fd8ab8ad","modified":1623555531733},{"_id":"public/tags/贪心-反悔-优先队列/index.html","hash":"5f4317e4910377c6ed3c83b93f37ad4f7c97957d","modified":1623399223425},{"_id":"public/2021/06/11/数据备份/backUp.png","hash":"7591cff1c6a13315edb921cec93ef64d8781ae75","modified":1623399223425},{"_id":"source/_posts/BestCowFences.md","hash":"4cf2e2e5d23e65dd605f4d393912a03db68b0ec6","modified":1623557174728},{"_id":"source/_posts/BestCowFences/BestCowFence.png","hash":"cba042a07e1eed0b0ddd78e61fe006647bed5323","modified":1623515446697},{"_id":"public/2021/06/13/BestCowFences/index.html","hash":"1c60963faae547bb86bbfbaef92f12b0268242ac","modified":1623559687531},{"_id":"public/categories/div2/index.html","hash":"db3b96a6a3723e3985abd86585d68100a594f544","modified":1623555531733},{"_id":"public/tags/限定长度最大子段和/index.html","hash":"12208ec3b1518e98bba40a0b18bc6ac3d3098ac9","modified":1623559687531},{"_id":"public/tags/思维/index.html","hash":"cb5c02fbbe29c1cc65d5fae54a592fed6e1f09b3","modified":1623559687531},{"_id":"public/tags/二分答案/index.html","hash":"cbebd6c6b314b1b6d32a69f828997c3eecc9283c","modified":1623559687531},{"_id":"public/2021/06/13/BestCowFences/BestCowFence.png","hash":"cba042a07e1eed0b0ddd78e61fe006647bed5323","modified":1623555531733},{"_id":"source/_posts/MaxMedian.md","hash":"52089e79cf97c0b80d858f140ed4aba525455350","modified":1623559240088},{"_id":"source/_posts/MaxMedian/MaxMedian.png","hash":"a51a9bbdc1ba4026d2073b0c4abe23ffdafb2f55","modified":1623515469291},{"_id":"public/2021/06/13/MaxMedian/index.html","hash":"6bed6dbdc3864e6cdf1994637c9110c7e3439f26","modified":1624462386851},{"_id":"public/2021/06/13/MaxMedian/MaxMedian.png","hash":"a51a9bbdc1ba4026d2073b0c4abe23ffdafb2f55","modified":1623559687531},{"_id":"source/_posts/USST.md","hash":"09518053cc107f3036fba10b41c5132bc8c0fbc1","modified":1624461645782},{"_id":"source/_posts/USST.pdf","hash":"4028db8233eb6516fc54b0ea8078e33e2828c083","modified":1624461647622},{"_id":"public/2021/06/23/USST/index.html","hash":"1207ee7f562f9a2141aa6d8c0ccf4a65ef2e0196","modified":1624462386851}],"Category":[{"name":"ACM","_id":"ckpp77ovh0003u8tkgd6b84jw"},{"name":"Diary","_id":"ckpp77ovl0008u8tk7l7i9gxo"},{"name":"-算法","_id":"ckpp77ovo000du8tka0zwc1yv"},{"name":"div1","_id":"ckps1ze7w0001c0tk6mwz8e1i"},{"name":"-div1","_id":"ckps1ze810003c0tkgv6mc40e"},{"name":"div2","_id":"ckpun1mbv0001xktkcntsaa6d"}],"Data":[],"Page":[{"title":"About me","date":"2021-03-21T15:19:57.000Z","_content":"","source":"About-me/index.md","raw":"---\ntitle: About me\ndate: 2021-03-21 23:19:57\n---\n","updated":"2021-03-21T15:19:57.227Z","path":"About-me/index.html","comments":1,"layout":"page","_id":"ckpp77ove0001u8tkb0ljh2rg","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Postons","date":"2021-06-09T06:44:47.000Z","_content":"\n# 题目\n{% asset_img Potions(Hard_version).png %}\n#### 题目分析\n题目大概意思就是给出n个药水，每种药水会让生命值变化，你从左到右走，经过这个位置的时候可以拿起这瓶药水也可以忽略这瓶药水。你的初始生命值为0，并且整个过程中你的生命值不能低于0，问你最多能拿多少药水。\n\n#### 题解\n这个题目和最大连续子序列不同，这个是可以不连续的。\n\n- 贪心：使用贪心的策略，每次只要生命值允许，就拿这瓶药，并且记录自己拿了那些药。\n\n- 反悔：如果走到一个地方，拿了这瓶药之后，自己的生命会比0小，则比较：\n     - 若将之前所有药中生命值最小的一瓶比现在碰到的这瓶还小，那么丢弃之前那瓶药，而选择这瓶药，即反悔。\n     - 否则跳过这瓶药\n\n- 优先队列：由于每次都要比较之前已经拿了的药最小的，所以要用小根堆来记录之前已经喝过的药。\n\n#### 代码\n```c++\n#include<iostream>\n#include<queue>\nusing namespace std;\nlong long Now=0;    // 当前生命值\nint ans=0;    // 能够捡起的数量 \nint a[200004];\nint n;     // position数\nint main(){\n    //freopen(\"test/div1A.txt\",\"r\",stdin);\n    cin>>n;\n    priority_queue<int,vector<int>,greater<int>> Q;   // 小根堆\n    for(int i = 0;i<n;++i){\n        cin>>a[i];\n    }\n\n    for(int i =0;i<n;++i){\n        if(Now+a[i]<0){\n            if(!Q.empty()&&Q.top()<a[i]){\n                // 将小根堆顶部替换掉，由于Now本来就大于0，所以反悔后Now也大于0\n                Now=Now+a[i]-Q.top();\n                Q.pop();\n                Q.push(a[i]);\n                \n            }else{\n                continue;\n            }\n        }else{\n            Now+=a[i];\n            Q.push(a[i]);    // 把之前要的记录下来\n            ans++;\n        }\n    }\n    cout<<ans<<endl;\n}\n```\n\n\n","source":"_posts/Postons.md","raw":"---\ntitle: Postons\ndate: 2021-06-09 14:44:47\ncategories:\n   - div1\ntags:\n   - 反悔\n   - 贪心\n   - 优先队列\n---\n\n# 题目\n{% asset_img Potions(Hard_version).png %}\n#### 题目分析\n题目大概意思就是给出n个药水，每种药水会让生命值变化，你从左到右走，经过这个位置的时候可以拿起这瓶药水也可以忽略这瓶药水。你的初始生命值为0，并且整个过程中你的生命值不能低于0，问你最多能拿多少药水。\n\n#### 题解\n这个题目和最大连续子序列不同，这个是可以不连续的。\n\n- 贪心：使用贪心的策略，每次只要生命值允许，就拿这瓶药，并且记录自己拿了那些药。\n\n- 反悔：如果走到一个地方，拿了这瓶药之后，自己的生命会比0小，则比较：\n     - 若将之前所有药中生命值最小的一瓶比现在碰到的这瓶还小，那么丢弃之前那瓶药，而选择这瓶药，即反悔。\n     - 否则跳过这瓶药\n\n- 优先队列：由于每次都要比较之前已经拿了的药最小的，所以要用小根堆来记录之前已经喝过的药。\n\n#### 代码\n```c++\n#include<iostream>\n#include<queue>\nusing namespace std;\nlong long Now=0;    // 当前生命值\nint ans=0;    // 能够捡起的数量 \nint a[200004];\nint n;     // position数\nint main(){\n    //freopen(\"test/div1A.txt\",\"r\",stdin);\n    cin>>n;\n    priority_queue<int,vector<int>,greater<int>> Q;   // 小根堆\n    for(int i = 0;i<n;++i){\n        cin>>a[i];\n    }\n\n    for(int i =0;i<n;++i){\n        if(Now+a[i]<0){\n            if(!Q.empty()&&Q.top()<a[i]){\n                // 将小根堆顶部替换掉，由于Now本来就大于0，所以反悔后Now也大于0\n                Now=Now+a[i]-Q.top();\n                Q.pop();\n                Q.push(a[i]);\n                \n            }else{\n                continue;\n            }\n        }else{\n            Now+=a[i];\n            Q.push(a[i]);    // 把之前要的记录下来\n            ans++;\n        }\n    }\n    cout<<ans<<endl;\n}\n```\n\n\n","slug":"Postons","published":1,"updated":"2021-06-11T07:55:00.142Z","_id":"ckpp77ova0000u8tkhdr22q6g","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><img src=\"/2021/06/09/Postons/Potions(Hard_version).png\" class=\"\">\n<h4 id=\"题目分析\"><a href=\"#题目分析\" class=\"headerlink\" title=\"题目分析\"></a>题目分析</h4><p>题目大概意思就是给出n个药水，每种药水会让生命值变化，你从左到右走，经过这个位置的时候可以拿起这瓶药水也可以忽略这瓶药水。你的初始生命值为0，并且整个过程中你的生命值不能低于0，问你最多能拿多少药水。</p>\n<h4 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h4><p>这个题目和最大连续子序列不同，这个是可以不连续的。</p>\n<ul>\n<li><p>贪心：使用贪心的策略，每次只要生命值允许，就拿这瓶药，并且记录自己拿了那些药。</p>\n</li>\n<li><p>反悔：如果走到一个地方，拿了这瓶药之后，自己的生命会比0小，则比较：</p>\n<ul>\n<li>若将之前所有药中生命值最小的一瓶比现在碰到的这瓶还小，那么丢弃之前那瓶药，而选择这瓶药，即反悔。</li>\n<li>否则跳过这瓶药</li>\n</ul>\n</li>\n<li><p>优先队列：由于每次都要比较之前已经拿了的药最小的，所以要用小根堆来记录之前已经喝过的药。</p>\n</li>\n</ul>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> Now=<span class=\"number\">0</span>;    <span class=\"comment\">// 当前生命值</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> ans=<span class=\"number\">0</span>;    <span class=\"comment\">// 能够捡起的数量 </span></span><br><span class=\"line\"><span class=\"keyword\">int</span> a[<span class=\"number\">200004</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> n;     <span class=\"comment\">// position数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//freopen(&quot;test/div1A.txt&quot;,&quot;r&quot;,stdin);</span></span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    priority_queue&lt;<span class=\"keyword\">int</span>,vector&lt;<span class=\"keyword\">int</span>&gt;,greater&lt;<span class=\"keyword\">int</span>&gt;&gt; Q;   <span class=\"comment\">// 小根堆</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">        cin&gt;&gt;a[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i =<span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(Now+a[i]&lt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!Q.<span class=\"built_in\">empty</span>()&amp;&amp;Q.<span class=\"built_in\">top</span>()&lt;a[i])&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 将小根堆顶部替换掉，由于Now本来就大于0，所以反悔后Now也大于0</span></span><br><span class=\"line\">                Now=Now+a[i]-Q.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">                Q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">                Q.<span class=\"built_in\">push</span>(a[i]);</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            Now+=a[i];</span><br><span class=\"line\">            Q.<span class=\"built_in\">push</span>(a[i]);    <span class=\"comment\">// 把之前要的记录下来</span></span><br><span class=\"line\">            ans++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><img src=\"/2021/06/09/Postons/Potions(Hard_version).png\" class=\"\">\n<h4 id=\"题目分析\"><a href=\"#题目分析\" class=\"headerlink\" title=\"题目分析\"></a>题目分析</h4><p>题目大概意思就是给出n个药水，每种药水会让生命值变化，你从左到右走，经过这个位置的时候可以拿起这瓶药水也可以忽略这瓶药水。你的初始生命值为0，并且整个过程中你的生命值不能低于0，问你最多能拿多少药水。</p>\n<h4 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h4><p>这个题目和最大连续子序列不同，这个是可以不连续的。</p>\n<ul>\n<li><p>贪心：使用贪心的策略，每次只要生命值允许，就拿这瓶药，并且记录自己拿了那些药。</p>\n</li>\n<li><p>反悔：如果走到一个地方，拿了这瓶药之后，自己的生命会比0小，则比较：</p>\n<ul>\n<li>若将之前所有药中生命值最小的一瓶比现在碰到的这瓶还小，那么丢弃之前那瓶药，而选择这瓶药，即反悔。</li>\n<li>否则跳过这瓶药</li>\n</ul>\n</li>\n<li><p>优先队列：由于每次都要比较之前已经拿了的药最小的，所以要用小根堆来记录之前已经喝过的药。</p>\n</li>\n</ul>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> Now=<span class=\"number\">0</span>;    <span class=\"comment\">// 当前生命值</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> ans=<span class=\"number\">0</span>;    <span class=\"comment\">// 能够捡起的数量 </span></span><br><span class=\"line\"><span class=\"keyword\">int</span> a[<span class=\"number\">200004</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> n;     <span class=\"comment\">// position数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//freopen(&quot;test/div1A.txt&quot;,&quot;r&quot;,stdin);</span></span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    priority_queue&lt;<span class=\"keyword\">int</span>,vector&lt;<span class=\"keyword\">int</span>&gt;,greater&lt;<span class=\"keyword\">int</span>&gt;&gt; Q;   <span class=\"comment\">// 小根堆</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">        cin&gt;&gt;a[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i =<span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(Now+a[i]&lt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!Q.<span class=\"built_in\">empty</span>()&amp;&amp;Q.<span class=\"built_in\">top</span>()&lt;a[i])&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 将小根堆顶部替换掉，由于Now本来就大于0，所以反悔后Now也大于0</span></span><br><span class=\"line\">                Now=Now+a[i]-Q.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">                Q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">                Q.<span class=\"built_in\">push</span>(a[i]);</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            Now+=a[i];</span><br><span class=\"line\">            Q.<span class=\"built_in\">push</span>(a[i]);    <span class=\"comment\">// 把之前要的记录下来</span></span><br><span class=\"line\">            ans++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n"},{"title":"IDEApush到github被拒绝的问题","date":"2021-03-22T14:49:21.000Z","_content":"\n##  上传时被拒绝\n\n上传代码到github出现rejected的问题是因为新传的文件和原来的不是同一时间上传等，解决办法：\n\n```\ngit pull --rebase origin master\ngit push -u origin master -f     //这句不一定要\n```\n\n\n##  删除Github上面的文件夹\n\n先pull（把github上的文件pull下来）\n再执行\n```\ngit rm --cached -r \"要删除的文件夹\"\n```\n然后再commit，再push就行了。\n","source":"_posts/IDEApush到github被拒绝的问题.md","raw":"---\ntitle: IDEApush到github被拒绝的问题\ndate: 2021-03-22 22:49:21\ncategories:\n- Diary\ntags:\n- JAVA\n---\n\n##  上传时被拒绝\n\n上传代码到github出现rejected的问题是因为新传的文件和原来的不是同一时间上传等，解决办法：\n\n```\ngit pull --rebase origin master\ngit push -u origin master -f     //这句不一定要\n```\n\n\n##  删除Github上面的文件夹\n\n先pull（把github上的文件pull下来）\n再执行\n```\ngit rm --cached -r \"要删除的文件夹\"\n```\n然后再commit，再push就行了。\n","slug":"IDEApush到github被拒绝的问题","published":1,"updated":"2021-03-29T14:44:35.959Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckpp77ovf0002u8tk0ghb1f6y","content":"<h2 id=\"上传时被拒绝\"><a href=\"#上传时被拒绝\" class=\"headerlink\" title=\"上传时被拒绝\"></a>上传时被拒绝</h2><p>上传代码到github出现rejected的问题是因为新传的文件和原来的不是同一时间上传等，解决办法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull --rebase origin master</span><br><span class=\"line\">git push -u origin master -f     &#x2F;&#x2F;这句不一定要</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"删除Github上面的文件夹\"><a href=\"#删除Github上面的文件夹\" class=\"headerlink\" title=\"删除Github上面的文件夹\"></a>删除Github上面的文件夹</h2><p>先pull（把github上的文件pull下来）<br>再执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rm --cached -r &quot;要删除的文件夹&quot;</span><br></pre></td></tr></table></figure>\n<p>然后再commit，再push就行了。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"上传时被拒绝\"><a href=\"#上传时被拒绝\" class=\"headerlink\" title=\"上传时被拒绝\"></a>上传时被拒绝</h2><p>上传代码到github出现rejected的问题是因为新传的文件和原来的不是同一时间上传等，解决办法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull --rebase origin master</span><br><span class=\"line\">git push -u origin master -f     &#x2F;&#x2F;这句不一定要</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"删除Github上面的文件夹\"><a href=\"#删除Github上面的文件夹\" class=\"headerlink\" title=\"删除Github上面的文件夹\"></a>删除Github上面的文件夹</h2><p>先pull（把github上的文件pull下来）<br>再执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rm --cached -r &quot;要删除的文件夹&quot;</span><br></pre></td></tr></table></figure>\n<p>然后再commit，再push就行了。</p>\n"},{"title":"关于对floyd算法的质疑","date":"2021-04-17T16:24:38.000Z","_content":"# floyd算法\n所谓floyd算法，就是求图的每两个顶点的最短路径问题。算法用的是动态规划。\n循环N次，每次选取一个顶点K，比较图的每个顶点经过K到达其他顶点的距离和本来该顶点到达其他顶点的距离，并进行距离的更新。最后可求出每两个点的最短距离。\n\n#### 疑惑\n例如一个有向图，只有1->2和1->0->4->3->2这两条路径。前者长度8，后者总长度6。那么在选取0作起始点的时候，0->2没有更新成为最短路径，并且后来会把0抛弃掉，不考虑经过0，所以在选择经过0的时候，我们就没能求出1经过0到达2的最短路径。那么怎么还能算出1->2的最短路径？\n#### 理解\n在对0进行考虑的时候，我们已经更新了1->4的路径，而这条路径是从1经过0到达2的最短路径的一部分。所以其实经过0到达2的最短路径就已经被求出了一部分，所以接下来和0就没关系了。接下来的求法也同理。\n\n","source":"_posts/关于对floyd算法的质疑.md","raw":"---\ntitle: 关于对floyd算法的质疑\ndate: 2021-04-18 00:24:38\ntags:\n  - 动态规划\n---\n# floyd算法\n所谓floyd算法，就是求图的每两个顶点的最短路径问题。算法用的是动态规划。\n循环N次，每次选取一个顶点K，比较图的每个顶点经过K到达其他顶点的距离和本来该顶点到达其他顶点的距离，并进行距离的更新。最后可求出每两个点的最短距离。\n\n#### 疑惑\n例如一个有向图，只有1->2和1->0->4->3->2这两条路径。前者长度8，后者总长度6。那么在选取0作起始点的时候，0->2没有更新成为最短路径，并且后来会把0抛弃掉，不考虑经过0，所以在选择经过0的时候，我们就没能求出1经过0到达2的最短路径。那么怎么还能算出1->2的最短路径？\n#### 理解\n在对0进行考虑的时候，我们已经更新了1->4的路径，而这条路径是从1经过0到达2的最短路径的一部分。所以其实经过0到达2的最短路径就已经被求出了一部分，所以接下来和0就没关系了。接下来的求法也同理。\n\n","slug":"关于对floyd算法的质疑","published":1,"updated":"2021-04-17T16:46:44.255Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckpp77ovi0005u8tkdad5eag9","content":"<h1 id=\"floyd算法\"><a href=\"#floyd算法\" class=\"headerlink\" title=\"floyd算法\"></a>floyd算法</h1><p>所谓floyd算法，就是求图的每两个顶点的最短路径问题。算法用的是动态规划。<br>循环N次，每次选取一个顶点K，比较图的每个顶点经过K到达其他顶点的距离和本来该顶点到达其他顶点的距离，并进行距离的更新。最后可求出每两个点的最短距离。</p>\n<h4 id=\"疑惑\"><a href=\"#疑惑\" class=\"headerlink\" title=\"疑惑\"></a>疑惑</h4><p>例如一个有向图，只有1-&gt;2和1-&gt;0-&gt;4-&gt;3-&gt;2这两条路径。前者长度8，后者总长度6。那么在选取0作起始点的时候，0-&gt;2没有更新成为最短路径，并且后来会把0抛弃掉，不考虑经过0，所以在选择经过0的时候，我们就没能求出1经过0到达2的最短路径。那么怎么还能算出1-&gt;2的最短路径？</p>\n<h4 id=\"理解\"><a href=\"#理解\" class=\"headerlink\" title=\"理解\"></a>理解</h4><p>在对0进行考虑的时候，我们已经更新了1-&gt;4的路径，而这条路径是从1经过0到达2的最短路径的一部分。所以其实经过0到达2的最短路径就已经被求出了一部分，所以接下来和0就没关系了。接下来的求法也同理。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"floyd算法\"><a href=\"#floyd算法\" class=\"headerlink\" title=\"floyd算法\"></a>floyd算法</h1><p>所谓floyd算法，就是求图的每两个顶点的最短路径问题。算法用的是动态规划。<br>循环N次，每次选取一个顶点K，比较图的每个顶点经过K到达其他顶点的距离和本来该顶点到达其他顶点的距离，并进行距离的更新。最后可求出每两个点的最短距离。</p>\n<h4 id=\"疑惑\"><a href=\"#疑惑\" class=\"headerlink\" title=\"疑惑\"></a>疑惑</h4><p>例如一个有向图，只有1-&gt;2和1-&gt;0-&gt;4-&gt;3-&gt;2这两条路径。前者长度8，后者总长度6。那么在选取0作起始点的时候，0-&gt;2没有更新成为最短路径，并且后来会把0抛弃掉，不考虑经过0，所以在选择经过0的时候，我们就没能求出1经过0到达2的最短路径。那么怎么还能算出1-&gt;2的最短路径？</p>\n<h4 id=\"理解\"><a href=\"#理解\" class=\"headerlink\" title=\"理解\"></a>理解</h4><p>在对0进行考虑的时候，我们已经更新了1-&gt;4的路径，而这条路径是从1经过0到达2的最短路径的一部分。所以其实经过0到达2的最短路径就已经被求出了一部分，所以接下来和0就没关系了。接下来的求法也同理。</p>\n"},{"title":"sptingboot集成mybatis","date":"2021-03-30T04:23:17.000Z","catagories":["springboot"],"_content":"\n\n# SpringBoot集成mybatis\n\n\n> ### 添加依赖\n\n&emsp;&emsp;在pom.xml文件中添加MySQL驱动依赖和mybatis依赖,MySQL不用加版本号，继承了父类的版本号，也可以自己指定版本号。\n```\n<!--MySQL驱动-->\n\t\t<dependency>\n\t\t\t<groupId>mysql</groupId>\n\t\t\t<artifactId>mysql-connector-java</artifactId>\n\t\t</dependency>\n\n\n<!--MyBatis整合springboot框架的起步依赖-->\n\t\t<dependency>\n\t\t\t<groupId>org.mybatis.spring.boot</groupId>\n\t\t\t<artifactId>mybatis-spring-boot-starter</artifactId>\n\t\t\t<version>2.0.0</version>\n\t\t</dependency>\n```\n>### 属性设置\n&emsp;&emsp;在GeneratorMapper.xml文件中进行连接数据库的属性设置，设置完成后生成即可。","source":"_posts/sptingboot集成mybatis.md","raw":"---\ntitle: sptingboot集成mybatis\ndate: 2021-03-30 12:23:17\ncatagories:\n- springboot\ntags:\n- JAVA\n- SptingBoot\n- 数据库\n---\n\n\n# SpringBoot集成mybatis\n\n\n> ### 添加依赖\n\n&emsp;&emsp;在pom.xml文件中添加MySQL驱动依赖和mybatis依赖,MySQL不用加版本号，继承了父类的版本号，也可以自己指定版本号。\n```\n<!--MySQL驱动-->\n\t\t<dependency>\n\t\t\t<groupId>mysql</groupId>\n\t\t\t<artifactId>mysql-connector-java</artifactId>\n\t\t</dependency>\n\n\n<!--MyBatis整合springboot框架的起步依赖-->\n\t\t<dependency>\n\t\t\t<groupId>org.mybatis.spring.boot</groupId>\n\t\t\t<artifactId>mybatis-spring-boot-starter</artifactId>\n\t\t\t<version>2.0.0</version>\n\t\t</dependency>\n```\n>### 属性设置\n&emsp;&emsp;在GeneratorMapper.xml文件中进行连接数据库的属性设置，设置完成后生成即可。","slug":"sptingboot集成mybatis","published":1,"updated":"2021-04-11T14:34:59.138Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckpp77ovj0006u8tk6gjdencj","content":"<h1 id=\"SpringBoot集成mybatis\"><a href=\"#SpringBoot集成mybatis\" class=\"headerlink\" title=\"SpringBoot集成mybatis\"></a>SpringBoot集成mybatis</h1><blockquote>\n<h3 id=\"添加依赖\"><a href=\"#添加依赖\" class=\"headerlink\" title=\"添加依赖\"></a>添加依赖</h3></blockquote>\n<p>&emsp;&emsp;在pom.xml文件中添加MySQL驱动依赖和mybatis依赖,MySQL不用加版本号，继承了父类的版本号，也可以自己指定版本号。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--MySQL驱动--&gt;</span><br><span class=\"line\">\t\t&lt;dependency&gt;</span><br><span class=\"line\">\t\t\t&lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class=\"line\">\t\t\t&lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class=\"line\">\t\t&lt;&#x2F;dependency&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!--MyBatis整合springboot框架的起步依赖--&gt;</span><br><span class=\"line\">\t\t&lt;dependency&gt;</span><br><span class=\"line\">\t\t\t&lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;</span><br><span class=\"line\">\t\t\t&lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class=\"line\">\t\t\t&lt;version&gt;2.0.0&lt;&#x2F;version&gt;</span><br><span class=\"line\">\t\t&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<h3 id=\"属性设置\"><a href=\"#属性设置\" class=\"headerlink\" title=\"属性设置\"></a>属性设置</h3><p>&emsp;&emsp;在GeneratorMapper.xml文件中进行连接数据库的属性设置，设置完成后生成即可。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"SpringBoot集成mybatis\"><a href=\"#SpringBoot集成mybatis\" class=\"headerlink\" title=\"SpringBoot集成mybatis\"></a>SpringBoot集成mybatis</h1><blockquote>\n<h3 id=\"添加依赖\"><a href=\"#添加依赖\" class=\"headerlink\" title=\"添加依赖\"></a>添加依赖</h3></blockquote>\n<p>&emsp;&emsp;在pom.xml文件中添加MySQL驱动依赖和mybatis依赖,MySQL不用加版本号，继承了父类的版本号，也可以自己指定版本号。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--MySQL驱动--&gt;</span><br><span class=\"line\">\t\t&lt;dependency&gt;</span><br><span class=\"line\">\t\t\t&lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class=\"line\">\t\t\t&lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class=\"line\">\t\t&lt;&#x2F;dependency&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!--MyBatis整合springboot框架的起步依赖--&gt;</span><br><span class=\"line\">\t\t&lt;dependency&gt;</span><br><span class=\"line\">\t\t\t&lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;</span><br><span class=\"line\">\t\t\t&lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class=\"line\">\t\t\t&lt;version&gt;2.0.0&lt;&#x2F;version&gt;</span><br><span class=\"line\">\t\t&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<h3 id=\"属性设置\"><a href=\"#属性设置\" class=\"headerlink\" title=\"属性设置\"></a>属性设置</h3><p>&emsp;&emsp;在GeneratorMapper.xml文件中进行连接数据库的属性设置，设置完成后生成即可。</p>\n</blockquote>\n"},{"title":"在O(logn)的复杂度下两数组的混合中位数","date":"2021-04-10T15:32:41.000Z","_content":"### 题目 \n设X[ 0 : n - 1]和Y[ 0 : n – 1 ]为两个数组，每个数组中含有n个已排好序的数。找出X和Y的2n个数的中位数。要求：O(logn)时间内\n\n##### 解析\n要在O(logn)时间内求解，则自然想到分治算法。求解思路与如下：\n先分别求数组X和Y的两个中位数MedX和MedY。则会有以下情况\n* （1）MedX==MedY。则很明显MedX即是2n个数的中位数。因为两个数组是完全等长的，所以两个数组中位数两边的数的个数，也是完全一样的。\n\n* （2）MedX>MedY\n  * 如果n是奇数\n这种情况下，比X<sub>(n-1)/2+1</sub>,X<sub>(n-1)/2+2</sub>,...,X<sub>n-1</sub>小的数至少有n+1个，所以X<sub>(n-1)/2+1</sub>,X<sub>(n-1)/2+2</sub>,...,X<sub>n-1</sub>一定比中位数大。所以中位数不会在X<sub>(n-1)/2+1</sub>,X(n-1)/2+2</sub>,...,X<sub>n-1</sub>中。同样Y<sub>0</sub>,Y<sub>1</sub>,...,Y<sub>(n-1)/2-1</sub>一定比中位数小。所以中位数在X<sub>0</sub>,X<sub>1</sub>,...,X<sub>(n-1)/2</sub>和Y<sub>(n-1)/2</sub>,Y<sub>n/2+2</sub>,...,Y<sub>n-1</sub>中。则只需要考察X[0:(n-1)/2:n-1]和Y[0:(n-1)/2]。\n  * 如果n是偶数\n  则X<sub>(n-1)/2+2</sub>,X<sub>(n-1)/2+3</sub>,...,X<sub>n-1</sub>小的数至少有n+1个，所以X<sub>(n-1)/2+2</sub>,X<sub>(n-1)/2+3</sub>,...,X<sub>n-1</sub>一定比中位数大。同样Y<sub>0</sub>,Y<sub>1</sub>,...,Y<sub>(n-)/2-2</sub>一定比中位数小。则只需要考察X[0:(n-1)/2+1]和Y[(n-1)/2-1:n-1]。\n\n由于在中位数两边加上或减去任意等数量的数并不影响中位数的取值,所以上述方法成立。\n* （3）MedX<MedY\n这种情况和上面的同理\n\n分到最后每个数组只有两个元素，则不可以再分下去，利用X和Y的中位数用直接方法求解。\n  \n``` c++\n#include<iostream>\nusing namespace std;\n/*\n函数名：FindMedian\n功能：  求数组的某一区间的中位数\n参数：  double Z[]-所求数组，int zl-数组的最小下标，int zr-数组的最大下标\n返回值：double-中位数\n*/\ndouble FindMedian(double Z[],int zl,int zr){\n       if((zr-zl)%2==0){\n           return Z[(zr+zl)/2];\n       }else{\n           return (Z[(zr+zl)/2]+Z[(zr+zl)/2+1])/2;\n       }\n}\n/*\n函数名：FindMedian\n功能：  求分别有序数组X某一区间和有序数组Y某一区间的混合中位数\n参数：  int X[]-数组X，int xl-数组X要考察的最小下标，int xr-数组x要考察的最大下标\n返回值：double-混合中位数\n*/\ndouble FindMixMedian(double X[],int xl,int xr,double Y[],int yl,int yr){\n    \n    double MedX=FindMedian(X,xl,xr);// 求X考察区域的中位数\n    double MedY=FindMedian(Y,yl,yr);// 求y所考察区域的中位数\n    // 若两个中位数相等，则所求便是混合区间的中位数\n    if(abs(MedX-MedY)<0.00001){\n        return MedY;\n    }\n    // 若两边都只剩一个了，就取平均\n    if(xl==xr&&yl==yr){\n        return (X[xl]+Y[xl])/2;\n    }\n    // 若每个数组只剩两个，则讨论求出中位数\n    if(xr-xl+1==2&&yr-yl+1==2){\n        // 若MedX大，则X[xr]大于X[xl]和Y[YL],则判断X[xr]和Y[yr]\n        if(MedX>MedY){    \n            if(X[xr]>=Y[yr]){     // 若X[xr]>=Y[yr],则可以确定地关系是Y[yl]<=Y[yr]<=X[xr]\n                if(X[xl]<Y[yl]){  // X[xl]<Y[yl]<=Y[yr]<=X[xr] \n                    return ((Y[yl]+Y[yr])/2);\n                }else{            // Y[yl]<=Y[yr]<X[xl]<=X[xr]或 Y[yl]<=X[xl]<=Y[yr]<=X[xr]\n                    return ((X[xl]+Y[yr])/2);\n                }\n            }else{ // 如果X[xr]比Y[Yr]小，则X[xl]一定比Y[yl]大,则 Y[yl]<X[xl]<=X[xr]<Y[yr]\n             return MedX;\n            }\n        }\n        // 若MedY大，则与上面的对称\n        if(MedX<MedY){     \n            if(Y[yr]>=X[xr]){\n                if(Y[yl]<X[xl]){\n                    return ((X[xl]+X[xr])/2);\n                }else{    \n                    return ((Y[yl]+X[xr])/2);\n                }  \n            } else{\n                return MedY;\n            }\n         }\n\n    }\n    // 区间划分\n    if(MedX>MedY){   // MedX大时，X取小的部分，Y取大的部分\n        if((xl-xr+1)%2!=0){    // 若区间个数为奇数\n           return FindMixMedian(X,xl,(xl+xr)/2,Y,(yl+yr)/2,yr);\n        }else{\n           return FindMixMedian(X,xl,(xl+xr)/2+1,Y,(yl+yr)/2,yr);\n        }\n    }else{           // MedX小时，X取大的部分，Y取小的部分\n        if((xl-xr+1)%2!=0){    // 若区间个数为奇数\n           return FindMixMedian(X,(xl+xr)/2,xr,Y,yl,(yl+yr)/2);\n        }else{\n           return FindMixMedian(X,(xl+xr)/2,xr,Y,yl,(yl+yr)/2+1);\n        }\n    }\n}\nint main(){\n    freopen(\"input1.txt\",\"r\",stdin);\n    freopen(\"output1.txt\",\"w\",stdout);\n    int n;     // 数组X和Y中每个数组所含有的元素个数   \n    double X[202]; \n    double Y[202];\n    double ans;\n    cin>>n;\n    for(int i = 0;i<n;++i){\n        cin>>X[i];\n    }\n    for(int i = 0;i<n;++i){\n        cin>>Y[i];\n    }\n    ans = FindMixMedian(X,0,n-1,Y,0,n-1);\n    cout<<ans<<endl;\n}\n```","source":"_posts/在O-logn-的复杂度下两数组的混合中位数.md","raw":"---\ntitle: 在O(logn)的复杂度下两数组的混合中位数\ndate: 2021-04-10 23:32:41\ncategories:\n  -算法\ntags:\n  -分治法\n---\n### 题目 \n设X[ 0 : n - 1]和Y[ 0 : n – 1 ]为两个数组，每个数组中含有n个已排好序的数。找出X和Y的2n个数的中位数。要求：O(logn)时间内\n\n##### 解析\n要在O(logn)时间内求解，则自然想到分治算法。求解思路与如下：\n先分别求数组X和Y的两个中位数MedX和MedY。则会有以下情况\n* （1）MedX==MedY。则很明显MedX即是2n个数的中位数。因为两个数组是完全等长的，所以两个数组中位数两边的数的个数，也是完全一样的。\n\n* （2）MedX>MedY\n  * 如果n是奇数\n这种情况下，比X<sub>(n-1)/2+1</sub>,X<sub>(n-1)/2+2</sub>,...,X<sub>n-1</sub>小的数至少有n+1个，所以X<sub>(n-1)/2+1</sub>,X<sub>(n-1)/2+2</sub>,...,X<sub>n-1</sub>一定比中位数大。所以中位数不会在X<sub>(n-1)/2+1</sub>,X(n-1)/2+2</sub>,...,X<sub>n-1</sub>中。同样Y<sub>0</sub>,Y<sub>1</sub>,...,Y<sub>(n-1)/2-1</sub>一定比中位数小。所以中位数在X<sub>0</sub>,X<sub>1</sub>,...,X<sub>(n-1)/2</sub>和Y<sub>(n-1)/2</sub>,Y<sub>n/2+2</sub>,...,Y<sub>n-1</sub>中。则只需要考察X[0:(n-1)/2:n-1]和Y[0:(n-1)/2]。\n  * 如果n是偶数\n  则X<sub>(n-1)/2+2</sub>,X<sub>(n-1)/2+3</sub>,...,X<sub>n-1</sub>小的数至少有n+1个，所以X<sub>(n-1)/2+2</sub>,X<sub>(n-1)/2+3</sub>,...,X<sub>n-1</sub>一定比中位数大。同样Y<sub>0</sub>,Y<sub>1</sub>,...,Y<sub>(n-)/2-2</sub>一定比中位数小。则只需要考察X[0:(n-1)/2+1]和Y[(n-1)/2-1:n-1]。\n\n由于在中位数两边加上或减去任意等数量的数并不影响中位数的取值,所以上述方法成立。\n* （3）MedX<MedY\n这种情况和上面的同理\n\n分到最后每个数组只有两个元素，则不可以再分下去，利用X和Y的中位数用直接方法求解。\n  \n``` c++\n#include<iostream>\nusing namespace std;\n/*\n函数名：FindMedian\n功能：  求数组的某一区间的中位数\n参数：  double Z[]-所求数组，int zl-数组的最小下标，int zr-数组的最大下标\n返回值：double-中位数\n*/\ndouble FindMedian(double Z[],int zl,int zr){\n       if((zr-zl)%2==0){\n           return Z[(zr+zl)/2];\n       }else{\n           return (Z[(zr+zl)/2]+Z[(zr+zl)/2+1])/2;\n       }\n}\n/*\n函数名：FindMedian\n功能：  求分别有序数组X某一区间和有序数组Y某一区间的混合中位数\n参数：  int X[]-数组X，int xl-数组X要考察的最小下标，int xr-数组x要考察的最大下标\n返回值：double-混合中位数\n*/\ndouble FindMixMedian(double X[],int xl,int xr,double Y[],int yl,int yr){\n    \n    double MedX=FindMedian(X,xl,xr);// 求X考察区域的中位数\n    double MedY=FindMedian(Y,yl,yr);// 求y所考察区域的中位数\n    // 若两个中位数相等，则所求便是混合区间的中位数\n    if(abs(MedX-MedY)<0.00001){\n        return MedY;\n    }\n    // 若两边都只剩一个了，就取平均\n    if(xl==xr&&yl==yr){\n        return (X[xl]+Y[xl])/2;\n    }\n    // 若每个数组只剩两个，则讨论求出中位数\n    if(xr-xl+1==2&&yr-yl+1==2){\n        // 若MedX大，则X[xr]大于X[xl]和Y[YL],则判断X[xr]和Y[yr]\n        if(MedX>MedY){    \n            if(X[xr]>=Y[yr]){     // 若X[xr]>=Y[yr],则可以确定地关系是Y[yl]<=Y[yr]<=X[xr]\n                if(X[xl]<Y[yl]){  // X[xl]<Y[yl]<=Y[yr]<=X[xr] \n                    return ((Y[yl]+Y[yr])/2);\n                }else{            // Y[yl]<=Y[yr]<X[xl]<=X[xr]或 Y[yl]<=X[xl]<=Y[yr]<=X[xr]\n                    return ((X[xl]+Y[yr])/2);\n                }\n            }else{ // 如果X[xr]比Y[Yr]小，则X[xl]一定比Y[yl]大,则 Y[yl]<X[xl]<=X[xr]<Y[yr]\n             return MedX;\n            }\n        }\n        // 若MedY大，则与上面的对称\n        if(MedX<MedY){     \n            if(Y[yr]>=X[xr]){\n                if(Y[yl]<X[xl]){\n                    return ((X[xl]+X[xr])/2);\n                }else{    \n                    return ((Y[yl]+X[xr])/2);\n                }  \n            } else{\n                return MedY;\n            }\n         }\n\n    }\n    // 区间划分\n    if(MedX>MedY){   // MedX大时，X取小的部分，Y取大的部分\n        if((xl-xr+1)%2!=0){    // 若区间个数为奇数\n           return FindMixMedian(X,xl,(xl+xr)/2,Y,(yl+yr)/2,yr);\n        }else{\n           return FindMixMedian(X,xl,(xl+xr)/2+1,Y,(yl+yr)/2,yr);\n        }\n    }else{           // MedX小时，X取大的部分，Y取小的部分\n        if((xl-xr+1)%2!=0){    // 若区间个数为奇数\n           return FindMixMedian(X,(xl+xr)/2,xr,Y,yl,(yl+yr)/2);\n        }else{\n           return FindMixMedian(X,(xl+xr)/2,xr,Y,yl,(yl+yr)/2+1);\n        }\n    }\n}\nint main(){\n    freopen(\"input1.txt\",\"r\",stdin);\n    freopen(\"output1.txt\",\"w\",stdout);\n    int n;     // 数组X和Y中每个数组所含有的元素个数   \n    double X[202]; \n    double Y[202];\n    double ans;\n    cin>>n;\n    for(int i = 0;i<n;++i){\n        cin>>X[i];\n    }\n    for(int i = 0;i<n;++i){\n        cin>>Y[i];\n    }\n    ans = FindMixMedian(X,0,n-1,Y,0,n-1);\n    cout<<ans<<endl;\n}\n```","slug":"在O-logn-的复杂度下两数组的混合中位数","published":1,"updated":"2021-04-17T05:53:34.414Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckpp77ovm000au8tkc3sf0c91","content":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p>设X[ 0 : n - 1]和Y[ 0 : n – 1 ]为两个数组，每个数组中含有n个已排好序的数。找出X和Y的2n个数的中位数。要求：O(logn)时间内</p>\n<h5 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h5><p>要在O(logn)时间内求解，则自然想到分治算法。求解思路与如下：<br>先分别求数组X和Y的两个中位数MedX和MedY。则会有以下情况</p>\n<ul>\n<li><p>（1）MedX==MedY。则很明显MedX即是2n个数的中位数。因为两个数组是完全等长的，所以两个数组中位数两边的数的个数，也是完全一样的。</p>\n</li>\n<li><p>（2）MedX&gt;MedY</p>\n<ul>\n<li>如果n是奇数<br>这种情况下，比X<sub>(n-1)/2+1</sub>,X<sub>(n-1)/2+2</sub>,…,X<sub>n-1</sub>小的数至少有n+1个，所以X<sub>(n-1)/2+1</sub>,X<sub>(n-1)/2+2</sub>,…,X<sub>n-1</sub>一定比中位数大。所以中位数不会在X<sub>(n-1)/2+1</sub>,X(n-1)/2+2</sub>,…,X<sub>n-1</sub>中。同样Y<sub>0</sub>,Y<sub>1</sub>,…,Y<sub>(n-1)/2-1</sub>一定比中位数小。所以中位数在X<sub>0</sub>,X<sub>1</sub>,…,X<sub>(n-1)/2</sub>和Y<sub>(n-1)/2</sub>,Y<sub>n/2+2</sub>,…,Y<sub>n-1</sub>中。则只需要考察X[0:(n-1)/2:n-1]和Y[0:(n-1)/2]。</li>\n<li>如果n是偶数<br>则X<sub>(n-1)/2+2</sub>,X<sub>(n-1)/2+3</sub>,…,X<sub>n-1</sub>小的数至少有n+1个，所以X<sub>(n-1)/2+2</sub>,X<sub>(n-1)/2+3</sub>,…,X<sub>n-1</sub>一定比中位数大。同样Y<sub>0</sub>,Y<sub>1</sub>,…,Y<sub>(n-)/2-2</sub>一定比中位数小。则只需要考察X[0:(n-1)/2+1]和Y[(n-1)/2-1:n-1]。</li>\n</ul>\n</li>\n</ul>\n<p>由于在中位数两边加上或减去任意等数量的数并不影响中位数的取值,所以上述方法成立。</p>\n<ul>\n<li>（3）MedX&lt;MedY<br>这种情况和上面的同理</li>\n</ul>\n<p>分到最后每个数组只有两个元素，则不可以再分下去，利用X和Y的中位数用直接方法求解。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">函数名：FindMedian</span></span><br><span class=\"line\"><span class=\"comment\">功能：  求数组的某一区间的中位数</span></span><br><span class=\"line\"><span class=\"comment\">参数：  double Z[]-所求数组，int zl-数组的最小下标，int zr-数组的最大下标</span></span><br><span class=\"line\"><span class=\"comment\">返回值：double-中位数</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">FindMedian</span><span class=\"params\">(<span class=\"keyword\">double</span> Z[],<span class=\"keyword\">int</span> zl,<span class=\"keyword\">int</span> zr)</span></span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span>((zr-zl)%<span class=\"number\">2</span>==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> Z[(zr+zl)/<span class=\"number\">2</span>];</span><br><span class=\"line\">       &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">           <span class=\"built_in\"><span class=\"keyword\">return</span></span> (Z[(zr+zl)/<span class=\"number\">2</span>]+Z[(zr+zl)/<span class=\"number\">2</span>+<span class=\"number\">1</span>])/<span class=\"number\">2</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">函数名：FindMedian</span></span><br><span class=\"line\"><span class=\"comment\">功能：  求分别有序数组X某一区间和有序数组Y某一区间的混合中位数</span></span><br><span class=\"line\"><span class=\"comment\">参数：  int X[]-数组X，int xl-数组X要考察的最小下标，int xr-数组x要考察的最大下标</span></span><br><span class=\"line\"><span class=\"comment\">返回值：double-混合中位数</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">FindMixMedian</span><span class=\"params\">(<span class=\"keyword\">double</span> X[],<span class=\"keyword\">int</span> xl,<span class=\"keyword\">int</span> xr,<span class=\"keyword\">double</span> Y[],<span class=\"keyword\">int</span> yl,<span class=\"keyword\">int</span> yr)</span></span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">double</span> MedX=<span class=\"built_in\">FindMedian</span>(X,xl,xr);<span class=\"comment\">// 求X考察区域的中位数</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> MedY=<span class=\"built_in\">FindMedian</span>(Y,yl,yr);<span class=\"comment\">// 求y所考察区域的中位数</span></span><br><span class=\"line\">    <span class=\"comment\">// 若两个中位数相等，则所求便是混合区间的中位数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">abs</span>(MedX-MedY)&lt;<span class=\"number\">0.00001</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> MedY;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 若两边都只剩一个了，就取平均</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(xl==xr&amp;&amp;yl==yr)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (X[xl]+Y[xl])/<span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 若每个数组只剩两个，则讨论求出中位数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(xr-xl+<span class=\"number\">1</span>==<span class=\"number\">2</span>&amp;&amp;yr-yl+<span class=\"number\">1</span>==<span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 若MedX大，则X[xr]大于X[xl]和Y[YL],则判断X[xr]和Y[yr]</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(MedX&gt;MedY)&#123;    </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(X[xr]&gt;=Y[yr])&#123;     <span class=\"comment\">// 若X[xr]&gt;=Y[yr],则可以确定地关系是Y[yl]&lt;=Y[yr]&lt;=X[xr]</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(X[xl]&lt;Y[yl])&#123;  <span class=\"comment\">// X[xl]&lt;Y[yl]&lt;=Y[yr]&lt;=X[xr] </span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> ((Y[yl]+Y[yr])/<span class=\"number\">2</span>);</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;            <span class=\"comment\">// Y[yl]&lt;=Y[yr]&lt;X[xl]&lt;=X[xr]或 Y[yl]&lt;=X[xl]&lt;=Y[yr]&lt;=X[xr]</span></span><br><span class=\"line\">                    <span class=\"built_in\"><span class=\"keyword\">return</span></span> ((X[xl]+Y[yr])/<span class=\"number\">2</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123; <span class=\"comment\">// 如果X[xr]比Y[Yr]小，则X[xl]一定比Y[yl]大,则 Y[yl]&lt;X[xl]&lt;=X[xr]&lt;Y[yr]</span></span><br><span class=\"line\">             <span class=\"keyword\">return</span> MedX;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 若MedY大，则与上面的对称</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(MedX&lt;MedY)&#123;     </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(Y[yr]&gt;=X[xr])&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(Y[yl]&lt;X[xl])&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> ((X[xl]+X[xr])/<span class=\"number\">2</span>);</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;    </span><br><span class=\"line\">                    <span class=\"built_in\"><span class=\"keyword\">return</span></span> ((Y[yl]+X[xr])/<span class=\"number\">2</span>);</span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> MedY;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 区间划分</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(MedX&gt;MedY)&#123;   <span class=\"comment\">// MedX大时，X取小的部分，Y取大的部分</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>((xl-xr+<span class=\"number\">1</span>)%<span class=\"number\">2</span>!=<span class=\"number\">0</span>)&#123;    <span class=\"comment\">// 若区间个数为奇数</span></span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"built_in\">FindMixMedian</span>(X,xl,(xl+xr)/<span class=\"number\">2</span>,Y,(yl+yr)/<span class=\"number\">2</span>,yr);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"built_in\">FindMixMedian</span>(X,xl,(xl+xr)/<span class=\"number\">2</span>+<span class=\"number\">1</span>,Y,(yl+yr)/<span class=\"number\">2</span>,yr);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;           <span class=\"comment\">// MedX小时，X取大的部分，Y取小的部分</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>((xl-xr+<span class=\"number\">1</span>)%<span class=\"number\">2</span>!=<span class=\"number\">0</span>)&#123;    <span class=\"comment\">// 若区间个数为奇数</span></span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"built_in\">FindMixMedian</span>(X,(xl+xr)/<span class=\"number\">2</span>,xr,Y,yl,(yl+yr)/<span class=\"number\">2</span>);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"built_in\">FindMixMedian</span>(X,(xl+xr)/<span class=\"number\">2</span>,xr,Y,yl,(yl+yr)/<span class=\"number\">2</span>+<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">freopen</span>(<span class=\"string\">&quot;input1.txt&quot;</span>,<span class=\"string\">&quot;r&quot;</span>,stdin);</span><br><span class=\"line\">    <span class=\"built_in\">freopen</span>(<span class=\"string\">&quot;output1.txt&quot;</span>,<span class=\"string\">&quot;w&quot;</span>,stdout);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;     <span class=\"comment\">// 数组X和Y中每个数组所含有的元素个数   </span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> X[<span class=\"number\">202</span>]; </span><br><span class=\"line\">    <span class=\"keyword\">double</span> Y[<span class=\"number\">202</span>];</span><br><span class=\"line\">    <span class=\"keyword\">double</span> ans;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">        cin&gt;&gt;X[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">        cin&gt;&gt;Y[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ans = <span class=\"built_in\">FindMixMedian</span>(X,<span class=\"number\">0</span>,n<span class=\"number\">-1</span>,Y,<span class=\"number\">0</span>,n<span class=\"number\">-1</span>);</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p>设X[ 0 : n - 1]和Y[ 0 : n – 1 ]为两个数组，每个数组中含有n个已排好序的数。找出X和Y的2n个数的中位数。要求：O(logn)时间内</p>\n<h5 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h5><p>要在O(logn)时间内求解，则自然想到分治算法。求解思路与如下：<br>先分别求数组X和Y的两个中位数MedX和MedY。则会有以下情况</p>\n<ul>\n<li><p>（1）MedX==MedY。则很明显MedX即是2n个数的中位数。因为两个数组是完全等长的，所以两个数组中位数两边的数的个数，也是完全一样的。</p>\n</li>\n<li><p>（2）MedX&gt;MedY</p>\n<ul>\n<li>如果n是奇数<br>这种情况下，比X<sub>(n-1)/2+1</sub>,X<sub>(n-1)/2+2</sub>,…,X<sub>n-1</sub>小的数至少有n+1个，所以X<sub>(n-1)/2+1</sub>,X<sub>(n-1)/2+2</sub>,…,X<sub>n-1</sub>一定比中位数大。所以中位数不会在X<sub>(n-1)/2+1</sub>,X(n-1)/2+2</sub>,…,X<sub>n-1</sub>中。同样Y<sub>0</sub>,Y<sub>1</sub>,…,Y<sub>(n-1)/2-1</sub>一定比中位数小。所以中位数在X<sub>0</sub>,X<sub>1</sub>,…,X<sub>(n-1)/2</sub>和Y<sub>(n-1)/2</sub>,Y<sub>n/2+2</sub>,…,Y<sub>n-1</sub>中。则只需要考察X[0:(n-1)/2:n-1]和Y[0:(n-1)/2]。</li>\n<li>如果n是偶数<br>则X<sub>(n-1)/2+2</sub>,X<sub>(n-1)/2+3</sub>,…,X<sub>n-1</sub>小的数至少有n+1个，所以X<sub>(n-1)/2+2</sub>,X<sub>(n-1)/2+3</sub>,…,X<sub>n-1</sub>一定比中位数大。同样Y<sub>0</sub>,Y<sub>1</sub>,…,Y<sub>(n-)/2-2</sub>一定比中位数小。则只需要考察X[0:(n-1)/2+1]和Y[(n-1)/2-1:n-1]。</li>\n</ul>\n</li>\n</ul>\n<p>由于在中位数两边加上或减去任意等数量的数并不影响中位数的取值,所以上述方法成立。</p>\n<ul>\n<li>（3）MedX&lt;MedY<br>这种情况和上面的同理</li>\n</ul>\n<p>分到最后每个数组只有两个元素，则不可以再分下去，利用X和Y的中位数用直接方法求解。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">函数名：FindMedian</span></span><br><span class=\"line\"><span class=\"comment\">功能：  求数组的某一区间的中位数</span></span><br><span class=\"line\"><span class=\"comment\">参数：  double Z[]-所求数组，int zl-数组的最小下标，int zr-数组的最大下标</span></span><br><span class=\"line\"><span class=\"comment\">返回值：double-中位数</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">FindMedian</span><span class=\"params\">(<span class=\"keyword\">double</span> Z[],<span class=\"keyword\">int</span> zl,<span class=\"keyword\">int</span> zr)</span></span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span>((zr-zl)%<span class=\"number\">2</span>==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> Z[(zr+zl)/<span class=\"number\">2</span>];</span><br><span class=\"line\">       &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">           <span class=\"built_in\"><span class=\"keyword\">return</span></span> (Z[(zr+zl)/<span class=\"number\">2</span>]+Z[(zr+zl)/<span class=\"number\">2</span>+<span class=\"number\">1</span>])/<span class=\"number\">2</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">函数名：FindMedian</span></span><br><span class=\"line\"><span class=\"comment\">功能：  求分别有序数组X某一区间和有序数组Y某一区间的混合中位数</span></span><br><span class=\"line\"><span class=\"comment\">参数：  int X[]-数组X，int xl-数组X要考察的最小下标，int xr-数组x要考察的最大下标</span></span><br><span class=\"line\"><span class=\"comment\">返回值：double-混合中位数</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">FindMixMedian</span><span class=\"params\">(<span class=\"keyword\">double</span> X[],<span class=\"keyword\">int</span> xl,<span class=\"keyword\">int</span> xr,<span class=\"keyword\">double</span> Y[],<span class=\"keyword\">int</span> yl,<span class=\"keyword\">int</span> yr)</span></span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">double</span> MedX=<span class=\"built_in\">FindMedian</span>(X,xl,xr);<span class=\"comment\">// 求X考察区域的中位数</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> MedY=<span class=\"built_in\">FindMedian</span>(Y,yl,yr);<span class=\"comment\">// 求y所考察区域的中位数</span></span><br><span class=\"line\">    <span class=\"comment\">// 若两个中位数相等，则所求便是混合区间的中位数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">abs</span>(MedX-MedY)&lt;<span class=\"number\">0.00001</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> MedY;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 若两边都只剩一个了，就取平均</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(xl==xr&amp;&amp;yl==yr)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (X[xl]+Y[xl])/<span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 若每个数组只剩两个，则讨论求出中位数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(xr-xl+<span class=\"number\">1</span>==<span class=\"number\">2</span>&amp;&amp;yr-yl+<span class=\"number\">1</span>==<span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 若MedX大，则X[xr]大于X[xl]和Y[YL],则判断X[xr]和Y[yr]</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(MedX&gt;MedY)&#123;    </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(X[xr]&gt;=Y[yr])&#123;     <span class=\"comment\">// 若X[xr]&gt;=Y[yr],则可以确定地关系是Y[yl]&lt;=Y[yr]&lt;=X[xr]</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(X[xl]&lt;Y[yl])&#123;  <span class=\"comment\">// X[xl]&lt;Y[yl]&lt;=Y[yr]&lt;=X[xr] </span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> ((Y[yl]+Y[yr])/<span class=\"number\">2</span>);</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;            <span class=\"comment\">// Y[yl]&lt;=Y[yr]&lt;X[xl]&lt;=X[xr]或 Y[yl]&lt;=X[xl]&lt;=Y[yr]&lt;=X[xr]</span></span><br><span class=\"line\">                    <span class=\"built_in\"><span class=\"keyword\">return</span></span> ((X[xl]+Y[yr])/<span class=\"number\">2</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123; <span class=\"comment\">// 如果X[xr]比Y[Yr]小，则X[xl]一定比Y[yl]大,则 Y[yl]&lt;X[xl]&lt;=X[xr]&lt;Y[yr]</span></span><br><span class=\"line\">             <span class=\"keyword\">return</span> MedX;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 若MedY大，则与上面的对称</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(MedX&lt;MedY)&#123;     </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(Y[yr]&gt;=X[xr])&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(Y[yl]&lt;X[xl])&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> ((X[xl]+X[xr])/<span class=\"number\">2</span>);</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;    </span><br><span class=\"line\">                    <span class=\"built_in\"><span class=\"keyword\">return</span></span> ((Y[yl]+X[xr])/<span class=\"number\">2</span>);</span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> MedY;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 区间划分</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(MedX&gt;MedY)&#123;   <span class=\"comment\">// MedX大时，X取小的部分，Y取大的部分</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>((xl-xr+<span class=\"number\">1</span>)%<span class=\"number\">2</span>!=<span class=\"number\">0</span>)&#123;    <span class=\"comment\">// 若区间个数为奇数</span></span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"built_in\">FindMixMedian</span>(X,xl,(xl+xr)/<span class=\"number\">2</span>,Y,(yl+yr)/<span class=\"number\">2</span>,yr);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"built_in\">FindMixMedian</span>(X,xl,(xl+xr)/<span class=\"number\">2</span>+<span class=\"number\">1</span>,Y,(yl+yr)/<span class=\"number\">2</span>,yr);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;           <span class=\"comment\">// MedX小时，X取大的部分，Y取小的部分</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>((xl-xr+<span class=\"number\">1</span>)%<span class=\"number\">2</span>!=<span class=\"number\">0</span>)&#123;    <span class=\"comment\">// 若区间个数为奇数</span></span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"built_in\">FindMixMedian</span>(X,(xl+xr)/<span class=\"number\">2</span>,xr,Y,yl,(yl+yr)/<span class=\"number\">2</span>);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"built_in\">FindMixMedian</span>(X,(xl+xr)/<span class=\"number\">2</span>,xr,Y,yl,(yl+yr)/<span class=\"number\">2</span>+<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">freopen</span>(<span class=\"string\">&quot;input1.txt&quot;</span>,<span class=\"string\">&quot;r&quot;</span>,stdin);</span><br><span class=\"line\">    <span class=\"built_in\">freopen</span>(<span class=\"string\">&quot;output1.txt&quot;</span>,<span class=\"string\">&quot;w&quot;</span>,stdout);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;     <span class=\"comment\">// 数组X和Y中每个数组所含有的元素个数   </span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> X[<span class=\"number\">202</span>]; </span><br><span class=\"line\">    <span class=\"keyword\">double</span> Y[<span class=\"number\">202</span>];</span><br><span class=\"line\">    <span class=\"keyword\">double</span> ans;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">        cin&gt;&gt;X[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">        cin&gt;&gt;Y[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ans = <span class=\"built_in\">FindMixMedian</span>(X,<span class=\"number\">0</span>,n<span class=\"number\">-1</span>,Y,<span class=\"number\">0</span>,n<span class=\"number\">-1</span>);</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"数据备份","date":"2021-06-11T07:52:27.000Z","_content":"# 题目\n{% asset_img backUp.png %}\n### 题目简述\n大概就是有n个办公楼，要找出k对，每对之间拉一个电缆，并且每个楼只能用一次，求出最小的距离之和\n\n### 分析\n- 首先要明确，找出的n对楼里面，每对肯定是相邻的，若不相邻，则令其中间的任一一对代替，能得到更优结果\n- 如果每次只选择最小那对，也是不行的，如：\n    - 现在有一个原始的对序列 2 1 2 5 6，要找两队。则放到优先队列中有 1 2 2 5 6，如果先选最小的，则现在选的是1，由于1中两个城市在2 2 这两队中，所以2 2 要丢掉。则优先队列中能用的只剩下 5 6，则下次应该选择5。不难发现，如果不选1的话，选2 2明显会比选1 5好。到这里不难发现，我们要后悔。、\n- 那么怎么进行后悔呢？\n    - 我们在选择最小的1之后，2 2 本来是要废掉的，但是我们不直接丢掉他们，而是创建一个新的数为 2+2-1=3 放入优先队列中。则优先队列中剩下的为 3 5 6，这样我们下次选3就相当于选了 2+2-1+1，即 2 2，后悔成功。\n\n### 算法\n每次取最小的一个区间，然后将这个数两边得区间合并，并减去这个数，构成后悔结点（则原区间最左边和最右边还应该加一段无穷大）。一直做下去，最终即可得到结果。\n区间段用链表维护。需要注意的是链表的更新。\n\n### 代码\n```c++\n#include<iostream>\n#include<cstring>\n#include<queue>\nusing namespace std;\nlong long s[100002];     // 每个公司到起点的距离\n\n// 每个相邻区间作为一个结点\ntypedef struct Node{\n      long long  Len;            // 区间的长度\n      int pos;                   // 当前结点的位置c\n}NODE;\n\n// 仿函数\nstruct tmp{\n    bool operator() (Node a,Node b){\n        return a.Len>b.Len;\n    }\n};\n\nbool isUsed[100002];// 判断某个结点是否已经使用过\nint Next[100002];   // 存放某个结点的下一个结点\nint Prio[100002];   // 存放某个节点的一个结点 \nlong long val[100002]; // 要得到某个位置的值信息，不能从队列里获得，要另存  \n\nNODE sNode;\nint main(){\n    //freopen(\"test/div1C.txt\",\"r\",stdin);\n    // 初始化标记数组\n    memset(isUsed,false,sizeof(isUsed));\n    int n,k;    // 办公楼数和可以铺设的电网数\n    long long ans=0;\n    cin>>n>>k;\n    for(int i =0;i<n;++i){\n        cin>>s[i];\n    }\n    priority_queue<NODE,vector<NODE>,tmp> Q;    // 设置一个小根堆存放现有结点\n    \n    \n\n    // 初始化第一个结点\n    sNode.Len=s[1]-s[0];\n    sNode.pos=1;    // 从1开始\n    Prio[1]=0;     // 第一个结点前驱为空\n    Next[1]=2;       // 后继为1\n    val[1]=sNode.Len;\n    Q.push(sNode);  // 第一个结点入队\n\n    // 初始化其他结点,最后一个结点的下标是n-1，因为一共有n-1个结点\n    for(int i =1; i<n-1;++i){\n        sNode.Len=s[i+1]-s[i];\n        sNode.pos=i+1;    \n        Prio[i+1]=i;     \n        Next[i+1]=i+2;       \n        val[i+1]=sNode.Len;\n        Q.push(sNode);     \n    }\n\n    // 两端设极大\n    val[0]=2e9;\n    val[n]=2e9;\n\n\n    // 进行贪心选择\n    while(k!=0){\n        // 跳过无效结点\n        while(isUsed[Q.top().pos]){\n            Q.pop();\n        }\n        sNode=Q.top();  // 取出长度最小的那个有效结点\n        Q.pop();\n        ans+=sNode.Len;  // 取了这个点，答案要加上\n        \n        // 求新的结点的长度，实现隐式反悔\n        sNode.Len=val[Prio[sNode.pos]]+val[Next[sNode.pos]]-val[sNode.pos];\n        val[sNode.pos]=sNode.Len;\n        \n      \n        // 两端设置为已使用\n        isUsed[Prio[sNode.pos]]=true;\n        isUsed[Next[sNode.pos]]=true;\n        //更新新结点的前驱后继\n        Prio[sNode.pos]=Prio[Prio[sNode.pos]];\n        Next[sNode.pos]=Next[Next[sNode.pos]];\n\n        // 更新前面的前面的后继和后面的后面的前驱\n        // 注意Prio[sNode.pos]和Next[sNode.pos]已经变了\n        Next[Prio[sNode.pos]]=sNode.pos;\n        Prio[Next[sNode.pos]]=sNode.pos;\n\n        // 新结点入队\n        Q.push(sNode);\n        --k;\n    }\n    cout<<ans<<endl;\n}\n```","source":"_posts/数据备份.md","raw":"---\ntitle: 数据备份\ndate: 2021-06-11 15:52:27\ncategories:\n    -div1\ntags:\n    -贪心\n    -反悔\n    -优先队列\n---\n# 题目\n{% asset_img backUp.png %}\n### 题目简述\n大概就是有n个办公楼，要找出k对，每对之间拉一个电缆，并且每个楼只能用一次，求出最小的距离之和\n\n### 分析\n- 首先要明确，找出的n对楼里面，每对肯定是相邻的，若不相邻，则令其中间的任一一对代替，能得到更优结果\n- 如果每次只选择最小那对，也是不行的，如：\n    - 现在有一个原始的对序列 2 1 2 5 6，要找两队。则放到优先队列中有 1 2 2 5 6，如果先选最小的，则现在选的是1，由于1中两个城市在2 2 这两队中，所以2 2 要丢掉。则优先队列中能用的只剩下 5 6，则下次应该选择5。不难发现，如果不选1的话，选2 2明显会比选1 5好。到这里不难发现，我们要后悔。、\n- 那么怎么进行后悔呢？\n    - 我们在选择最小的1之后，2 2 本来是要废掉的，但是我们不直接丢掉他们，而是创建一个新的数为 2+2-1=3 放入优先队列中。则优先队列中剩下的为 3 5 6，这样我们下次选3就相当于选了 2+2-1+1，即 2 2，后悔成功。\n\n### 算法\n每次取最小的一个区间，然后将这个数两边得区间合并，并减去这个数，构成后悔结点（则原区间最左边和最右边还应该加一段无穷大）。一直做下去，最终即可得到结果。\n区间段用链表维护。需要注意的是链表的更新。\n\n### 代码\n```c++\n#include<iostream>\n#include<cstring>\n#include<queue>\nusing namespace std;\nlong long s[100002];     // 每个公司到起点的距离\n\n// 每个相邻区间作为一个结点\ntypedef struct Node{\n      long long  Len;            // 区间的长度\n      int pos;                   // 当前结点的位置c\n}NODE;\n\n// 仿函数\nstruct tmp{\n    bool operator() (Node a,Node b){\n        return a.Len>b.Len;\n    }\n};\n\nbool isUsed[100002];// 判断某个结点是否已经使用过\nint Next[100002];   // 存放某个结点的下一个结点\nint Prio[100002];   // 存放某个节点的一个结点 \nlong long val[100002]; // 要得到某个位置的值信息，不能从队列里获得，要另存  \n\nNODE sNode;\nint main(){\n    //freopen(\"test/div1C.txt\",\"r\",stdin);\n    // 初始化标记数组\n    memset(isUsed,false,sizeof(isUsed));\n    int n,k;    // 办公楼数和可以铺设的电网数\n    long long ans=0;\n    cin>>n>>k;\n    for(int i =0;i<n;++i){\n        cin>>s[i];\n    }\n    priority_queue<NODE,vector<NODE>,tmp> Q;    // 设置一个小根堆存放现有结点\n    \n    \n\n    // 初始化第一个结点\n    sNode.Len=s[1]-s[0];\n    sNode.pos=1;    // 从1开始\n    Prio[1]=0;     // 第一个结点前驱为空\n    Next[1]=2;       // 后继为1\n    val[1]=sNode.Len;\n    Q.push(sNode);  // 第一个结点入队\n\n    // 初始化其他结点,最后一个结点的下标是n-1，因为一共有n-1个结点\n    for(int i =1; i<n-1;++i){\n        sNode.Len=s[i+1]-s[i];\n        sNode.pos=i+1;    \n        Prio[i+1]=i;     \n        Next[i+1]=i+2;       \n        val[i+1]=sNode.Len;\n        Q.push(sNode);     \n    }\n\n    // 两端设极大\n    val[0]=2e9;\n    val[n]=2e9;\n\n\n    // 进行贪心选择\n    while(k!=0){\n        // 跳过无效结点\n        while(isUsed[Q.top().pos]){\n            Q.pop();\n        }\n        sNode=Q.top();  // 取出长度最小的那个有效结点\n        Q.pop();\n        ans+=sNode.Len;  // 取了这个点，答案要加上\n        \n        // 求新的结点的长度，实现隐式反悔\n        sNode.Len=val[Prio[sNode.pos]]+val[Next[sNode.pos]]-val[sNode.pos];\n        val[sNode.pos]=sNode.Len;\n        \n      \n        // 两端设置为已使用\n        isUsed[Prio[sNode.pos]]=true;\n        isUsed[Next[sNode.pos]]=true;\n        //更新新结点的前驱后继\n        Prio[sNode.pos]=Prio[Prio[sNode.pos]];\n        Next[sNode.pos]=Next[Next[sNode.pos]];\n\n        // 更新前面的前面的后继和后面的后面的前驱\n        // 注意Prio[sNode.pos]和Next[sNode.pos]已经变了\n        Next[Prio[sNode.pos]]=sNode.pos;\n        Prio[Next[sNode.pos]]=sNode.pos;\n\n        // 新结点入队\n        Q.push(sNode);\n        --k;\n    }\n    cout<<ans<<endl;\n}\n```","slug":"数据备份","published":1,"updated":"2021-06-11T08:13:32.887Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckps1ze7u0000c0tkgsyfbk0y","content":"<h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><img src=\"/2021/06/11/%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/backUp.png\" class=\"\">\n<h3 id=\"题目简述\"><a href=\"#题目简述\" class=\"headerlink\" title=\"题目简述\"></a>题目简述</h3><p>大概就是有n个办公楼，要找出k对，每对之间拉一个电缆，并且每个楼只能用一次，求出最小的距离之和</p>\n<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><ul>\n<li>首先要明确，找出的n对楼里面，每对肯定是相邻的，若不相邻，则令其中间的任一一对代替，能得到更优结果</li>\n<li>如果每次只选择最小那对，也是不行的，如：<ul>\n<li>现在有一个原始的对序列 2 1 2 5 6，要找两队。则放到优先队列中有 1 2 2 5 6，如果先选最小的，则现在选的是1，由于1中两个城市在2 2 这两队中，所以2 2 要丢掉。则优先队列中能用的只剩下 5 6，则下次应该选择5。不难发现，如果不选1的话，选2 2明显会比选1 5好。到这里不难发现，我们要后悔。、</li>\n</ul>\n</li>\n<li>那么怎么进行后悔呢？<ul>\n<li>我们在选择最小的1之后，2 2 本来是要废掉的，但是我们不直接丢掉他们，而是创建一个新的数为 2+2-1=3 放入优先队列中。则优先队列中剩下的为 3 5 6，这样我们下次选3就相当于选了 2+2-1+1，即 2 2，后悔成功。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h3><p>每次取最小的一个区间，然后将这个数两边得区间合并，并减去这个数，构成后悔结点（则原区间最左边和最右边还应该加一段无穷大）。一直做下去，最终即可得到结果。<br>区间段用链表维护。需要注意的是链表的更新。</p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> s[<span class=\"number\">100002</span>];     <span class=\"comment\">// 每个公司到起点的距离</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 每个相邻区间作为一个结点</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span>&#123;</span></span><br><span class=\"line\">      <span class=\"keyword\">long</span> <span class=\"keyword\">long</span>  Len;            <span class=\"comment\">// 区间的长度</span></span><br><span class=\"line\">      <span class=\"keyword\">int</span> pos;                   <span class=\"comment\">// 当前结点的位置c</span></span><br><span class=\"line\">&#125;NODE;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 仿函数</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tmp</span>&#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">operator</span><span class=\"params\">()</span> <span class=\"params\">(Node a,Node b)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.Len&gt;b.Len;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">bool</span> isUsed[<span class=\"number\">100002</span>];<span class=\"comment\">// 判断某个结点是否已经使用过</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> Next[<span class=\"number\">100002</span>];   <span class=\"comment\">// 存放某个结点的下一个结点</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> Prio[<span class=\"number\">100002</span>];   <span class=\"comment\">// 存放某个节点的一个结点 </span></span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> val[<span class=\"number\">100002</span>]; <span class=\"comment\">// 要得到某个位置的值信息，不能从队列里获得，要另存  </span></span><br><span class=\"line\"></span><br><span class=\"line\">NODE sNode;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//freopen(&quot;test/div1C.txt&quot;,&quot;r&quot;,stdin);</span></span><br><span class=\"line\">    <span class=\"comment\">// 初始化标记数组</span></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(isUsed,<span class=\"literal\">false</span>,<span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(isUsed));</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n,k;    <span class=\"comment\">// 办公楼数和可以铺设的电网数</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i =<span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">        cin&gt;&gt;s[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    priority_queue&lt;NODE,vector&lt;NODE&gt;,tmp&gt; Q;    <span class=\"comment\">// 设置一个小根堆存放现有结点</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化第一个结点</span></span><br><span class=\"line\">    sNode.Len=s[<span class=\"number\">1</span>]-s[<span class=\"number\">0</span>];</span><br><span class=\"line\">    sNode.pos=<span class=\"number\">1</span>;    <span class=\"comment\">// 从1开始</span></span><br><span class=\"line\">    Prio[<span class=\"number\">1</span>]=<span class=\"number\">0</span>;     <span class=\"comment\">// 第一个结点前驱为空</span></span><br><span class=\"line\">    Next[<span class=\"number\">1</span>]=<span class=\"number\">2</span>;       <span class=\"comment\">// 后继为1</span></span><br><span class=\"line\">    val[<span class=\"number\">1</span>]=sNode.Len;</span><br><span class=\"line\">    Q.<span class=\"built_in\">push</span>(sNode);  <span class=\"comment\">// 第一个结点入队</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化其他结点,最后一个结点的下标是n-1，因为一共有n-1个结点</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i =<span class=\"number\">1</span>; i&lt;n<span class=\"number\">-1</span>;++i)&#123;</span><br><span class=\"line\">        sNode.Len=s[i+<span class=\"number\">1</span>]-s[i];</span><br><span class=\"line\">        sNode.pos=i+<span class=\"number\">1</span>;    </span><br><span class=\"line\">        Prio[i+<span class=\"number\">1</span>]=i;     </span><br><span class=\"line\">        Next[i+<span class=\"number\">1</span>]=i+<span class=\"number\">2</span>;       </span><br><span class=\"line\">        val[i+<span class=\"number\">1</span>]=sNode.Len;</span><br><span class=\"line\">        Q.<span class=\"built_in\">push</span>(sNode);     </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 两端设极大</span></span><br><span class=\"line\">    val[<span class=\"number\">0</span>]=<span class=\"number\">2e9</span>;</span><br><span class=\"line\">    val[n]=<span class=\"number\">2e9</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 进行贪心选择</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(k!=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 跳过无效结点</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(isUsed[Q.<span class=\"built_in\">top</span>().pos])&#123;</span><br><span class=\"line\">            Q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sNode=Q.<span class=\"built_in\">top</span>();  <span class=\"comment\">// 取出长度最小的那个有效结点</span></span><br><span class=\"line\">        Q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        ans+=sNode.Len;  <span class=\"comment\">// 取了这个点，答案要加上</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 求新的结点的长度，实现隐式反悔</span></span><br><span class=\"line\">        sNode.Len=val[Prio[sNode.pos]]+val[Next[sNode.pos]]-val[sNode.pos];</span><br><span class=\"line\">        val[sNode.pos]=sNode.Len;</span><br><span class=\"line\">        </span><br><span class=\"line\">      </span><br><span class=\"line\">        <span class=\"comment\">// 两端设置为已使用</span></span><br><span class=\"line\">        isUsed[Prio[sNode.pos]]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">        isUsed[Next[sNode.pos]]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"comment\">//更新新结点的前驱后继</span></span><br><span class=\"line\">        Prio[sNode.pos]=Prio[Prio[sNode.pos]];</span><br><span class=\"line\">        Next[sNode.pos]=Next[Next[sNode.pos]];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 更新前面的前面的后继和后面的后面的前驱</span></span><br><span class=\"line\">        <span class=\"comment\">// 注意Prio[sNode.pos]和Next[sNode.pos]已经变了</span></span><br><span class=\"line\">        Next[Prio[sNode.pos]]=sNode.pos;</span><br><span class=\"line\">        Prio[Next[sNode.pos]]=sNode.pos;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 新结点入队</span></span><br><span class=\"line\">        Q.<span class=\"built_in\">push</span>(sNode);</span><br><span class=\"line\">        --k;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><img src=\"/2021/06/11/%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/backUp.png\" class=\"\">\n<h3 id=\"题目简述\"><a href=\"#题目简述\" class=\"headerlink\" title=\"题目简述\"></a>题目简述</h3><p>大概就是有n个办公楼，要找出k对，每对之间拉一个电缆，并且每个楼只能用一次，求出最小的距离之和</p>\n<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><ul>\n<li>首先要明确，找出的n对楼里面，每对肯定是相邻的，若不相邻，则令其中间的任一一对代替，能得到更优结果</li>\n<li>如果每次只选择最小那对，也是不行的，如：<ul>\n<li>现在有一个原始的对序列 2 1 2 5 6，要找两队。则放到优先队列中有 1 2 2 5 6，如果先选最小的，则现在选的是1，由于1中两个城市在2 2 这两队中，所以2 2 要丢掉。则优先队列中能用的只剩下 5 6，则下次应该选择5。不难发现，如果不选1的话，选2 2明显会比选1 5好。到这里不难发现，我们要后悔。、</li>\n</ul>\n</li>\n<li>那么怎么进行后悔呢？<ul>\n<li>我们在选择最小的1之后，2 2 本来是要废掉的，但是我们不直接丢掉他们，而是创建一个新的数为 2+2-1=3 放入优先队列中。则优先队列中剩下的为 3 5 6，这样我们下次选3就相当于选了 2+2-1+1，即 2 2，后悔成功。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h3><p>每次取最小的一个区间，然后将这个数两边得区间合并，并减去这个数，构成后悔结点（则原区间最左边和最右边还应该加一段无穷大）。一直做下去，最终即可得到结果。<br>区间段用链表维护。需要注意的是链表的更新。</p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> s[<span class=\"number\">100002</span>];     <span class=\"comment\">// 每个公司到起点的距离</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 每个相邻区间作为一个结点</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span>&#123;</span></span><br><span class=\"line\">      <span class=\"keyword\">long</span> <span class=\"keyword\">long</span>  Len;            <span class=\"comment\">// 区间的长度</span></span><br><span class=\"line\">      <span class=\"keyword\">int</span> pos;                   <span class=\"comment\">// 当前结点的位置c</span></span><br><span class=\"line\">&#125;NODE;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 仿函数</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tmp</span>&#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">operator</span><span class=\"params\">()</span> <span class=\"params\">(Node a,Node b)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.Len&gt;b.Len;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">bool</span> isUsed[<span class=\"number\">100002</span>];<span class=\"comment\">// 判断某个结点是否已经使用过</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> Next[<span class=\"number\">100002</span>];   <span class=\"comment\">// 存放某个结点的下一个结点</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> Prio[<span class=\"number\">100002</span>];   <span class=\"comment\">// 存放某个节点的一个结点 </span></span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> val[<span class=\"number\">100002</span>]; <span class=\"comment\">// 要得到某个位置的值信息，不能从队列里获得，要另存  </span></span><br><span class=\"line\"></span><br><span class=\"line\">NODE sNode;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//freopen(&quot;test/div1C.txt&quot;,&quot;r&quot;,stdin);</span></span><br><span class=\"line\">    <span class=\"comment\">// 初始化标记数组</span></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(isUsed,<span class=\"literal\">false</span>,<span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(isUsed));</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n,k;    <span class=\"comment\">// 办公楼数和可以铺设的电网数</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i =<span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">        cin&gt;&gt;s[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    priority_queue&lt;NODE,vector&lt;NODE&gt;,tmp&gt; Q;    <span class=\"comment\">// 设置一个小根堆存放现有结点</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化第一个结点</span></span><br><span class=\"line\">    sNode.Len=s[<span class=\"number\">1</span>]-s[<span class=\"number\">0</span>];</span><br><span class=\"line\">    sNode.pos=<span class=\"number\">1</span>;    <span class=\"comment\">// 从1开始</span></span><br><span class=\"line\">    Prio[<span class=\"number\">1</span>]=<span class=\"number\">0</span>;     <span class=\"comment\">// 第一个结点前驱为空</span></span><br><span class=\"line\">    Next[<span class=\"number\">1</span>]=<span class=\"number\">2</span>;       <span class=\"comment\">// 后继为1</span></span><br><span class=\"line\">    val[<span class=\"number\">1</span>]=sNode.Len;</span><br><span class=\"line\">    Q.<span class=\"built_in\">push</span>(sNode);  <span class=\"comment\">// 第一个结点入队</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化其他结点,最后一个结点的下标是n-1，因为一共有n-1个结点</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i =<span class=\"number\">1</span>; i&lt;n<span class=\"number\">-1</span>;++i)&#123;</span><br><span class=\"line\">        sNode.Len=s[i+<span class=\"number\">1</span>]-s[i];</span><br><span class=\"line\">        sNode.pos=i+<span class=\"number\">1</span>;    </span><br><span class=\"line\">        Prio[i+<span class=\"number\">1</span>]=i;     </span><br><span class=\"line\">        Next[i+<span class=\"number\">1</span>]=i+<span class=\"number\">2</span>;       </span><br><span class=\"line\">        val[i+<span class=\"number\">1</span>]=sNode.Len;</span><br><span class=\"line\">        Q.<span class=\"built_in\">push</span>(sNode);     </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 两端设极大</span></span><br><span class=\"line\">    val[<span class=\"number\">0</span>]=<span class=\"number\">2e9</span>;</span><br><span class=\"line\">    val[n]=<span class=\"number\">2e9</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 进行贪心选择</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(k!=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 跳过无效结点</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(isUsed[Q.<span class=\"built_in\">top</span>().pos])&#123;</span><br><span class=\"line\">            Q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sNode=Q.<span class=\"built_in\">top</span>();  <span class=\"comment\">// 取出长度最小的那个有效结点</span></span><br><span class=\"line\">        Q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        ans+=sNode.Len;  <span class=\"comment\">// 取了这个点，答案要加上</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 求新的结点的长度，实现隐式反悔</span></span><br><span class=\"line\">        sNode.Len=val[Prio[sNode.pos]]+val[Next[sNode.pos]]-val[sNode.pos];</span><br><span class=\"line\">        val[sNode.pos]=sNode.Len;</span><br><span class=\"line\">        </span><br><span class=\"line\">      </span><br><span class=\"line\">        <span class=\"comment\">// 两端设置为已使用</span></span><br><span class=\"line\">        isUsed[Prio[sNode.pos]]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">        isUsed[Next[sNode.pos]]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"comment\">//更新新结点的前驱后继</span></span><br><span class=\"line\">        Prio[sNode.pos]=Prio[Prio[sNode.pos]];</span><br><span class=\"line\">        Next[sNode.pos]=Next[Next[sNode.pos]];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 更新前面的前面的后继和后面的后面的前驱</span></span><br><span class=\"line\">        <span class=\"comment\">// 注意Prio[sNode.pos]和Next[sNode.pos]已经变了</span></span><br><span class=\"line\">        Next[Prio[sNode.pos]]=sNode.pos;</span><br><span class=\"line\">        Prio[Next[sNode.pos]]=sNode.pos;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 新结点入队</span></span><br><span class=\"line\">        Q.<span class=\"built_in\">push</span>(sNode);</span><br><span class=\"line\">        --k;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"BestCowFences","date":"2021-06-12T16:35:27.000Z","_content":"# 题目\n{% asset_img BestCowFence.png %}\n### 题目简介\n题目大概就是围起连续不小于f的数，使他们的平均值最大，求出这个最大值。\n### 分析\n 如果是求连续子序列最大和，那么问题就很简单。但是他这里要求的是最大平均数，由于最大平均数不仅和连续子序列的和有关，还和连续子序列的长度有关。即average=sum/length。则事情就变得不那么简单了。\n\n##### 二分答案\n这里用到二分答案策略，所谓的二分答案，就是假设所求的值刚开始在一个区间段[l,r]，然后选取这个区间段的中间值mid作为答案，如果算出这个中间值取大了，就从左半区间[l,mid],否则从[mid,r]找最后直到区间缩到无穷小，则此时区间的逼近值即为正确答案。这个其实在数值分析里面学过。\n\n##### 变向思维\n我们要求连续区间的最大平均值，很困难，因为这个平均值不仅和连续区间和sum有关，还与区间长度length有关，这就需要我们将问题进行转换。\n\n假设最大平均值为ans，则对于平均值最大的那段区间[i,j]有(a<sub>i</sub>+a<sub>i+1</sub>+...+a<sub>j</sub>)/length=ans。即(a<sub>i</sub>+a<sub>i+1</sub>+...+a<sub>j</sub>)-ans*length=0。\n\n- 如果有大于ans的区间段平均值，则对于最大的区间段[p,q],有(a<sub>p</sub>+a<sub>p+1</sub>+...+a<sub>q</sub>)/length>ans，即(a<sub>p</sub>+a<sub>p+1</sub>+...+a<sub>q</sub>)-ans*length>0。那么我们的ans就偏小了。这就是一个二分的判断偏小依据。\n\n- 如果全部的区间段平均值都小于ans，则对于最大的区间段，有(a<sub>p</sub>+a<sub>p+1</sub>+...+a<sub>q</sub>)/length<ans,即(a<sub>p</sub>+a<sub>p+1</sub>+...+a<sub>q</sub>)-ans*length<0,则此时ans偏大了。得到一个二分偏大的判断。\n\n那么问题就从求连续子序列最大平均值，转换成了求(a<sub>i</sub>+a<sub>i+1</sub>+...+a<sub>j</sub>)-ans * length的值。我们将整个区间段[0,n-1]的值全部减去ans，那么我们在求连续子序列的和时，就相当于求a<sub>i</sub>+a<sub>i+1</sub>+...+a<sub>j</sub>-ans * lengths的值。则问题最终变成了一个连续子序列求和问题。\n\n##### 长度不小于f的最大连续子序列问题\n我们可以先求出[0,n]的前缀和sum[i] i=0,1,2...n。由于子序列的长度不能小于f，则以i结尾的连续子序列dp[i] (i>=f)，前f个数一定是要的。先让dp[i]=sum[i],则sum[i]-sum[i-k-1]这段肯定要留在dp[i]里面。所以只需要找到sum[0] ~ sum[i-k]中小于0的最小值sum[m]，然后令dp=sum[i]-sum[m]即为以i结尾的连续子序列的最大值（就是把前面连续的最自己没有正作用的子序列干掉）。则我们要维护从sum[0]~sum[i-k]的最小值，并且每次用dp[i]更新整个区间内连续子序列的最大值即可。\n```c++\nfor(int i=f;i<n;++i){\n           Min=min(Min,sum[i-f]);   \n           Max=max(Max,sum[i]-Min);   // sum[i]-Min是以i结尾的最大连续子段和，Max是之前求出的最大连续子段和\n       }\n```\n\n## 算法\n先假定二分区间为很大，然后二分假设答案mid，令原数组所有的数减去mid得到新数组。求新数组中长度不小于k的连续子序列的最大和，如果结果大于0，说明ans设小了，区间往右边分，否则区间往左边分。直到最后区间逼近一个数为止。\n## 代码\n\n```c++\n#include<iostream>\n#include<cmath>\nusing namespace std;\ndouble a[100002];\ndouble b[100002];\ndouble sum[100002]; // 记录第i个数之前的和\nint n;\nint f;\nint main(){\n    //freopen(\"test/div1A.txt\",\"r\",stdin);\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    double mid;       // 假设的答案 \n    cin>>n>>f;\n    for(int i=0;i<n;++i){\n        //scanf(\"%lf\",&a[i]);  // 用cin会套老鹅\n        cin>>a[i];\n    }\n    double l=-1e6;    // 答案区间的左边\n    double r=1e6;     // 答案区间的右边\n    while(r-l>1e-4){\n       mid = (l+r)/2;\n       // 先求出减去平均值后的数组\n       for(int i=0;i<n;++i){\n           b[i]=a[i]-mid;   \n       }\n       \n       sum[0]=b[0];\n       for(int i = 1;i<n;++i){\n            sum[i]=sum[i-1]+b[i];\n       }\n       double Min=0;     // 记录以j(0<=j<i-f)结尾大子段和的最小值，初始值应该为0，因为比0小的我们才不要\n                         // 如果这里初始化为一个很大的值，那么若sum[0]大于0，就会被认为是要被抛弃的，然而我们只需要抛弃小于0的\n       double Max=-1e9;      // 记录长度大于f的最大子段和\n       // 求限定长度为f的最大连续子段和\n       for(int i=f;i<n;++i){\n           Min=min(Min,sum[i-f]);   \n           Max=max(Max,sum[i]-Min);   // sum[i]-Min是以i结尾的最大连续子段和，Max是之前求出的最大连续子段和\n       }\n       Max=max(Max,sum[f-1]);   // 观察可知上面没有判断sum[f-1]的情况\n       if(Max>0){  // Max>0说明答案不够大\n         l=mid;\n       }else{      // 否则就是答案不够小\n         r=mid;\n       }\n\n    }\n    cout<<(int)(1000*r)<<endl;\n}\n```\n\n\n\n","source":"_posts/BestCowFences.md","raw":"---\ntitle: BestCowFences\ndate: 2021-06-13 00:35:27\ncategories:\n    - div1\ntags:\n    - 限定长度最大子段和\n    - 思维\n    - 二分答案\n---\n# 题目\n{% asset_img BestCowFence.png %}\n### 题目简介\n题目大概就是围起连续不小于f的数，使他们的平均值最大，求出这个最大值。\n### 分析\n 如果是求连续子序列最大和，那么问题就很简单。但是他这里要求的是最大平均数，由于最大平均数不仅和连续子序列的和有关，还和连续子序列的长度有关。即average=sum/length。则事情就变得不那么简单了。\n\n##### 二分答案\n这里用到二分答案策略，所谓的二分答案，就是假设所求的值刚开始在一个区间段[l,r]，然后选取这个区间段的中间值mid作为答案，如果算出这个中间值取大了，就从左半区间[l,mid],否则从[mid,r]找最后直到区间缩到无穷小，则此时区间的逼近值即为正确答案。这个其实在数值分析里面学过。\n\n##### 变向思维\n我们要求连续区间的最大平均值，很困难，因为这个平均值不仅和连续区间和sum有关，还与区间长度length有关，这就需要我们将问题进行转换。\n\n假设最大平均值为ans，则对于平均值最大的那段区间[i,j]有(a<sub>i</sub>+a<sub>i+1</sub>+...+a<sub>j</sub>)/length=ans。即(a<sub>i</sub>+a<sub>i+1</sub>+...+a<sub>j</sub>)-ans*length=0。\n\n- 如果有大于ans的区间段平均值，则对于最大的区间段[p,q],有(a<sub>p</sub>+a<sub>p+1</sub>+...+a<sub>q</sub>)/length>ans，即(a<sub>p</sub>+a<sub>p+1</sub>+...+a<sub>q</sub>)-ans*length>0。那么我们的ans就偏小了。这就是一个二分的判断偏小依据。\n\n- 如果全部的区间段平均值都小于ans，则对于最大的区间段，有(a<sub>p</sub>+a<sub>p+1</sub>+...+a<sub>q</sub>)/length<ans,即(a<sub>p</sub>+a<sub>p+1</sub>+...+a<sub>q</sub>)-ans*length<0,则此时ans偏大了。得到一个二分偏大的判断。\n\n那么问题就从求连续子序列最大平均值，转换成了求(a<sub>i</sub>+a<sub>i+1</sub>+...+a<sub>j</sub>)-ans * length的值。我们将整个区间段[0,n-1]的值全部减去ans，那么我们在求连续子序列的和时，就相当于求a<sub>i</sub>+a<sub>i+1</sub>+...+a<sub>j</sub>-ans * lengths的值。则问题最终变成了一个连续子序列求和问题。\n\n##### 长度不小于f的最大连续子序列问题\n我们可以先求出[0,n]的前缀和sum[i] i=0,1,2...n。由于子序列的长度不能小于f，则以i结尾的连续子序列dp[i] (i>=f)，前f个数一定是要的。先让dp[i]=sum[i],则sum[i]-sum[i-k-1]这段肯定要留在dp[i]里面。所以只需要找到sum[0] ~ sum[i-k]中小于0的最小值sum[m]，然后令dp=sum[i]-sum[m]即为以i结尾的连续子序列的最大值（就是把前面连续的最自己没有正作用的子序列干掉）。则我们要维护从sum[0]~sum[i-k]的最小值，并且每次用dp[i]更新整个区间内连续子序列的最大值即可。\n```c++\nfor(int i=f;i<n;++i){\n           Min=min(Min,sum[i-f]);   \n           Max=max(Max,sum[i]-Min);   // sum[i]-Min是以i结尾的最大连续子段和，Max是之前求出的最大连续子段和\n       }\n```\n\n## 算法\n先假定二分区间为很大，然后二分假设答案mid，令原数组所有的数减去mid得到新数组。求新数组中长度不小于k的连续子序列的最大和，如果结果大于0，说明ans设小了，区间往右边分，否则区间往左边分。直到最后区间逼近一个数为止。\n## 代码\n\n```c++\n#include<iostream>\n#include<cmath>\nusing namespace std;\ndouble a[100002];\ndouble b[100002];\ndouble sum[100002]; // 记录第i个数之前的和\nint n;\nint f;\nint main(){\n    //freopen(\"test/div1A.txt\",\"r\",stdin);\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    double mid;       // 假设的答案 \n    cin>>n>>f;\n    for(int i=0;i<n;++i){\n        //scanf(\"%lf\",&a[i]);  // 用cin会套老鹅\n        cin>>a[i];\n    }\n    double l=-1e6;    // 答案区间的左边\n    double r=1e6;     // 答案区间的右边\n    while(r-l>1e-4){\n       mid = (l+r)/2;\n       // 先求出减去平均值后的数组\n       for(int i=0;i<n;++i){\n           b[i]=a[i]-mid;   \n       }\n       \n       sum[0]=b[0];\n       for(int i = 1;i<n;++i){\n            sum[i]=sum[i-1]+b[i];\n       }\n       double Min=0;     // 记录以j(0<=j<i-f)结尾大子段和的最小值，初始值应该为0，因为比0小的我们才不要\n                         // 如果这里初始化为一个很大的值，那么若sum[0]大于0，就会被认为是要被抛弃的，然而我们只需要抛弃小于0的\n       double Max=-1e9;      // 记录长度大于f的最大子段和\n       // 求限定长度为f的最大连续子段和\n       for(int i=f;i<n;++i){\n           Min=min(Min,sum[i-f]);   \n           Max=max(Max,sum[i]-Min);   // sum[i]-Min是以i结尾的最大连续子段和，Max是之前求出的最大连续子段和\n       }\n       Max=max(Max,sum[f-1]);   // 观察可知上面没有判断sum[f-1]的情况\n       if(Max>0){  // Max>0说明答案不够大\n         l=mid;\n       }else{      // 否则就是答案不够小\n         r=mid;\n       }\n\n    }\n    cout<<(int)(1000*r)<<endl;\n}\n```\n\n\n\n","slug":"BestCowFences","published":1,"updated":"2021-06-13T04:06:14.728Z","_id":"ckpun1mbr0000xktk8n1z1mld","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><img src=\"/2021/06/13/BestCowFences/BestCowFence.png\" class=\"\">\n<h3 id=\"题目简介\"><a href=\"#题目简介\" class=\"headerlink\" title=\"题目简介\"></a>题目简介</h3><p>题目大概就是围起连续不小于f的数，使他们的平均值最大，求出这个最大值。</p>\n<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p> 如果是求连续子序列最大和，那么问题就很简单。但是他这里要求的是最大平均数，由于最大平均数不仅和连续子序列的和有关，还和连续子序列的长度有关。即average=sum/length。则事情就变得不那么简单了。</p>\n<h5 id=\"二分答案\"><a href=\"#二分答案\" class=\"headerlink\" title=\"二分答案\"></a>二分答案</h5><p>这里用到二分答案策略，所谓的二分答案，就是假设所求的值刚开始在一个区间段[l,r]，然后选取这个区间段的中间值mid作为答案，如果算出这个中间值取大了，就从左半区间[l,mid],否则从[mid,r]找最后直到区间缩到无穷小，则此时区间的逼近值即为正确答案。这个其实在数值分析里面学过。</p>\n<h5 id=\"变向思维\"><a href=\"#变向思维\" class=\"headerlink\" title=\"变向思维\"></a>变向思维</h5><p>我们要求连续区间的最大平均值，很困难，因为这个平均值不仅和连续区间和sum有关，还与区间长度length有关，这就需要我们将问题进行转换。</p>\n<p>假设最大平均值为ans，则对于平均值最大的那段区间[i,j]有(a<sub>i</sub>+a<sub>i+1</sub>+…+a<sub>j</sub>)/length=ans。即(a<sub>i</sub>+a<sub>i+1</sub>+…+a<sub>j</sub>)-ans*length=0。</p>\n<ul>\n<li><p>如果有大于ans的区间段平均值，则对于最大的区间段[p,q],有(a<sub>p</sub>+a<sub>p+1</sub>+…+a<sub>q</sub>)/length&gt;ans，即(a<sub>p</sub>+a<sub>p+1</sub>+…+a<sub>q</sub>)-ans*length&gt;0。那么我们的ans就偏小了。这就是一个二分的判断偏小依据。</p>\n</li>\n<li><p>如果全部的区间段平均值都小于ans，则对于最大的区间段，有(a<sub>p</sub>+a<sub>p+1</sub>+…+a<sub>q</sub>)/length&lt;ans,即(a<sub>p</sub>+a<sub>p+1</sub>+…+a<sub>q</sub>)-ans*length&lt;0,则此时ans偏大了。得到一个二分偏大的判断。</p>\n</li>\n</ul>\n<p>那么问题就从求连续子序列最大平均值，转换成了求(a<sub>i</sub>+a<sub>i+1</sub>+…+a<sub>j</sub>)-ans * length的值。我们将整个区间段[0,n-1]的值全部减去ans，那么我们在求连续子序列的和时，就相当于求a<sub>i</sub>+a<sub>i+1</sub>+…+a<sub>j</sub>-ans * lengths的值。则问题最终变成了一个连续子序列求和问题。</p>\n<h5 id=\"长度不小于f的最大连续子序列问题\"><a href=\"#长度不小于f的最大连续子序列问题\" class=\"headerlink\" title=\"长度不小于f的最大连续子序列问题\"></a>长度不小于f的最大连续子序列问题</h5><p>我们可以先求出[0,n]的前缀和sum[i] i=0,1,2…n。由于子序列的长度不能小于f，则以i结尾的连续子序列dp[i] (i&gt;=f)，前f个数一定是要的。先让dp[i]=sum[i],则sum[i]-sum[i-k-1]这段肯定要留在dp[i]里面。所以只需要找到sum[0] ~ sum[i-k]中小于0的最小值sum[m]，然后令dp=sum[i]-sum[m]即为以i结尾的连续子序列的最大值（就是把前面连续的最自己没有正作用的子序列干掉）。则我们要维护从sum[0]~sum[i-k]的最小值，并且每次用dp[i]更新整个区间内连续子序列的最大值即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=f;i&lt;n;++i)&#123;</span><br><span class=\"line\">           Min=<span class=\"built_in\">min</span>(Min,sum[i-f]);   </span><br><span class=\"line\">           Max=<span class=\"built_in\">max</span>(Max,sum[i]-Min);   <span class=\"comment\">// sum[i]-Min是以i结尾的最大连续子段和，Max是之前求出的最大连续子段和</span></span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h2><p>先假定二分区间为很大，然后二分假设答案mid，令原数组所有的数减去mid得到新数组。求新数组中长度不小于k的连续子序列的最大和，如果结果大于0，说明ans设小了，区间往右边分，否则区间往左边分。直到最后区间逼近一个数为止。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">double</span> a[<span class=\"number\">100002</span>];</span><br><span class=\"line\"><span class=\"keyword\">double</span> b[<span class=\"number\">100002</span>];</span><br><span class=\"line\"><span class=\"keyword\">double</span> sum[<span class=\"number\">100002</span>]; <span class=\"comment\">// 记录第i个数之前的和</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"><span class=\"keyword\">int</span> f;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//freopen(&quot;test/div1A.txt&quot;,&quot;r&quot;,stdin);</span></span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">double</span> mid;       <span class=\"comment\">// 假设的答案 </span></span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;f;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//scanf(&quot;%lf&quot;,&amp;a[i]);  // 用cin会套老鹅</span></span><br><span class=\"line\">        cin&gt;&gt;a[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> l=<span class=\"number\">-1e6</span>;    <span class=\"comment\">// 答案区间的左边</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> r=<span class=\"number\">1e6</span>;     <span class=\"comment\">// 答案区间的右边</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(r-l&gt;<span class=\"number\">1e-4</span>)&#123;</span><br><span class=\"line\">       mid = (l+r)/<span class=\"number\">2</span>;</span><br><span class=\"line\">       <span class=\"comment\">// 先求出减去平均值后的数组</span></span><br><span class=\"line\">       <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">           b[i]=a[i]-mid;   </span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       </span><br><span class=\"line\">       sum[<span class=\"number\">0</span>]=b[<span class=\"number\">0</span>];</span><br><span class=\"line\">       <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">            sum[i]=sum[i<span class=\"number\">-1</span>]+b[i];</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">double</span> Min=<span class=\"number\">0</span>;     <span class=\"comment\">// 记录以j(0&lt;=j&lt;i-f)结尾大子段和的最小值，初始值应该为0，因为比0小的我们才不要</span></span><br><span class=\"line\">                         <span class=\"comment\">// 如果这里初始化为一个很大的值，那么若sum[0]大于0，就会被认为是要被抛弃的，然而我们只需要抛弃小于0的</span></span><br><span class=\"line\">       <span class=\"keyword\">double</span> Max=<span class=\"number\">-1e9</span>;      <span class=\"comment\">// 记录长度大于f的最大子段和</span></span><br><span class=\"line\">       <span class=\"comment\">// 求限定长度为f的最大连续子段和</span></span><br><span class=\"line\">       <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=f;i&lt;n;++i)&#123;</span><br><span class=\"line\">           Min=<span class=\"built_in\">min</span>(Min,sum[i-f]);   </span><br><span class=\"line\">           Max=<span class=\"built_in\">max</span>(Max,sum[i]-Min);   <span class=\"comment\">// sum[i]-Min是以i结尾的最大连续子段和，Max是之前求出的最大连续子段和</span></span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       Max=<span class=\"built_in\">max</span>(Max,sum[f<span class=\"number\">-1</span>]);   <span class=\"comment\">// 观察可知上面没有判断sum[f-1]的情况</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span>(Max&gt;<span class=\"number\">0</span>)&#123;  <span class=\"comment\">// Max&gt;0说明答案不够大</span></span><br><span class=\"line\">         l=mid;</span><br><span class=\"line\">       &#125;<span class=\"keyword\">else</span>&#123;      <span class=\"comment\">// 否则就是答案不够小</span></span><br><span class=\"line\">         r=mid;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;(<span class=\"keyword\">int</span>)(<span class=\"number\">1000</span>*r)&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><img src=\"/2021/06/13/BestCowFences/BestCowFence.png\" class=\"\">\n<h3 id=\"题目简介\"><a href=\"#题目简介\" class=\"headerlink\" title=\"题目简介\"></a>题目简介</h3><p>题目大概就是围起连续不小于f的数，使他们的平均值最大，求出这个最大值。</p>\n<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p> 如果是求连续子序列最大和，那么问题就很简单。但是他这里要求的是最大平均数，由于最大平均数不仅和连续子序列的和有关，还和连续子序列的长度有关。即average=sum/length。则事情就变得不那么简单了。</p>\n<h5 id=\"二分答案\"><a href=\"#二分答案\" class=\"headerlink\" title=\"二分答案\"></a>二分答案</h5><p>这里用到二分答案策略，所谓的二分答案，就是假设所求的值刚开始在一个区间段[l,r]，然后选取这个区间段的中间值mid作为答案，如果算出这个中间值取大了，就从左半区间[l,mid],否则从[mid,r]找最后直到区间缩到无穷小，则此时区间的逼近值即为正确答案。这个其实在数值分析里面学过。</p>\n<h5 id=\"变向思维\"><a href=\"#变向思维\" class=\"headerlink\" title=\"变向思维\"></a>变向思维</h5><p>我们要求连续区间的最大平均值，很困难，因为这个平均值不仅和连续区间和sum有关，还与区间长度length有关，这就需要我们将问题进行转换。</p>\n<p>假设最大平均值为ans，则对于平均值最大的那段区间[i,j]有(a<sub>i</sub>+a<sub>i+1</sub>+…+a<sub>j</sub>)/length=ans。即(a<sub>i</sub>+a<sub>i+1</sub>+…+a<sub>j</sub>)-ans*length=0。</p>\n<ul>\n<li><p>如果有大于ans的区间段平均值，则对于最大的区间段[p,q],有(a<sub>p</sub>+a<sub>p+1</sub>+…+a<sub>q</sub>)/length&gt;ans，即(a<sub>p</sub>+a<sub>p+1</sub>+…+a<sub>q</sub>)-ans*length&gt;0。那么我们的ans就偏小了。这就是一个二分的判断偏小依据。</p>\n</li>\n<li><p>如果全部的区间段平均值都小于ans，则对于最大的区间段，有(a<sub>p</sub>+a<sub>p+1</sub>+…+a<sub>q</sub>)/length&lt;ans,即(a<sub>p</sub>+a<sub>p+1</sub>+…+a<sub>q</sub>)-ans*length&lt;0,则此时ans偏大了。得到一个二分偏大的判断。</p>\n</li>\n</ul>\n<p>那么问题就从求连续子序列最大平均值，转换成了求(a<sub>i</sub>+a<sub>i+1</sub>+…+a<sub>j</sub>)-ans * length的值。我们将整个区间段[0,n-1]的值全部减去ans，那么我们在求连续子序列的和时，就相当于求a<sub>i</sub>+a<sub>i+1</sub>+…+a<sub>j</sub>-ans * lengths的值。则问题最终变成了一个连续子序列求和问题。</p>\n<h5 id=\"长度不小于f的最大连续子序列问题\"><a href=\"#长度不小于f的最大连续子序列问题\" class=\"headerlink\" title=\"长度不小于f的最大连续子序列问题\"></a>长度不小于f的最大连续子序列问题</h5><p>我们可以先求出[0,n]的前缀和sum[i] i=0,1,2…n。由于子序列的长度不能小于f，则以i结尾的连续子序列dp[i] (i&gt;=f)，前f个数一定是要的。先让dp[i]=sum[i],则sum[i]-sum[i-k-1]这段肯定要留在dp[i]里面。所以只需要找到sum[0] ~ sum[i-k]中小于0的最小值sum[m]，然后令dp=sum[i]-sum[m]即为以i结尾的连续子序列的最大值（就是把前面连续的最自己没有正作用的子序列干掉）。则我们要维护从sum[0]~sum[i-k]的最小值，并且每次用dp[i]更新整个区间内连续子序列的最大值即可。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=f;i&lt;n;++i)&#123;</span><br><span class=\"line\">           Min=<span class=\"built_in\">min</span>(Min,sum[i-f]);   </span><br><span class=\"line\">           Max=<span class=\"built_in\">max</span>(Max,sum[i]-Min);   <span class=\"comment\">// sum[i]-Min是以i结尾的最大连续子段和，Max是之前求出的最大连续子段和</span></span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h2><p>先假定二分区间为很大，然后二分假设答案mid，令原数组所有的数减去mid得到新数组。求新数组中长度不小于k的连续子序列的最大和，如果结果大于0，说明ans设小了，区间往右边分，否则区间往左边分。直到最后区间逼近一个数为止。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">double</span> a[<span class=\"number\">100002</span>];</span><br><span class=\"line\"><span class=\"keyword\">double</span> b[<span class=\"number\">100002</span>];</span><br><span class=\"line\"><span class=\"keyword\">double</span> sum[<span class=\"number\">100002</span>]; <span class=\"comment\">// 记录第i个数之前的和</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"><span class=\"keyword\">int</span> f;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//freopen(&quot;test/div1A.txt&quot;,&quot;r&quot;,stdin);</span></span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">double</span> mid;       <span class=\"comment\">// 假设的答案 </span></span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;f;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//scanf(&quot;%lf&quot;,&amp;a[i]);  // 用cin会套老鹅</span></span><br><span class=\"line\">        cin&gt;&gt;a[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> l=<span class=\"number\">-1e6</span>;    <span class=\"comment\">// 答案区间的左边</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> r=<span class=\"number\">1e6</span>;     <span class=\"comment\">// 答案区间的右边</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(r-l&gt;<span class=\"number\">1e-4</span>)&#123;</span><br><span class=\"line\">       mid = (l+r)/<span class=\"number\">2</span>;</span><br><span class=\"line\">       <span class=\"comment\">// 先求出减去平均值后的数组</span></span><br><span class=\"line\">       <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">           b[i]=a[i]-mid;   </span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       </span><br><span class=\"line\">       sum[<span class=\"number\">0</span>]=b[<span class=\"number\">0</span>];</span><br><span class=\"line\">       <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">            sum[i]=sum[i<span class=\"number\">-1</span>]+b[i];</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">double</span> Min=<span class=\"number\">0</span>;     <span class=\"comment\">// 记录以j(0&lt;=j&lt;i-f)结尾大子段和的最小值，初始值应该为0，因为比0小的我们才不要</span></span><br><span class=\"line\">                         <span class=\"comment\">// 如果这里初始化为一个很大的值，那么若sum[0]大于0，就会被认为是要被抛弃的，然而我们只需要抛弃小于0的</span></span><br><span class=\"line\">       <span class=\"keyword\">double</span> Max=<span class=\"number\">-1e9</span>;      <span class=\"comment\">// 记录长度大于f的最大子段和</span></span><br><span class=\"line\">       <span class=\"comment\">// 求限定长度为f的最大连续子段和</span></span><br><span class=\"line\">       <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=f;i&lt;n;++i)&#123;</span><br><span class=\"line\">           Min=<span class=\"built_in\">min</span>(Min,sum[i-f]);   </span><br><span class=\"line\">           Max=<span class=\"built_in\">max</span>(Max,sum[i]-Min);   <span class=\"comment\">// sum[i]-Min是以i结尾的最大连续子段和，Max是之前求出的最大连续子段和</span></span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       Max=<span class=\"built_in\">max</span>(Max,sum[f<span class=\"number\">-1</span>]);   <span class=\"comment\">// 观察可知上面没有判断sum[f-1]的情况</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span>(Max&gt;<span class=\"number\">0</span>)&#123;  <span class=\"comment\">// Max&gt;0说明答案不够大</span></span><br><span class=\"line\">         l=mid;</span><br><span class=\"line\">       &#125;<span class=\"keyword\">else</span>&#123;      <span class=\"comment\">// 否则就是答案不够小</span></span><br><span class=\"line\">         r=mid;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;(<span class=\"keyword\">int</span>)(<span class=\"number\">1000</span>*r)&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n"},{"title":"MaxMedian","date":"2021-06-13T03:57:10.000Z","_content":"# 题目\n{% asset_img MaxMedian.png %}\n\n### 题目简述\n这题是长度不小于k连续子序列排队后的最大中位数。其中排序后+中位数定义下标为$\\lfloor(r-l+1)/2\\rfloor$.\n\n###分析\n这是一道求长度不小于k的连续子序列问题，但它又不是简单求连续子序列的问题。而是求中位数，而且是子序列排序后的中位数，并且要中位数最大。这种场景很难不让人想到二分答案+问题转化。\n通过观察不难发现\n- 如果连续子序列长度是偶数，如[1,2,3,4,5,6],那么大于等于中位数的数会比小于中位数的数多两个。\n- 如果连续子序列的长度是奇数，如[1,2,3,4,5]那么大于等于中位数的数会比小于中位数的数一两个。\n除上面所述两中情况之外不会有其他情况。\n\n## 算法\n根据分析可以巧妙设计算法，假设答案ans，如果序列中的值大于等于ans，令其等于1，否等于-1。如果变换后的序列中长度不小于k的最大连续子序列的值小于0，就说明中位数ans设大了，则答案往小取，否则答案往大取，直到二分区间无穷小。\n\n```c++\n#include<iostream>\nusing namespace std;\nint a[200002];\nint sum[200002];\nint main(){\n    int n,k;\n    //freopen(\"test/div1C.txt\",\"r\",stdin);\n    // 关同步流\n     ios::sync_with_stdio(false);\n     cin.tie(0);\n    cin>>n>>k;\n    for(int i = 0;i<n;++i){\n        cin>>a[i];\n    }\n    double l=-1e9;   // 答案左区间\n    double r=1e9;    // 答案右区间\n    while(r-l>1e-5){\n        //cout<<l<<\" \"<<r<<endl;\n        double mid=(l+r)/2;\n        //求变形之后地前缀和\n        if(a[0]>=mid){\n            sum[0]=1;\n        }else{\n            sum[0]=-1;\n        }\n        for(int j = 1;j<n;++j){\n           if(a[j]>=mid){\n               sum[j]=sum[j-1]+1;\n           }else{\n               sum[j]=sum[j-1]-1;\n           }\n        }\n\n       // 求最大子段和\n       int Min=0;\n       int Max=-1e9;\n       for(int i = k;i<n;++i){\n           Min=min(Min,sum[i-k]);\n           Max=max(Max,sum[i]-Min);\n       }\n\n       Max=max(Max,sum[k-1]);\n       if(Max>0){\n           l=mid;\n       }else{\n           r=mid;\n       }\n       \n    }\n    cout<<(int)r<<endl;\n}\n```\n\n\n\n\n","source":"_posts/MaxMedian.md","raw":"---\ntitle: MaxMedian\ndate: 2021-06-13 11:57:10\ncategories:\n    - div1\ntags:\n    - 限定长度最大子段和\n    - 思维\n    - 二分答案\n---\n# 题目\n{% asset_img MaxMedian.png %}\n\n### 题目简述\n这题是长度不小于k连续子序列排队后的最大中位数。其中排序后+中位数定义下标为$\\lfloor(r-l+1)/2\\rfloor$.\n\n###分析\n这是一道求长度不小于k的连续子序列问题，但它又不是简单求连续子序列的问题。而是求中位数，而且是子序列排序后的中位数，并且要中位数最大。这种场景很难不让人想到二分答案+问题转化。\n通过观察不难发现\n- 如果连续子序列长度是偶数，如[1,2,3,4,5,6],那么大于等于中位数的数会比小于中位数的数多两个。\n- 如果连续子序列的长度是奇数，如[1,2,3,4,5]那么大于等于中位数的数会比小于中位数的数一两个。\n除上面所述两中情况之外不会有其他情况。\n\n## 算法\n根据分析可以巧妙设计算法，假设答案ans，如果序列中的值大于等于ans，令其等于1，否等于-1。如果变换后的序列中长度不小于k的最大连续子序列的值小于0，就说明中位数ans设大了，则答案往小取，否则答案往大取，直到二分区间无穷小。\n\n```c++\n#include<iostream>\nusing namespace std;\nint a[200002];\nint sum[200002];\nint main(){\n    int n,k;\n    //freopen(\"test/div1C.txt\",\"r\",stdin);\n    // 关同步流\n     ios::sync_with_stdio(false);\n     cin.tie(0);\n    cin>>n>>k;\n    for(int i = 0;i<n;++i){\n        cin>>a[i];\n    }\n    double l=-1e9;   // 答案左区间\n    double r=1e9;    // 答案右区间\n    while(r-l>1e-5){\n        //cout<<l<<\" \"<<r<<endl;\n        double mid=(l+r)/2;\n        //求变形之后地前缀和\n        if(a[0]>=mid){\n            sum[0]=1;\n        }else{\n            sum[0]=-1;\n        }\n        for(int j = 1;j<n;++j){\n           if(a[j]>=mid){\n               sum[j]=sum[j-1]+1;\n           }else{\n               sum[j]=sum[j-1]-1;\n           }\n        }\n\n       // 求最大子段和\n       int Min=0;\n       int Max=-1e9;\n       for(int i = k;i<n;++i){\n           Min=min(Min,sum[i-k]);\n           Max=max(Max,sum[i]-Min);\n       }\n\n       Max=max(Max,sum[k-1]);\n       if(Max>0){\n           l=mid;\n       }else{\n           r=mid;\n       }\n       \n    }\n    cout<<(int)r<<endl;\n}\n```\n\n\n\n\n","slug":"MaxMedian","published":1,"updated":"2021-06-13T04:40:40.088Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckpupip0m0000uctk8c7s0zz9","content":"<h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><img src=\"/2021/06/13/MaxMedian/MaxMedian.png\" class=\"\">\n\n<h3 id=\"题目简述\"><a href=\"#题目简述\" class=\"headerlink\" title=\"题目简述\"></a>题目简述</h3><p>这题是长度不小于k连续子序列排队后的最大中位数。其中排序后+中位数定义下标为$\\lfloor(r-l+1)/2\\rfloor$.</p>\n<p>###分析<br>这是一道求长度不小于k的连续子序列问题，但它又不是简单求连续子序列的问题。而是求中位数，而且是子序列排序后的中位数，并且要中位数最大。这种场景很难不让人想到二分答案+问题转化。<br>通过观察不难发现</p>\n<ul>\n<li>如果连续子序列长度是偶数，如[1,2,3,4,5,6],那么大于等于中位数的数会比小于中位数的数多两个。</li>\n<li>如果连续子序列的长度是奇数，如[1,2,3,4,5]那么大于等于中位数的数会比小于中位数的数一两个。<br>除上面所述两中情况之外不会有其他情况。</li>\n</ul>\n<h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h2><p>根据分析可以巧妙设计算法，假设答案ans，如果序列中的值大于等于ans，令其等于1，否等于-1。如果变换后的序列中长度不小于k的最大连续子序列的值小于0，就说明中位数ans设大了，则答案往小取，否则答案往大取，直到二分区间无穷小。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">int</span> a[<span class=\"number\">200002</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> sum[<span class=\"number\">200002</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n,k;</span><br><span class=\"line\">    <span class=\"comment\">//freopen(&quot;test/div1C.txt&quot;,&quot;r&quot;,stdin);</span></span><br><span class=\"line\">    <span class=\"comment\">// 关同步流</span></span><br><span class=\"line\">     ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">     cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">        cin&gt;&gt;a[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> l=<span class=\"number\">-1e9</span>;   <span class=\"comment\">// 答案左区间</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> r=<span class=\"number\">1e9</span>;    <span class=\"comment\">// 答案右区间</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(r-l&gt;<span class=\"number\">1e-5</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//cout&lt;&lt;l&lt;&lt;&quot; &quot;&lt;&lt;r&lt;&lt;endl;</span></span><br><span class=\"line\">        <span class=\"keyword\">double</span> mid=(l+r)/<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"comment\">//求变形之后地前缀和</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a[<span class=\"number\">0</span>]&gt;=mid)&#123;</span><br><span class=\"line\">            sum[<span class=\"number\">0</span>]=<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            sum[<span class=\"number\">0</span>]=<span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;j&lt;n;++j)&#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span>(a[j]&gt;=mid)&#123;</span><br><span class=\"line\">               sum[j]=sum[j<span class=\"number\">-1</span>]+<span class=\"number\">1</span>;</span><br><span class=\"line\">           &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">               sum[j]=sum[j<span class=\"number\">-1</span>]<span class=\"number\">-1</span>;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">// 求最大子段和</span></span><br><span class=\"line\">       <span class=\"keyword\">int</span> Min=<span class=\"number\">0</span>;</span><br><span class=\"line\">       <span class=\"keyword\">int</span> Max=<span class=\"number\">-1e9</span>;</span><br><span class=\"line\">       <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = k;i&lt;n;++i)&#123;</span><br><span class=\"line\">           Min=<span class=\"built_in\">min</span>(Min,sum[i-k]);</span><br><span class=\"line\">           Max=<span class=\"built_in\">max</span>(Max,sum[i]-Min);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       Max=<span class=\"built_in\">max</span>(Max,sum[k<span class=\"number\">-1</span>]);</span><br><span class=\"line\">       <span class=\"keyword\">if</span>(Max&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">           l=mid;</span><br><span class=\"line\">       &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">           r=mid;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;(<span class=\"keyword\">int</span>)r&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><img src=\"/2021/06/13/MaxMedian/MaxMedian.png\" class=\"\">\n\n<h3 id=\"题目简述\"><a href=\"#题目简述\" class=\"headerlink\" title=\"题目简述\"></a>题目简述</h3><p>这题是长度不小于k连续子序列排队后的最大中位数。其中排序后+中位数定义下标为$\\lfloor(r-l+1)/2\\rfloor$.</p>\n<p>###分析<br>这是一道求长度不小于k的连续子序列问题，但它又不是简单求连续子序列的问题。而是求中位数，而且是子序列排序后的中位数，并且要中位数最大。这种场景很难不让人想到二分答案+问题转化。<br>通过观察不难发现</p>\n<ul>\n<li>如果连续子序列长度是偶数，如[1,2,3,4,5,6],那么大于等于中位数的数会比小于中位数的数多两个。</li>\n<li>如果连续子序列的长度是奇数，如[1,2,3,4,5]那么大于等于中位数的数会比小于中位数的数一两个。<br>除上面所述两中情况之外不会有其他情况。</li>\n</ul>\n<h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h2><p>根据分析可以巧妙设计算法，假设答案ans，如果序列中的值大于等于ans，令其等于1，否等于-1。如果变换后的序列中长度不小于k的最大连续子序列的值小于0，就说明中位数ans设大了，则答案往小取，否则答案往大取，直到二分区间无穷小。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">int</span> a[<span class=\"number\">200002</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> sum[<span class=\"number\">200002</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n,k;</span><br><span class=\"line\">    <span class=\"comment\">//freopen(&quot;test/div1C.txt&quot;,&quot;r&quot;,stdin);</span></span><br><span class=\"line\">    <span class=\"comment\">// 关同步流</span></span><br><span class=\"line\">     ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">     cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">        cin&gt;&gt;a[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> l=<span class=\"number\">-1e9</span>;   <span class=\"comment\">// 答案左区间</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> r=<span class=\"number\">1e9</span>;    <span class=\"comment\">// 答案右区间</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(r-l&gt;<span class=\"number\">1e-5</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//cout&lt;&lt;l&lt;&lt;&quot; &quot;&lt;&lt;r&lt;&lt;endl;</span></span><br><span class=\"line\">        <span class=\"keyword\">double</span> mid=(l+r)/<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"comment\">//求变形之后地前缀和</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a[<span class=\"number\">0</span>]&gt;=mid)&#123;</span><br><span class=\"line\">            sum[<span class=\"number\">0</span>]=<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            sum[<span class=\"number\">0</span>]=<span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;j&lt;n;++j)&#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span>(a[j]&gt;=mid)&#123;</span><br><span class=\"line\">               sum[j]=sum[j<span class=\"number\">-1</span>]+<span class=\"number\">1</span>;</span><br><span class=\"line\">           &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">               sum[j]=sum[j<span class=\"number\">-1</span>]<span class=\"number\">-1</span>;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">// 求最大子段和</span></span><br><span class=\"line\">       <span class=\"keyword\">int</span> Min=<span class=\"number\">0</span>;</span><br><span class=\"line\">       <span class=\"keyword\">int</span> Max=<span class=\"number\">-1e9</span>;</span><br><span class=\"line\">       <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = k;i&lt;n;++i)&#123;</span><br><span class=\"line\">           Min=<span class=\"built_in\">min</span>(Min,sum[i-k]);</span><br><span class=\"line\">           Max=<span class=\"built_in\">max</span>(Max,sum[i]-Min);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       Max=<span class=\"built_in\">max</span>(Max,sum[k<span class=\"number\">-1</span>]);</span><br><span class=\"line\">       <span class=\"keyword\">if</span>(Max&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">           l=mid;</span><br><span class=\"line\">       &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">           r=mid;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;(<span class=\"keyword\">int</span>)r&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n"},{"_content":"# 上海理工校赛题解报告\n\n#### 小结\n数学题，不会\n\n---\n\n## B题 Bheith i ngra le\n当初挣扎了一下，然后不会求给定i行j列的格子有多少单调曲线，就放弃了。\n\n#### 分析\n* 题目的核心是是求给定i行j列的格子能够构造多少调单调曲线。可以用dp或者组合求解，不喜欢数学的我毅然投奔了dp。  \n* 不难发现，当给定了宽为i，高为j的格子矩阵的时候，我们分析右上角那块，如果这块不画，那么所有情况就会变成dp[i][j-1],如果这块画上，那么情况就会是dp[i-1][j]。则得到状态转移方程dp[i][j]=dp[i][j-1]+dp[i-1][j]。当然，边界条件还是值得考虑一下的。\n* 算出dp数组后，性高彩烈的用n<sup>3</sup>去套老鹅。其实我们确定了山顶左边位置l之后不用去确定右边的r，dp[n-l][h]就是右边包含山顶在内的全部可能。所以ans=ans+dp[l-1][h-1]*dp[n-l][h]即可。\n\n#### 代码\n```c++\n#include<iostream>\nusing namespace std;\n\nlong long dp[2003][2003];\nlong long mod=1e9+7;\nlong long ans;\nint main(){\n\tint n,m;\n\tcin >>n>>m;\n    // 初始化高度为1时\n\tdp[1][1]=2;\n\tfor(int i = 2;i<=n;++i){\n\t\tdp[i][1]=dp[i-1][1]+1;\n\t}\n\t// 初始化宽度为1的时候\n\tfor(int j = 2;j<=m;++j){\n\t\tdp[1][j]=dp[1][j-1]+1;\n\t} \n    // 求dp，i为宽，j为高\n\tfor(int i = 2;i<=n;++i){\n\t\tfor(int j = 2;j<=m;++j){\n           dp[i][j]=(dp[i][j-1]+dp[i-1][j])%mod;\n\t\t}\n\t}\n\t\n\t// 宽度为0时答案应该为1，因为下面用的乘法\n\tfor(int j=0;j<=m;++j){\n\t\tdp[0][j]=1;\n\t} \n\n   // 高度为0时，也应该是1，即取0\n   for(int i = 0;i<=n;++i){\n\t   dp[i][0]=1;\n   }\n\t\n\t// cout<<dp[1][1]<<endl<<dp[2][1]<<endl<<dp[1][2]<<endl<<dp[2][2]<<endl<<dp[1][3]<<endl<<dp[2][3]<<endl; \n\n\t// 枚举山顶的情况,l是左边，r是右边，h是山高\n\tfor(int l = 1;l<=n;++l){\n\t\t\tfor(int h = 1;h<=m;++h){\n               ans = (ans+(dp[l-1][h-1]*dp[n-l][h])%mod)%mod;   // 是左边的情况乘以右边的情况\n\t\t\t}\n\t}\n\t\n\t// 加上山顶全为0的情况，只有一种\n\t ans=(ans+1)%mod;\n\n\tcout<<ans<<endl;\n\n\n}\n```","source":"_posts/USST.md","raw":"# 上海理工校赛题解报告\n\n#### 小结\n数学题，不会\n\n---\n\n## B题 Bheith i ngra le\n当初挣扎了一下，然后不会求给定i行j列的格子有多少单调曲线，就放弃了。\n\n#### 分析\n* 题目的核心是是求给定i行j列的格子能够构造多少调单调曲线。可以用dp或者组合求解，不喜欢数学的我毅然投奔了dp。  \n* 不难发现，当给定了宽为i，高为j的格子矩阵的时候，我们分析右上角那块，如果这块不画，那么所有情况就会变成dp[i][j-1],如果这块画上，那么情况就会是dp[i-1][j]。则得到状态转移方程dp[i][j]=dp[i][j-1]+dp[i-1][j]。当然，边界条件还是值得考虑一下的。\n* 算出dp数组后，性高彩烈的用n<sup>3</sup>去套老鹅。其实我们确定了山顶左边位置l之后不用去确定右边的r，dp[n-l][h]就是右边包含山顶在内的全部可能。所以ans=ans+dp[l-1][h-1]*dp[n-l][h]即可。\n\n#### 代码\n```c++\n#include<iostream>\nusing namespace std;\n\nlong long dp[2003][2003];\nlong long mod=1e9+7;\nlong long ans;\nint main(){\n\tint n,m;\n\tcin >>n>>m;\n    // 初始化高度为1时\n\tdp[1][1]=2;\n\tfor(int i = 2;i<=n;++i){\n\t\tdp[i][1]=dp[i-1][1]+1;\n\t}\n\t// 初始化宽度为1的时候\n\tfor(int j = 2;j<=m;++j){\n\t\tdp[1][j]=dp[1][j-1]+1;\n\t} \n    // 求dp，i为宽，j为高\n\tfor(int i = 2;i<=n;++i){\n\t\tfor(int j = 2;j<=m;++j){\n           dp[i][j]=(dp[i][j-1]+dp[i-1][j])%mod;\n\t\t}\n\t}\n\t\n\t// 宽度为0时答案应该为1，因为下面用的乘法\n\tfor(int j=0;j<=m;++j){\n\t\tdp[0][j]=1;\n\t} \n\n   // 高度为0时，也应该是1，即取0\n   for(int i = 0;i<=n;++i){\n\t   dp[i][0]=1;\n   }\n\t\n\t// cout<<dp[1][1]<<endl<<dp[2][1]<<endl<<dp[1][2]<<endl<<dp[2][2]<<endl<<dp[1][3]<<endl<<dp[2][3]<<endl; \n\n\t// 枚举山顶的情况,l是左边，r是右边，h是山高\n\tfor(int l = 1;l<=n;++l){\n\t\t\tfor(int h = 1;h<=m;++h){\n               ans = (ans+(dp[l-1][h-1]*dp[n-l][h])%mod)%mod;   // 是左边的情况乘以右边的情况\n\t\t\t}\n\t}\n\t\n\t// 加上山顶全为0的情况，只有一种\n\t ans=(ans+1)%mod;\n\n\tcout<<ans<<endl;\n\n\n}\n```","slug":"USST","published":1,"date":"2021-06-23T15:06:48.464Z","updated":"2021-06-23T15:20:45.782Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckq9myos30000wstkc1vt7hxy","content":"<h1 id=\"上海理工校赛题解报告\"><a href=\"#上海理工校赛题解报告\" class=\"headerlink\" title=\"上海理工校赛题解报告\"></a>上海理工校赛题解报告</h1><h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p>数学题，不会</p>\n<hr>\n<h2 id=\"B题-Bheith-i-ngra-le\"><a href=\"#B题-Bheith-i-ngra-le\" class=\"headerlink\" title=\"B题 Bheith i ngra le\"></a>B题 Bheith i ngra le</h2><p>当初挣扎了一下，然后不会求给定i行j列的格子有多少单调曲线，就放弃了。</p>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><ul>\n<li>题目的核心是是求给定i行j列的格子能够构造多少调单调曲线。可以用dp或者组合求解，不喜欢数学的我毅然投奔了dp。  </li>\n<li>不难发现，当给定了宽为i，高为j的格子矩阵的时候，我们分析右上角那块，如果这块不画，那么所有情况就会变成dp[i][j-1],如果这块画上，那么情况就会是dp[i-1][j]。则得到状态转移方程dp[i][j]=dp[i][j-1]+dp[i-1][j]。当然，边界条件还是值得考虑一下的。</li>\n<li>算出dp数组后，性高彩烈的用n<sup>3</sup>去套老鹅。其实我们确定了山顶左边位置l之后不用去确定右边的r，dp[n-l][h]就是右边包含山顶在内的全部可能。所以ans=ans+dp[l-1][h-1]*dp[n-l][h]即可。</li>\n</ul>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> dp[<span class=\"number\">2003</span>][<span class=\"number\">2003</span>];</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> mod=<span class=\"number\">1e9</span>+<span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ans;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n,m;</span><br><span class=\"line\">\tcin &gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化高度为1时</span></span><br><span class=\"line\">\tdp[<span class=\"number\">1</span>][<span class=\"number\">1</span>]=<span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>;i&lt;=n;++i)&#123;</span><br><span class=\"line\">\t\tdp[i][<span class=\"number\">1</span>]=dp[i<span class=\"number\">-1</span>][<span class=\"number\">1</span>]+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 初始化宽度为1的时候</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">2</span>;j&lt;=m;++j)&#123;</span><br><span class=\"line\">\t\tdp[<span class=\"number\">1</span>][j]=dp[<span class=\"number\">1</span>][j<span class=\"number\">-1</span>]+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\">    <span class=\"comment\">// 求dp，i为宽，j为高</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>;i&lt;=n;++i)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">2</span>;j&lt;=m;++j)&#123;</span><br><span class=\"line\">           dp[i][j]=(dp[i][j<span class=\"number\">-1</span>]+dp[i<span class=\"number\">-1</span>][j])%mod;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 宽度为0时答案应该为1，因为下面用的乘法</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;=m;++j)&#123;</span><br><span class=\"line\">\t\tdp[<span class=\"number\">0</span>][j]=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 高度为0时，也应该是1，即取0</span></span><br><span class=\"line\">   <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;=n;++i)&#123;</span><br><span class=\"line\">\t   dp[i][<span class=\"number\">0</span>]=<span class=\"number\">1</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;dp[1][1]&lt;&lt;endl&lt;&lt;dp[2][1]&lt;&lt;endl&lt;&lt;dp[1][2]&lt;&lt;endl&lt;&lt;dp[2][2]&lt;&lt;endl&lt;&lt;dp[1][3]&lt;&lt;endl&lt;&lt;dp[2][3]&lt;&lt;endl; </span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 枚举山顶的情况,l是左边，r是右边，h是山高</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> l = <span class=\"number\">1</span>;l&lt;=n;++l)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> h = <span class=\"number\">1</span>;h&lt;=m;++h)&#123;</span><br><span class=\"line\">               ans = (ans+(dp[l<span class=\"number\">-1</span>][h<span class=\"number\">-1</span>]*dp[n-l][h])%mod)%mod;   <span class=\"comment\">// 是左边的情况乘以右边的情况</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 加上山顶全为0的情况，只有一种</span></span><br><span class=\"line\">\t ans=(ans+<span class=\"number\">1</span>)%mod;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"上海理工校赛题解报告\"><a href=\"#上海理工校赛题解报告\" class=\"headerlink\" title=\"上海理工校赛题解报告\"></a>上海理工校赛题解报告</h1><h4 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h4><p>数学题，不会</p>\n<hr>\n<h2 id=\"B题-Bheith-i-ngra-le\"><a href=\"#B题-Bheith-i-ngra-le\" class=\"headerlink\" title=\"B题 Bheith i ngra le\"></a>B题 Bheith i ngra le</h2><p>当初挣扎了一下，然后不会求给定i行j列的格子有多少单调曲线，就放弃了。</p>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><ul>\n<li>题目的核心是是求给定i行j列的格子能够构造多少调单调曲线。可以用dp或者组合求解，不喜欢数学的我毅然投奔了dp。  </li>\n<li>不难发现，当给定了宽为i，高为j的格子矩阵的时候，我们分析右上角那块，如果这块不画，那么所有情况就会变成dp[i][j-1],如果这块画上，那么情况就会是dp[i-1][j]。则得到状态转移方程dp[i][j]=dp[i][j-1]+dp[i-1][j]。当然，边界条件还是值得考虑一下的。</li>\n<li>算出dp数组后，性高彩烈的用n<sup>3</sup>去套老鹅。其实我们确定了山顶左边位置l之后不用去确定右边的r，dp[n-l][h]就是右边包含山顶在内的全部可能。所以ans=ans+dp[l-1][h-1]*dp[n-l][h]即可。</li>\n</ul>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> dp[<span class=\"number\">2003</span>][<span class=\"number\">2003</span>];</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> mod=<span class=\"number\">1e9</span>+<span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ans;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n,m;</span><br><span class=\"line\">\tcin &gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化高度为1时</span></span><br><span class=\"line\">\tdp[<span class=\"number\">1</span>][<span class=\"number\">1</span>]=<span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>;i&lt;=n;++i)&#123;</span><br><span class=\"line\">\t\tdp[i][<span class=\"number\">1</span>]=dp[i<span class=\"number\">-1</span>][<span class=\"number\">1</span>]+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 初始化宽度为1的时候</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">2</span>;j&lt;=m;++j)&#123;</span><br><span class=\"line\">\t\tdp[<span class=\"number\">1</span>][j]=dp[<span class=\"number\">1</span>][j<span class=\"number\">-1</span>]+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\">    <span class=\"comment\">// 求dp，i为宽，j为高</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>;i&lt;=n;++i)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">2</span>;j&lt;=m;++j)&#123;</span><br><span class=\"line\">           dp[i][j]=(dp[i][j<span class=\"number\">-1</span>]+dp[i<span class=\"number\">-1</span>][j])%mod;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 宽度为0时答案应该为1，因为下面用的乘法</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;=m;++j)&#123;</span><br><span class=\"line\">\t\tdp[<span class=\"number\">0</span>][j]=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 高度为0时，也应该是1，即取0</span></span><br><span class=\"line\">   <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;=n;++i)&#123;</span><br><span class=\"line\">\t   dp[i][<span class=\"number\">0</span>]=<span class=\"number\">1</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;dp[1][1]&lt;&lt;endl&lt;&lt;dp[2][1]&lt;&lt;endl&lt;&lt;dp[1][2]&lt;&lt;endl&lt;&lt;dp[2][2]&lt;&lt;endl&lt;&lt;dp[1][3]&lt;&lt;endl&lt;&lt;dp[2][3]&lt;&lt;endl; </span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 枚举山顶的情况,l是左边，r是右边，h是山高</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> l = <span class=\"number\">1</span>;l&lt;=n;++l)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> h = <span class=\"number\">1</span>;h&lt;=m;++h)&#123;</span><br><span class=\"line\">               ans = (ans+(dp[l<span class=\"number\">-1</span>][h<span class=\"number\">-1</span>]*dp[n-l][h])%mod)%mod;   <span class=\"comment\">// 是左边的情况乘以右边的情况</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 加上山顶全为0的情况，只有一种</span></span><br><span class=\"line\">\t ans=(ans+<span class=\"number\">1</span>)%mod;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"}],"PostAsset":[{"_id":"source/_posts/Postons/Potions(Hard_version).png","slug":"Potions(Hard_version).png","post":"ckpp77ova0000u8tkhdr22q6g","modified":0,"renderable":0},{"_id":"source/_posts/数据备份/backUp.png","slug":"backUp.png","post":"ckps1ze7u0000c0tkgsyfbk0y","modified":0,"renderable":0},{"_id":"source/_posts/BestCowFences/BestCowFence.png","slug":"BestCowFence.png","post":"ckpun1mbr0000xktk8n1z1mld","modified":0,"renderable":0},{"_id":"source/_posts/MaxMedian/MaxMedian.png","slug":"MaxMedian.png","post":"ckpupip0m0000uctk8c7s0zz9","modified":0,"renderable":0}],"PostCategory":[{"post_id":"ckpp77ovf0002u8tk0ghb1f6y","category_id":"ckpp77ovl0008u8tk7l7i9gxo","_id":"ckpp77ovo000eu8tkhnexdcn7"},{"post_id":"ckpp77ovm000au8tkc3sf0c91","category_id":"ckpp77ovo000du8tka0zwc1yv","_id":"ckpp77ovp000ju8tk1zzl9grn"},{"post_id":"ckpp77ova0000u8tkhdr22q6g","category_id":"ckps1ze7w0001c0tk6mwz8e1i","_id":"ckps1ze810005c0tk621g35ws"},{"post_id":"ckps1ze7u0000c0tkgsyfbk0y","category_id":"ckps1ze810003c0tkgv6mc40e","_id":"ckps1ze820006c0tkbosb91r0"},{"post_id":"ckpupip0m0000uctk8c7s0zz9","category_id":"ckps1ze7w0001c0tk6mwz8e1i","_id":"ckpupip0q0003uctkauyzhdlg"},{"post_id":"ckpun1mbr0000xktk8n1z1mld","category_id":"ckps1ze7w0001c0tk6mwz8e1i","_id":"ckpupip0s0005uctkd8tkbqly"}],"PostTag":[{"post_id":"ckpp77ova0000u8tkhdr22q6g","tag_id":"ckpp77ovi0004u8tk1wjkfb14","_id":"ckpp77ovp000gu8tk8ked6jco"},{"post_id":"ckpp77ova0000u8tkhdr22q6g","tag_id":"ckpp77ovl0009u8tk24dx2d6s","_id":"ckpp77ovp000hu8tkfo3dar5l"},{"post_id":"ckpp77ova0000u8tkhdr22q6g","tag_id":"ckpp77ovn000cu8tkbv43fe7d","_id":"ckpp77ovp000ku8tkgexvbukv"},{"post_id":"ckpp77ovf0002u8tk0ghb1f6y","tag_id":"ckpp77ovo000fu8tk6ehj2pw5","_id":"ckpp77ovp000lu8tkhgizgm2y"},{"post_id":"ckpp77ovi0005u8tkdad5eag9","tag_id":"ckpp77ovp000iu8tk43q45eju","_id":"ckpp77ovr000nu8tk4e8tbunu"},{"post_id":"ckpp77ovj0006u8tk6gjdencj","tag_id":"ckpp77ovo000fu8tk6ehj2pw5","_id":"ckpp77ovs000ru8tkfp884a20"},{"post_id":"ckpp77ovj0006u8tk6gjdencj","tag_id":"ckpp77ovr000ou8tk04x83yjr","_id":"ckpp77ovs000su8tk0hgz61xz"},{"post_id":"ckpp77ovj0006u8tk6gjdencj","tag_id":"ckpp77ovr000pu8tk138v29ny","_id":"ckpp77ovs000uu8tkd8889g6x"},{"post_id":"ckpp77ovm000au8tkc3sf0c91","tag_id":"ckpp77ovs000vu8tk897w4xn1","_id":"ckpp77ovt000yu8tke02rbgd0"},{"post_id":"ckps1ze7u0000c0tkgsyfbk0y","tag_id":"ckps1ze800002c0tk5vk63n5o","_id":"ckps1ze810004c0tk1ltd9tcm"},{"post_id":"ckpun1mbr0000xktk8n1z1mld","tag_id":"ckpun1mbx0002xktk83sy5osg","_id":"ckpun1mbz0006xktk6zyl8ajm"},{"post_id":"ckpun1mbr0000xktk8n1z1mld","tag_id":"ckpun1mbx0003xktkfal53f1l","_id":"ckpun1mbz0007xktk0ah04g70"},{"post_id":"ckpun1mbr0000xktk8n1z1mld","tag_id":"ckpun1mby0005xktkchx4bcu9","_id":"ckpun1mbz0008xktk30adh1cd"},{"post_id":"ckpupip0m0000uctk8c7s0zz9","tag_id":"ckpun1mbx0002xktk83sy5osg","_id":"ckpupip0p0001uctkbzp77srp"},{"post_id":"ckpupip0m0000uctk8c7s0zz9","tag_id":"ckpun1mbx0003xktkfal53f1l","_id":"ckpupip0p0002uctk2dao1rvl"},{"post_id":"ckpupip0m0000uctk8c7s0zz9","tag_id":"ckpun1mby0005xktkchx4bcu9","_id":"ckpupip0q0004uctke6fzguq7"}],"Tag":[{"name":"反悔","_id":"ckpp77ovi0004u8tk1wjkfb14"},{"name":"贪心","_id":"ckpp77ovl0009u8tk24dx2d6s"},{"name":"优先队列","_id":"ckpp77ovn000cu8tkbv43fe7d"},{"name":"JAVA","_id":"ckpp77ovo000fu8tk6ehj2pw5"},{"name":"动态规划","_id":"ckpp77ovp000iu8tk43q45eju"},{"name":"SptingBoot","_id":"ckpp77ovr000ou8tk04x83yjr"},{"name":"数据库","_id":"ckpp77ovr000pu8tk138v29ny"},{"name":"数学","_id":"ckpp77ovs000qu8tkbnsy296n"},{"name":"队列","_id":"ckpp77ovs000tu8tk3wvx9cau"},{"name":"-分治法","_id":"ckpp77ovs000vu8tk897w4xn1"},{"name":"-贪心 -反悔 -优先队列","_id":"ckps1ze800002c0tk5vk63n5o"},{"name":"限定长度最大子段和","_id":"ckpun1mbx0002xktk83sy5osg"},{"name":"思维","_id":"ckpun1mbx0003xktkfal53f1l"},{"name":"二分答案","_id":"ckpun1mby0005xktkchx4bcu9"}]}}
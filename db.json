{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","path":"lib/font-awesome/webfonts/fa-brands-400.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","path":"lib/font-awesome/css/all.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","path":"lib/font-awesome/webfonts/fa-solid-900.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","path":"lib/font-awesome/webfonts/fa-regular-400.woff2","modified":0,"renderable":1},{"_id":"source/categories/index.pdf","path":"categories/index.pdf","modified":0,"renderable":0}],"Cache":[{"_id":"source/About-me/index.md","hash":"964a080d4c60b47acb2fc39fee02789c767eb23c","modified":1626344126438},{"_id":"source/_posts/EducationalCodeforcesRound111.md","hash":"ecc8704dc8e7d85bdff28e63a666243161e426f0","modified":1626486821298},{"_id":"source/_posts/BestCowFences.md","hash":"15030ed855bb6c0962b64b8f38aff57d2bde48fe","modified":1626344126450},{"_id":"source/_posts/IDEApush到github被拒绝的问题.md","hash":"84b8b82d95c63ff4892701b3e47bc93b52133cce","modified":1626344126457},{"_id":"source/_posts/MaxMedian.md","hash":"a64b5b32776d126862f8b58b056b2e31d42e65c6","modified":1626344126457},{"_id":"source/_posts/Postons.md","hash":"9687128903e27f6272f97cde64694ba6819ca8c6","modified":1626344126463},{"_id":"source/_posts/sptingboot集成mybatis.md","hash":"793bf9cbfecda8f5300a20e4dc912d65120dbdbc","modified":1626344126479},{"_id":"source/_posts/数据备份.md","hash":"487f11652d9e3d6a846be211088c586e180f7a2b","modified":1626344126481},{"_id":"source/_posts/关于对floyd算法的质疑.md","hash":"febb4803470577943d85fb5e1f5e6e7904d74a82","modified":1626344126479},{"_id":"source/_posts/USST题解报告.md","hash":"009249bfed023a131f8c1b68ba3eb405c02ba5b0","modified":1626367517545},{"_id":"source/_posts/在O-logn-的复杂度下两数组的混合中位数.md","hash":"d1b313d0a4a3039edc7d01f85cec31790483807d","modified":1626344126480},{"_id":"source/_posts/牛客欢乐赛8E.md","hash":"084838c03a4b53863f39dfdda74510415ffdfa76","modified":1626367138271},{"_id":"source/categories/index.pdf","hash":"a258a88a5bcf8099859ba5263f7c9d94eea6eca8","modified":1626344126495},{"_id":"source/tags/index.md","hash":"aaa09584cbf09c86c3826d2d9016f2e9572d7643","modified":1626344126496},{"_id":"source/categories/index.md","hash":"124f9625b57cff69d2f39ecbdf71eff7b45560c3","modified":1626344126494},{"_id":"source/tags/index_tmp.html","hash":"7639c64003161b903d8d7efb717f5f5670f00bda","modified":1626344126498},{"_id":"source/_posts/EducationalCodeforcesRound111/CF111_1.png","hash":"4cdf8bee3b1e8efe00f010530ee18d865cc96acf","modified":1626449662472},{"_id":"source/_posts/EducationalCodeforcesRound111/CF111_2.png","hash":"535fafa952e6a48b063439973008e8adcea15c4e","modified":1626449675278},{"_id":"source/_posts/EducationalCodeforcesRound111/CF111_3.png","hash":"d894693df812aeb762629fdd71bd29797019ea05","modified":1626449698525},{"_id":"source/_posts/USST题解/M.png","hash":"fa97730a331a85a7e5e1055c0138e9d9767cd49b","modified":1626344126474},{"_id":"source/_posts/USST题解/M2.png","hash":"13dadca51a8f67b0b2fb83197f85d67a982f6fa2","modified":1626344126475},{"_id":"source/_posts/牛客欢乐赛8E/1.png","hash":"e3a161095c32dacdeb812bbeea83bcd51d95b273","modified":1626344126492},{"_id":"source/_posts/牛客欢乐赛8E/2.png","hash":"50612dcc44432a03c20d45ed8d891ae743db7eab","modified":1626344126493},{"_id":"source/_posts/EducationalCodeforcesRound111/CF111_0.png","hash":"8dc7fd3fb14f0eff6bce2c5a202abbacffc3847d","modified":1626452662144},{"_id":"source/_posts/USST题解报告.pdf","hash":"070c50a5cebfc98de03fe4f922df4de062fa8e35","modified":1626367525236},{"_id":"source/_posts/牛客欢乐赛8E.pdf","hash":"66eab4e6cc33878c0e7f8f9c9132fba5036c6fdb","modified":1626367144660},{"_id":"source/_posts/EducationalCodeforcesRound111.pdf","hash":"75a745b67372d79f90c12a59489face98431c235","modified":1626486841454},{"_id":"source/_posts/BestCowFences/BestCowFence.png","hash":"cba042a07e1eed0b0ddd78e61fe006647bed5323","modified":1626344126455},{"_id":"source/_posts/MaxMedian/MaxMedian.png","hash":"a51a9bbdc1ba4026d2073b0c4abe23ffdafb2f55","modified":1626344126462},{"_id":"themes/next/layout/_partials/footer.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1626344126595},{"_id":"themes/next/.editorconfig","hash":"731c650ddad6eb0fc7c3d4a91cad1698fe7ad311","modified":1626344126525},{"_id":"themes/next/.gitattributes","hash":"3e00e1fb043438cd820d94ee3dc9ffb6718996f3","modified":1626344126526},{"_id":"themes/next/.gitignore","hash":"83418530da80e6a78501e1d62a89c3bf5cbaec3d","modified":1626344126542},{"_id":"themes/next/.eslintrc.json","hash":"d3c11de434171d55d70daadd3914bc33544b74b8","modified":1626344126526},{"_id":"themes/next/LICENSE.md","hash":"0a9c7399f102b4eb0a6950dd31264be421557c7d","modified":1626344126544},{"_id":"themes/next/.travis.yml","hash":"379f31a140ce41e441442add6f673bf397d863ea","modified":1626344126543},{"_id":"themes/next/.stylintrc","hash":"6259e2a0b65d46865ab89564b88fc67638668295","modified":1626344126543},{"_id":"themes/next/_config.yml","hash":"141bd8d8ac6425861a1064573d1ab710a54670d6","modified":1626365251777},{"_id":"themes/next/README.md","hash":"7d56751b580d042559b2acf904fca4b42bcb30a7","modified":1626344126545},{"_id":"themes/next/gulpfile.js","hash":"0c76a1ac610ee8cbe8e2cc9cca1c925ffd0edf98","modified":1626344126569},{"_id":"themes/next/package.json","hash":"b099e7cea4406e209130410d13de87988ba37b2a","modified":1626344126655},{"_id":"themes/next/crowdin.yml","hash":"4a53f5985e545c635cb56b2a57ed290cb8cf8942","modified":1626344126546},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"778b7e052993ed59f21ed266ba7119ee2e5253fb","modified":1626344126528},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5ddde54fb50d11dc08cec899a3588addb56aa386","modified":1626344126529},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"d2f8e6b65783e31787feb05d2ccea86151f53f35","modified":1626344126535},{"_id":"themes/next/.github/issue-close-app.yml","hash":"b14756e65546eb9ecc9d4393f0c9a84a3dac1824","modified":1626344126537},{"_id":"themes/next/.github/config.yml","hash":"df3d970700e6b409edc3d23be8d553db78d5ba3f","modified":1626344126536},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"533fbe6b2f87d7e7ec6949063bb7ea7eb4fbe52d","modified":1626344126537},{"_id":"themes/next/.github/lock.yml","hash":"3ce3d0a26030a1cd52b273cc6a6d444d7c8d85c2","modified":1626344126538},{"_id":"themes/next/.github/mergeable.yml","hash":"1c1cb77a62df1e3654b151c2da34b4a10d351170","modified":1626344126539},{"_id":"themes/next/.github/release-drafter.yml","hash":"09c3352b2d643acdc6839601ceb38abc38ab97c5","modified":1626344126540},{"_id":"themes/next/.github/stale.yml","hash":"590b65aca710e0fba75d3cf5361a64d13b6b0f63","modified":1626344126541},{"_id":"themes/next/docs/AGPL3.md","hash":"f463f95b169d64983f59fa6f3e4b6760290a0e6b","modified":1626344126548},{"_id":"themes/next/.github/support.yml","hash":"7ce2722d6904c31a086444c422dc49b6aa310651","modified":1626344126541},{"_id":"themes/next/docs/DATA-FILES.md","hash":"980fb8d37701f7fd96b30bb911519de3bbb473d1","modified":1626344126552},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"60c7e9ef0c578deebad43e9395c958fa61096baf","modified":1626344126549},{"_id":"themes/next/docs/LICENSE.txt","hash":"ae5ad07e4f4106bad55535dba042221539e6c7f9","modified":1626344126554},{"_id":"themes/next/docs/AUTHORS.md","hash":"cde7cc095ac31b421a573042cf61060f90d9ad0d","modified":1626344126551},{"_id":"themes/next/docs/INSTALLATION.md","hash":"07ea00bee149a1bdc9073e903ee6b411e9f2f818","modified":1626344126552},{"_id":"themes/next/languages/ar.yml","hash":"abcf220bd615cec0dd50e4d98da56580169d77e1","modified":1626344126570},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"6cc663db5e99fd86bb993c10d446ad26ada88e58","modified":1626344126554},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"1e86d32063b490d204baa9d45d8d3cb22c24a37d","modified":1626344126556},{"_id":"themes/next/docs/MATH.md","hash":"f56946053ade0915ff7efa74d43c38b8dd9e63bb","modified":1626344126555},{"_id":"themes/next/languages/de.yml","hash":"15078b7ede1b084e8a6a15d271f0db9c325bd698","modified":1626344126571},{"_id":"themes/next/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1626344126571},{"_id":"themes/next/languages/en.yml","hash":"dbb64776f9c001c54d0058256c415a9a0724ed5d","modified":1626344126572},{"_id":"themes/next/languages/fr.yml","hash":"3e2f89d4bb4441d33ecc7b5a4ee114f627603391","modified":1626344126575},{"_id":"themes/next/languages/es.yml","hash":"f064c793d56a5e0f20cda93b6f0e355044efc7d8","modified":1626344126573},{"_id":"themes/next/languages/hu.yml","hash":"0ea89ffaefd02a10494995f05a2a59d5e5679a28","modified":1626344126576},{"_id":"themes/next/languages/fa.yml","hash":"6c0a7d5bcc26eb45a9f3e02f13117c668e77fffd","modified":1626344126574},{"_id":"themes/next/languages/id.yml","hash":"7599bb0ecf278beb8fde3d17bfc148a3241aef82","modified":1626344126577},{"_id":"themes/next/languages/ja.yml","hash":"bf279d0eb1911806d01a12f27261fbc76a3bb3f9","modified":1626344126578},{"_id":"themes/next/languages/it.yml","hash":"46222f468e66789e9ba13095809eb5e5b63edf30","modified":1626344126577},{"_id":"themes/next/languages/ko.yml","hash":"af4be6cb394abd4e2e9a728418897d2ed4cc5315","modified":1626344126579},{"_id":"themes/next/languages/nl.yml","hash":"9749cf90b250e631dd550a4f32ada3bb20f66dd0","modified":1626344126580},{"_id":"themes/next/languages/pt-BR.yml","hash":"69aa3bef5710b61dc9a0f3b3a8f52f88c4d08c00","modified":1626344126582},{"_id":"themes/next/languages/ru.yml","hash":"012abc694cf9de281a0610f95f79c594f0a16562","modified":1626344126584},{"_id":"themes/next/languages/tr.yml","hash":"46e09f2119cbfbcf93fb8dbd267dccabeb8b0cda","modified":1626344126584},{"_id":"themes/next/languages/uk.yml","hash":"69ef00b1b8225920fcefff6a6b6f2f3aad00b4ce","modified":1626344126586},{"_id":"themes/next/languages/vi.yml","hash":"6a578cc28773bd764f4418110500478f185d6efa","modified":1626344126587},{"_id":"themes/next/languages/zh-CN.yml","hash":"81d73e21402dad729053a3041390435f43136a68","modified":1626344126587},{"_id":"themes/next/languages/pt.yml","hash":"f6606dd0b916a465c233f24bd9a70adce34dc8d6","modified":1626344126583},{"_id":"themes/next/languages/zh-tw.yml","hash":"cf0740648725983fb88409d6501876f8b79db41d","modified":1626344126589},{"_id":"themes/next/languages/zh-hk.yml","hash":"92ccee40c234626bf0142152949811ebe39fcef2","modified":1626344126588},{"_id":"themes/next/layout/_layout.swig","hash":"9554bd0f5c5a0438aa7b64065be5561c374d260e","modified":1626344126590},{"_id":"themes/next/layout/index.swig","hash":"8dfd96fb6f833dd5d037de800813105654e8e8e6","modified":1626344126652},{"_id":"themes/next/layout/category.swig","hash":"c546b017a956faaa5f5643c7c8a363af7ac9d6b9","modified":1626344126651},{"_id":"themes/next/layout/archive.swig","hash":"d9bca77f6dcfef71e300a294f731bead11ce199f","modified":1626344126650},{"_id":"themes/next/layout/page.swig","hash":"357d916694d4c9a0fd1140fa56d3d17e067d8b52","modified":1626344126653},{"_id":"themes/next/layout/post.swig","hash":"5f0b5ba2e0a5b763be5e7e96611865e33bba24d7","modified":1626344126653},{"_id":"themes/next/scripts/renderer.js","hash":"e3658eea97b1183ee2e9f676231e53f7994741f6","modified":1626344126676},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"e67146befddec3a0dc47dc80d1109070c71d5d04","modified":1626344126530},{"_id":"themes/next/layout/tag.swig","hash":"d44ff8755727f6532e86fc9fc8dc631200ffe161","modified":1626344126655},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"d5aa1a3323639a36bcd9a401484b67537043cd3c","modified":1626344126533},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"6beeca0f45a429cd932b6e648617f548ff64c27c","modified":1626344126531},{"_id":"themes/next/.github/ISSUE_TEMPLATE/question.md","hash":"59275aa0582f793fee7be67904dcf52ad33a7181","modified":1626344126534},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"54e6a067ed95268eab6be2ba040a7e9b1907928e","modified":1626344126557},{"_id":"themes/next/docs/ru/README.md","hash":"1e5ddb26ad6f931f8c06ce2120f257ff38b74fdf","modified":1626344126559},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"a9cfe5ac9ef727a8650b2b6584482751a26b1460","modified":1626344126558},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"cb8e39c377fc4a14aaf133b4d1338a48560e9e65","modified":1626344126560},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"3202be9a8d31986caac640e7a4c7ce22e99917eb","modified":1626344126561},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"611f2930c2b281b80543531b1bf33d082531456a","modified":1626344126563},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"7e6f227f2aaf30f400d4c065650a4e3d0d61b9e1","modified":1626344126562},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"2d868cd271d78b08775e28c5b976de8836da4455","modified":1626344126563},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"0d46f9f50cf2e4183970adce705d1041155b0d37","modified":1626344126566},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"716111dd36d276f463c707dfcc9937fea2a1cf7a","modified":1626344126565},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"50ab381c27611d5bf97bb3907b5ca9998f28187d","modified":1626344126566},{"_id":"themes/next/docs/zh-CN/README.md","hash":"8f7c0d0b766024152591d4ccfac715c8e18b37f3","modified":1626344126567},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"30ade8c806d7826cc50a4a3e46a9e6213fddf333","modified":1626344126591},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"b3201934b966bc731eaf8a4dad4ba4bdcd300c10","modified":1626344126568},{"_id":"themes/next/layout/_macro/post.swig","hash":"c3fd56bac90ce45a0c79ddfe68beb223ad0d72b4","modified":1626344126592},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"5bffdb1448caca7db7b1f84e1693e6657a106d50","modified":1626344126593},{"_id":"themes/next/layout/_scripts/index.swig","hash":"1822eaf55bbb4bec88871c324fc18ad95580ccb4","modified":1626344126616},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"ccff5a773644d33ff22f6b45b6734f52b048f22b","modified":1626344126619},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"7b9e0f776a5be6c3f95bc7f394e1424ba02ba93b","modified":1626344126616},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"244ca2d74ee0d497c87572c6a26b43c62a952673","modified":1626344126624},{"_id":"themes/next/layout/_scripts/three.swig","hash":"6b092c6d882b2dfa5273e1b3f60b244cb7c29fcd","modified":1626344126623},{"_id":"themes/next/layout/_partials/comments.swig","hash":"142efb4c6b73d8f736f6784804b40d5871333172","modified":1626344126594},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"2de77d533c91532a8a4052000244d0c1693370df","modified":1626344126606},{"_id":"themes/next/layout/_partials/languages.swig","hash":"c3ea82604a5853fb44c5f4e4663cbe912aa5dcf8","modified":1626344126602},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"28b0a7e843ec4365db1963646659a153753cd746","modified":1626344126629},{"_id":"themes/next/layout/_third-party/index.swig","hash":"c6b63cbc80938e6e09578b8c67e01adf13a9e3bd","modified":1626344126636},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"5392dcbb504266f0f61d5b8219914068ef9cdc25","modified":1626344126615},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"269102fc5e46bd1ce75abdcce161f0570ae70e2f","modified":1626344126639},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"5ae5adcd6f63ed98b2071e4f7e5e38c4d7d24e1b","modified":1626344126639},{"_id":"themes/next/scripts/events/index.js","hash":"5c355f10fe8c948a7f7cd28bd8120adb7595ebde","modified":1626344126657},{"_id":"themes/next/scripts/filters/front-matter.js","hash":"305d03c1e45782988809298c3e3b3c5d5ee438aa","modified":1626344126669},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"ad321db012cea520066deb0639335e9bc0dcc343","modified":1626344126668},{"_id":"themes/next/scripts/filters/minify.js","hash":"21196a48cb127bf476ce598f25f24e8a53ef50c2","modified":1626344126670},{"_id":"themes/next/scripts/filters/locals.js","hash":"a5e7d05d3bd2ae6dcffad5a8ea0f72c6e55dbd02","modified":1626344126669},{"_id":"themes/next/scripts/filters/post.js","hash":"57f2d817578dd97e206942604365e936a49854de","modified":1626344126671},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"b8d7ddfa4baa9b8d6b9066a634aa81c6243beec9","modified":1626344126673},{"_id":"themes/next/scripts/helpers/font.js","hash":"8fb1c0fc745df28e20b96222974402aab6d13a79","modified":1626344126673},{"_id":"themes/next/scripts/helpers/engine.js","hash":"eb6b8bbc1dce4846cd5e0fac0452dbff56d07b5d","modified":1626344126672},{"_id":"themes/next/scripts/tags/button.js","hash":"bb0e8abbc0a6d5b3a1a75a23976f2ac3075aab31","modified":1626344126677},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"840536754121e0da5968f5ad235f29200fc5d769","modified":1626344126678},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"e2d0184bc4a557e1017395b80ff46880078d8537","modified":1626344126679},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"4044129368d0e2811859a9661cad8ab47118bc32","modified":1626344126675},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"93ccd3f99d3cb42674f29183c756df63acb5d7f8","modified":1626344126680},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"81134494ff0134c0dae1b3815caf6606fccd4e46","modified":1626344126681},{"_id":"themes/next/scripts/tags/note.js","hash":"1fdf4f95810fdb983bfd5ad4c4f13fedd4ea2f8d","modified":1626344126682},{"_id":"themes/next/scripts/tags/label.js","hash":"fc83f4e1be2c34e81cb79938f4f99973eba1ea60","modified":1626344126681},{"_id":"themes/next/scripts/tags/tabs.js","hash":"c70a4a66fd0c28c98ccb6c5d5f398972e5574d28","modified":1626344126683},{"_id":"themes/next/scripts/tags/video.js","hash":"944293fec96e568d9b09bc1280d5dbc9ee1bbd17","modified":1626344126684},{"_id":"themes/next/scripts/tags/pdf.js","hash":"37b53661ad00a01a2ca7d2e4a5ad3a926073f8e2","modified":1626344126682},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1626344126764},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1626344126766},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1626344126765},{"_id":"themes/next/source/images/avatar.gif","hash":"1dd8c28b25e25a9a70841c6309440bfe08fb41f8","modified":1626344126765},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1626344126767},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1626344126768},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1626344126771},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1626344126769},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1626344126770},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1626344126771},{"_id":"themes/next/source/js/algolia-search.js","hash":"6a813410e33824d7acc65a369a2983912bb3420c","modified":1626344126774},{"_id":"themes/next/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1626344126773},{"_id":"themes/next/source/js/bookmark.js","hash":"9f05fd3672789311dc0cf5b37e40dc654cb04a2a","modified":1626344126775},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1626344126773},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1626344126772},{"_id":"themes/next/source/js/local-search.js","hash":"cfa6a0f3f9c2bc759ee507668a21f4e8f250f42a","modified":1626344126776},{"_id":"themes/next/source/js/utils.js","hash":"26a82e46fdcadc7c3c2c56a7267284b61a26f7f3","modified":1626344126780},{"_id":"themes/next/source/js/next-boot.js","hash":"250d8dcd6322e69e3fbadd0f3e37081c97b47c52","modified":1626344126777},{"_id":"themes/next/source/js/motion.js","hash":"d5aa1a08cdf3c8d1d8d550fb1801274cc41e5874","modified":1626344126776},{"_id":"themes/next/source/css/_colors.styl","hash":"11aef31a8e76f0f332a274a8bfd4537b73d4f88f","modified":1626344126685},{"_id":"themes/next/source/lib/anime.min.js","hash":"960be51132134acd65c2017cc8a5d69cb419a0cd","modified":1626344126781},{"_id":"themes/next/source/css/_mixins.styl","hash":"072a3fa473c19b20ccd7536a656cda044dbdae0a","modified":1626344126743},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"34c05e9d73b0f081db70990c296b6d6a0f8ea2ca","modified":1626344126618},{"_id":"themes/next/source/css/main.styl","hash":"815ef30987d02f3d76dbe4b5ee3a72135a152678","modified":1626344126763},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"0b44f400ec00d2b5add5ee96c11d22465c432376","modified":1626344126620},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"34495d408e8467555afee489500b8aad98c52079","modified":1626344126620},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"7d638e413f2548fc990c4a467dd03de6c81fc960","modified":1626344126597},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"34495d408e8467555afee489500b8aad98c52079","modified":1626344126621},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"0b44f400ec00d2b5add5ee96c11d22465c432376","modified":1626344126621},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"91056a6c98cca63ff8cc6956e531ee3faf4b8ad9","modified":1626344126599},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"90cce9f407e9490756ba99580e3eb09f55b05eaa","modified":1626344126598},{"_id":"themes/next/layout/_partials/header/menu-item.swig","hash":"4baa86ca631168fc6388d27f4b1b501b40c877a8","modified":1626344126600},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"bed6cc2b48cf2655036ba39c9bae73a295228a4d","modified":1626344126602},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"0dd316f153c492c0a03bd0273d50fa322bc81f11","modified":1626344126600},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"90d3eaba6fbe69bee465ddd67c467fd2c0239dc4","modified":1626344126601},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"91c0addb33006619faa4c32e5d66874e25f1e9b3","modified":1626344126604},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"8d4e3dd0d3631ce0b21bc15c259f6ac886de631d","modified":1626344126605},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"f2eb455c8bf13533427254f0c9b4b17b2498168b","modified":1626344126607},{"_id":"themes/next/layout/_partials/post/post-followme.swig","hash":"d8f785c062c6b0763a778bd4a252e6f5fee0e432","modified":1626344126608},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"a6c761d5193cb6f22e9422dbbcf209e05471b0ed","modified":1626344126612},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"ce712c110b5ce8aacba7a86b0558ff89700675c9","modified":1626344126608},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"bc7b047a6246df07767373644b1637d91c3a88b1","modified":1626344126609},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"128f7d679bb4d53b29203d598d217f029a66dee7","modified":1626344126612},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"f349a226e5370075bb6924e60da8b0170c7cfcc1","modified":1626344126610},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"98fd1f5df044f4534e1d4ca9ab092ba5761739a9","modified":1626344126611},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"7b2ef5db9615267a24b884388925de1e9b447c1f","modified":1626344126614},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"b8819bd056f8a580c5556d4415836a906ed5d7a4","modified":1626344126626},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"85b60e222712ca3b2c4dc2039de2dc36b8d82940","modified":1626344126628},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"91c2cb900c76224c5814eeb842d1d5f517f9bf05","modified":1626344126627},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"84adaadd83ce447fa9da2cff19006334c9fcbff9","modified":1626344126625},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"fb94ee487d75e484e59b7fba96e989f699ff8a83","modified":1626344126630},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"9298e6d6c4a62a0862fc0f4060ed99779d7b68cb","modified":1626344126632},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"2642e8aef5afbe23a2a76efdc955dab2ee04ed48","modified":1626344126630},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"59df21fcfe9d0ada8cee3188cb1075529c1c3eb8","modified":1626344126637},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"1b29b99fa921f12c25d3dc95facdf84ef7bb1b5c","modified":1626344126632},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"a42f97eda3748583bac2253c47fe5dfa54f07b8f","modified":1626344126633},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"3d91899ca079e84d95087b882526d291e6f53918","modified":1626344126635},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"606ad14a29320157df9b8f33738282c51bb393d9","modified":1626344126634},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"276f523e414d4aa7f350a8f2fd3df8a3d8ea9656","modified":1626344126638},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"1f34b2d3c753a3589ab6c462880bd4eb7df09914","modified":1626344126638},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"ae2707d6e47582bb470c075649ec7bad86a6d5a9","modified":1626344126635},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.swig","hash":"d2f0e4c598410ec33785abe302c7ea7492bb791a","modified":1626344126644},{"_id":"themes/next/layout/_third-party/statistics/index.swig","hash":"964cd6bac668cf6d211a2624fbef3948cfdece55","modified":1626344126647},{"_id":"themes/next/layout/_third-party/statistics/firestore.swig","hash":"01d94354d07e72cad47100482068b6be69fcc033","modified":1626344126646},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.swig","hash":"c171ea94e9afbba97f06856904264da331559463","modified":1626344126648},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.swig","hash":"53a0760c75d5aaabb3ce8e8aa8e003510d59807f","modified":1626344126646},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"58296a5c1883f26464c2a5ccf734c19f5fbf395a","modified":1626344126641},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"619338ddacf01e3df812e66a997e778f672f4726","modified":1626344126649},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"fd726aad77a57b288f07d6998ec29291c67c7cbb","modified":1626344126640},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"aa6ab95b8b76611694613defb4bf25003d1b927f","modified":1626344126642},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"5a223b60406cee7438cfe3a5e41d1284425aa7a5","modified":1626344126650},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"08496b71c9939718e7955704d219e44d7109247b","modified":1626344126659},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"2f22f48f7370470cef78561a47c2a47c78035385","modified":1626344126662},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"e73f697bb160b223fdde783237148be5f41c1d78","modified":1626344126660},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"713056d33dbcd8e9748205c5680b456c21174f4e","modified":1626344126663},{"_id":"themes/next/scripts/events/lib/config.js","hash":"aefe3b38a22bc155d485e39187f23e4f2ee5680a","modified":1626344126658},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"0c3bea89d64bc12c1bbe6f208a83773c6fb5375a","modified":1626344126663},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"67cf90d9a2428c14eb113a64bdd213c22a019aef","modified":1626344126665},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"323a47df6ded894944a2647db44556d6163e67c4","modified":1626344126666},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"a4f3153ac76a7ffdf6cc70f52f1b2cc218ed393e","modified":1626344126667},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"3a80559df0b670ccb065ea9d3bb587d0b61be3a4","modified":1626344126664},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"851359f5ff90f733a9bd7fe677edbee8b8ac714c","modified":1626344126667},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"5980abbbbeacd8541121f436fa414d24ad5e97c2","modified":1626344126760},{"_id":"themes/next/source/js/schemes/muse.js","hash":"a18559a9c332199efad0100cf84bb0c23fc0f17a","modified":1626344126778},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"b85a6e2af1387fe64b51e7cd3e2da8616e6f5a3f","modified":1626344126779},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"c22b58af3327236ec54d5706501aa5a20e15012e","modified":1626344126760},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"583ff1e7a2ca889f1f54eb0ca793894466823c7c","modified":1626344126759},{"_id":"themes/next/source/css/_variables/base.styl","hash":"ad680efdfb2f86546182bf3f59886efbcf3c1b2d","modified":1626344126762},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1626344126788},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"4e33774b1fe6d0a51f3a428c54c5e600e83bf154","modified":1626344126761},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1626344126789},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"7a95c27762e1303bf06ee808c63f616cb192fcaf","modified":1626344126718},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"510a6f0ba7485dd54ce347cca890ab52c4957081","modified":1626344126687},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"d17236df3b4d6def1e4e81133ef4729c390de3ac","modified":1626344126688},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"a2ee16cac29a82cfce26804c160286fcbee94161","modified":1626344126717},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"0534b329d279a6f255112b3305ff92c810f31724","modified":1626344126687},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"c52648a7b09f9fe37858f5694fcc1ffc709ad147","modified":1626344126705},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"4b068d0d898f4e624937503f0e1428993050bd65","modified":1626344126728},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"45f4badac6ec45cf24355f6157aece1d4d3f1134","modified":1626344126728},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5540c9259cb7895a5f10a289c7937e5470a7c134","modified":1626344126727},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"6d740699fb6a7640647a8fd77c4ea4992d8d6437","modified":1626344126733},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"e342b8f8e11a3a6aa5a029912c9778c25bf5d135","modified":1626344126744},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"b619f39e18398422e0ac4999d8f042a5eaebe9cd","modified":1626344126734},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"f317d2e3886e94f5fbb8781c2e68edd19669ff58","modified":1626344126734},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"43045d115f8fe95732c446aa45bf1c97609ff2a5","modified":1626344126734},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"20e0e3e3eba384930c022e21511214d244b4c9e7","modified":1626344126742},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"8674bd88df076a1dfe4023ed6750ded1f5b00223","modified":1626344126749},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"49c76bc723d3952abb613d9d68398ed7305da999","modified":1626344126749},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"b9e87d32da24264bda247c1526afe140c858b0ef","modified":1626344126745},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"9898323ee5a7ac2a5d4f633c653112280beb2643","modified":1626344126751},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"4b7f057dbb53efd7cbe7eac7835a793ab3cbb135","modified":1626344126750},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"25c2a7930da14f023329df20f38df2728057fb4d","modified":1626344126753},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"716e8b0f056bf6393e6bc6969ac84598ab8e7a6f","modified":1626344126746},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"12b265f82840f27112ca2b1be497677f20f87545","modified":1626344126746},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"2d3e05015796a790abd9d68957a5c698c0c9f9b6","modified":1626344126752},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"c5142739e01e9f25c8b32b2209af85c787bb2b42","modified":1626344126748},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5de34e1d8a290751641ae456c942410852d5e809","modified":1626344126755},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"e1c29b81a32273a0dedd926cda199a71aea72624","modified":1626344126747},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"0a9f0d9eb042595502d200fb8c65efb0e6c89aa9","modified":1626344126756},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"558794fced306339b98dc2b0ee7f0576802f1355","modified":1626344126755},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"b69ac38b9da8c9c1b7de696fdeea7f9d7705213a","modified":1626344126758},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"dc9318992ce2eb086ebaa2fe56b325e56d24098b","modified":1626344126757},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"25c2a7930da14f023329df20f38df2728057fb4d","modified":1626344126758},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","hash":"82e34d28f8a1169b20b60101d5bb0446deba3514","modified":1626344126783},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"7eeb22c5696f8e0c95161dc57703973cf81c8c12","modified":1626344126711},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"b4f4bae437d4f994af93cf142494ffcd86bae46b","modified":1626344126712},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1626344126786},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"300058ca12e81013e77ba01fe66ac210525768b6","modified":1626344126714},{"_id":"themes/next/source/css/_common/outline/header/headerband.styl","hash":"6d5f26646e2914474f295de8bf6dc327d4acd529","modified":1626344126714},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"b31c86d1a4f89837f9187bed646bda96b2cd286c","modified":1626344126713},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"49722d555a2edb18094bb2cb3d7336dd72051b93","modified":1626344126719},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"3d16ac0f4ccaeed868c246d4d49bde543d1f62cb","modified":1626344126716},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"b8c816fba0a9b4a35fbae03ba5b1b2da96ba2687","modified":1626344126716},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"357f825f0a649b2e28cba1481d4c9a0cb402e43a","modified":1626344126720},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"7a3a56b10ab714c0e2ed240d0939deeecdcad167","modified":1626344126715},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"525242ce9e912c4adfe5134347c67dbdb9e98e3d","modified":1626344126721},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"096f908c08ce553e482aadfd3e767a0145191093","modified":1626344126720},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"12f7eaf6b56624cbc411528562d6bb848ff97039","modified":1626344126722},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"b11b04737a1a0fea3bd9f0081d96ee6c015358d4","modified":1626344126723},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"098b4bdf49c7300490f959386d5d1185a32543f6","modified":1626344126724},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"fa0a2ea57b7b4ce75b5d18c264af2d92ea3192f9","modified":1626344126723},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"236a039b0900f4267de566b46f62314ad967d30f","modified":1626344126689},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"67a1fcb33535122d41acd24f1f49cf02c89b88fa","modified":1626344126725},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"5d540f683018745a5ed1d6f635df28ea610c1244","modified":1626344126725},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"18edddb2ffb3f85a68e4367f81e06c461e07bc25","modified":1626344126691},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"6cf78a379bb656cc0abb4ab80fcae60152ce41ad","modified":1626344126692},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"f6f05f02d50f742c84ee5122016c0563a8bb2cf9","modified":1626344126692},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"a52f8cae599099231866298ed831fdf76c9b6717","modified":1626344126695},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"97974c231b4659b8aa5e9321c4d54db5c816d0db","modified":1626344126693},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"9af620eba5ccceea21a0e3bc69f6f1fa7637c2f3","modified":1626344126695},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"70b3eb9d36543ab92796ac163544e9cf51b7c1e6","modified":1626344126696},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"97dec98d0403097d66822f1c90b50b2890c84698","modified":1626344126697},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"0dfb97703a519d9438f64f9e41ab1dd37381f733","modified":1626344126698},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"93ba8172c0d2c37d738e6dbd44fcd5a2e23b92f3","modified":1626344126700},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"2c24829d95c742eb9e8316ebf2fbe9f2c168b59a","modified":1626344126700},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"57b9a179675f1536e017cba457b6ac575e397c4f","modified":1626344126698},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"66fc406796b6efe6cea76550573b7a632112406a","modified":1626344126701},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"09dda2667628d1f91b2e37d8fc6df1413f961b64","modified":1626344126702},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5cc9e7394c927065c688cba5edd6e0a27587f1d8","modified":1626344126703},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"fcd64c23d17775b3635325f6758b648d932e79b5","modified":1626344126704},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"b266d2ce5e2b117be01537889e839a69004dc0bb","modified":1626344126703},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"b87f4a06c0db893df4f756f24be182e1a4751f24","modified":1626344126706},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"d83102771df652769e51ddfd041cf5f4ca1a041d","modified":1626344126707},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"8ed7a9d5dfac592de703421b543978095129aa5b","modified":1626344126708},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"bad99f4cccb93b3cefe990a2c85124e60698d32e","modified":1626344126708},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1f6b0d3ab227697ca115e57fd61122ea7950e19d","modified":1626344126709},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"4079e616fbf36112dec0674c1e0713d1d9769068","modified":1626344126729},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"80488259271bcfe38031f4c2e902463daba9336b","modified":1626344126731},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"ceacfa6218f6084c71a230b086e5d2708d29927e","modified":1626344126735},{"_id":"themes/next/source/css/_common/scaffolding/highlight/theme.styl","hash":"c911045b2ce9a66e38d9dd30c7ed078abbc10cbf","modified":1626344126732},{"_id":"themes/next/source/css/_common/scaffolding/highlight/diff.styl","hash":"83bd737f663a8461e66985af8ddbfc0a731fc939","modified":1626344126730},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"aca7bb220fc14ef2a8f96282d2a95a96a9238d46","modified":1626344126737},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"adaf0f580fccf4158169eeaf534a18005b39a760","modified":1626344126739},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"8b7aafb911850c73074cdb6cc87abe4ac8c12e99","modified":1626344126738},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"3256e39f281f06751a1c0145d9806a0e56d68170","modified":1626344126740},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"51d46fa3c7c6b691c61a2c2b0ac005c97cfbf72b","modified":1626344126741},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"03a5bcecc0b12231462ef6ffe432fa77ee71beff","modified":1626344126739},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1626344126784},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1626344126787},{"_id":"source/_posts/数据备份/backUp.png","hash":"7591cff1c6a13315edb921cec93ef64d8781ae75","modified":1626344126488},{"_id":"source/_posts/Postons/Potions(Hard_version).png","hash":"33ffe55a747ea25b14fcda469327c8213ee6716a","modified":1626344126472},{"_id":"public/About-me/index.html","hash":"c54c133ed9edcd3322693965aa79a78e8b134e01","modified":1628564774329},{"_id":"public/categories/index.html","hash":"5f5f1aa527554bab9b8d40934b4148ca756edc29","modified":1628564774329},{"_id":"public/tags/index.html","hash":"d118926c7377c8c87a00b8ff04d08e51590bddb3","modified":1628564774329},{"_id":"public/2021/03/22/IDEApush到github被拒绝的问题/index.html","hash":"feed19014ea2bdac7b7f5bb2e09985b3465a7e9f","modified":1628564774329},{"_id":"public/archives/page/2/index.html","hash":"700692c7b73c4f83640a03045a4f7203aa2eb64d","modified":1628564774329},{"_id":"public/archives/2021/page/2/index.html","hash":"b2d5be64ad5b0676e23e56fcb6330f9c6beaaf21","modified":1628564774329},{"_id":"public/archives/2021/03/index.html","hash":"5d09d87b420700e1bcc3fe27a66cdc90194ef160","modified":1628564774329},{"_id":"public/archives/2021/04/index.html","hash":"9d3f97672e0e7345e8c79ac7499051df3ee8801a","modified":1628564774329},{"_id":"public/archives/2021/06/index.html","hash":"e36d91442b05b8086f8444ba4c6af2d53a29e32e","modified":1628564774329},{"_id":"public/archives/2021/07/index.html","hash":"ff42f3419f847ec02a34894846f3430e280bdfbe","modified":1628564774329},{"_id":"public/categories/div1/index.html","hash":"0725400431130d43bb4d5ec4e0be795e7062fad3","modified":1628564774329},{"_id":"public/categories/Diary/index.html","hash":"5b017a80c771bb031cb6b4451f0225128e1134a8","modified":1628564774329},{"_id":"public/categories/算法/index.html","hash":"d16ad661e4b74e2f59d46abe2b31feea57050e3a","modified":1628564774329},{"_id":"public/categories/牛客/index.html","hash":"8cbcf3df1f9fa96b1baf6e9c9ade0e884596ee64","modified":1628564774329},{"_id":"public/categories/牛客/比赛/index.html","hash":"00d47f4f586bbbe9f356f21d817a6fd490c804ca","modified":1628564774329},{"_id":"public/page/2/index.html","hash":"f74b7a6e2632054f4756f29eca3fe14890fc6464","modified":1628564774329},{"_id":"public/tags/暴力/index.html","hash":"7cd9cbbed16d30416ac49fa73070db807746fbb5","modified":1628564774329},{"_id":"public/tags/几何/index.html","hash":"2e0246760bd4812d4ebe9fffff52247ab6541ab1","modified":1628564774329},{"_id":"public/tags/限定长度最大子段和/index.html","hash":"06287e1f15fc882d4f30520a5e60afbcf99a4d17","modified":1628564774329},{"_id":"public/tags/思维/index.html","hash":"dadf624eacba89af6005f76f9b879341e54dafc6","modified":1628564774329},{"_id":"public/tags/二分答案/index.html","hash":"ac75ab70dbf5558b7299e875cb6c79ac99cb57b8","modified":1628564774329},{"_id":"public/tags/JAVA/index.html","hash":"7890b3b083d64c2d0a2840c3e334830bdc2eea35","modified":1628564774329},{"_id":"public/tags/反悔/index.html","hash":"6ca13af9b1cc6133d5f4018ed4036938e106c115","modified":1628564774329},{"_id":"public/tags/贪心/index.html","hash":"817c06761a589d4225392910ba0628ffd206cfb7","modified":1628564774329},{"_id":"public/tags/优先队列/index.html","hash":"d21272a0287b091bf6e0de6c9e0f0c937f087cfa","modified":1628564774329},{"_id":"public/tags/SptingBoot/index.html","hash":"7816f9b7a2893856e9b69c5dc1df8b7931be01c5","modified":1628564774329},{"_id":"public/tags/数据库/index.html","hash":"77c37281aaa0e7c3d620e03dc528974aeae2c0dd","modified":1628564774329},{"_id":"public/tags/分治法/index.html","hash":"c1bf0f5ae68452b41f8483eb4770aca0e8028906","modified":1628564774329},{"_id":"public/tags/贪心-反悔-优先队列/index.html","hash":"025ea2b6d294ba744eacf5bc0e0d170b5850cdf9","modified":1628564774329},{"_id":"public/tags/动态规划/index.html","hash":"4b0add6b7c507e8ea51b7a858ad98633a50aee81","modified":1628564774329},{"_id":"public/tags/数论/index.html","hash":"38ebf538d7fd794baf3b7ad222adfeed44c518ce","modified":1628564774329},{"_id":"public/tags/组合数/index.html","hash":"5b2e192c9d30ea3f688e914a47ac8c1b7f2d1c55","modified":1628564774329},{"_id":"public/tags/逆元/index.html","hash":"46e1d34ff825f959a715b383891cf547aa6ac2f6","modified":1628564774329},{"_id":"public/tags/费马里小定理/index.html","hash":"572939daac9ead421770e3787ee1e5c13f567f5a","modified":1628564774329},{"_id":"public/2021/07/16/EducationalCodeforcesRound111/index.html","hash":"f1b419968fa98780e7bcfc5bc67593cc38040bb8","modified":1628564774329},{"_id":"public/2021/07/15/牛客欢乐赛8E/index.html","hash":"0a52fd49ebd3dd8d026b4f37c98b7ac3a088ba98","modified":1628564774329},{"_id":"public/2021/06/25/USST题解报告/index.html","hash":"cee5b8af071c7ad1e967decad1295c7f2683c29b","modified":1628564774329},{"_id":"public/2021/06/13/MaxMedian/index.html","hash":"d2d895482eee4a4e6e61f8db85502791cfd65f42","modified":1628564774329},{"_id":"public/2021/06/13/BestCowFences/index.html","hash":"cd2a4ab672c045b7476530000aec424c423f3370","modified":1628564774329},{"_id":"public/2021/06/11/数据备份/index.html","hash":"985185170d1126353b0d86f3db7848eb89c62950","modified":1628564774329},{"_id":"public/2021/06/09/Postons/index.html","hash":"c9f86c63ecba943cd4c6a85759437126ced50315","modified":1628564774329},{"_id":"public/2021/04/10/在O-logn-的复杂度下两数组的混合中位数/index.html","hash":"5f932a6ea7cff2467ac3e818f6ec6e72a84e8f09","modified":1628564774329},{"_id":"public/2021/04/18/关于对floyd算法的质疑/index.html","hash":"af0873da3410e049bfc9e1b178d00639d5104515","modified":1628564774329},{"_id":"public/2021/03/30/sptingboot集成mybatis/index.html","hash":"82457561b31677e8068365fba2a04522ee516be3","modified":1628564774329},{"_id":"public/archives/index.html","hash":"ae406e16202d71728324098969daafca70d1e3bb","modified":1628564774329},{"_id":"public/archives/2021/index.html","hash":"fbbf90e985c5e82fd4abf251f229014fe2dee37b","modified":1628564774329},{"_id":"public/index.html","hash":"162e7ef4ad472190efe81814462875a856910c21","modified":1628564774329},{"_id":"public/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1626486963241},{"_id":"public/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1626486963241},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1626486963241},{"_id":"public/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1626486963241},{"_id":"public/images/avatar.gif","hash":"1dd8c28b25e25a9a70841c6309440bfe08fb41f8","modified":1626486963241},{"_id":"public/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1626486963241},{"_id":"public/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1626486963241},{"_id":"public/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1626486963241},{"_id":"public/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1626486963241},{"_id":"public/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1626486963241},{"_id":"public/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1626486963241},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1626486963241},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1626486963241},{"_id":"public/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1626486963241},{"_id":"public/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1626486963241},{"_id":"public/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1626486963241},{"_id":"public/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1626486963241},{"_id":"public/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1626486963241},{"_id":"public/js/utils.js","hash":"730cca7f164eaf258661a61ff3f769851ff1e5da","modified":1626486963241},{"_id":"public/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1626486963241},{"_id":"public/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1626486963241},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1626486963241},{"_id":"public/css/main.css","hash":"eaf5d65a1d6ea94bf620b0eb565248cf934165e1","modified":1626486963241},{"_id":"public/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1626486963241},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1626486963241},{"_id":"public/categories/index.pdf","hash":"a258a88a5bcf8099859ba5263f7c9d94eea6eca8","modified":1626486963241},{"_id":"public/2021/07/16/EducationalCodeforcesRound111/CF111_1.png","hash":"4cdf8bee3b1e8efe00f010530ee18d865cc96acf","modified":1626486963241},{"_id":"public/2021/07/16/EducationalCodeforcesRound111/CF111_3.png","hash":"d894693df812aeb762629fdd71bd29797019ea05","modified":1626486963241},{"_id":"public/2021/07/16/EducationalCodeforcesRound111/CF111_2.png","hash":"535fafa952e6a48b063439973008e8adcea15c4e","modified":1626486963241},{"_id":"public/2021/07/15/牛客欢乐赛8E/1.png","hash":"e3a161095c32dacdeb812bbeea83bcd51d95b273","modified":1626486963241},{"_id":"public/2021/07/15/牛客欢乐赛8E/2.png","hash":"50612dcc44432a03c20d45ed8d891ae743db7eab","modified":1626486963241},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1626486963241},{"_id":"public/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1626486963241},{"_id":"public/2021/07/16/EducationalCodeforcesRound111/CF111_0.png","hash":"8dc7fd3fb14f0eff6bce2c5a202abbacffc3847d","modified":1626486963241},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1626486963241},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1626486963241},{"_id":"public/2021/06/13/BestCowFences/BestCowFence.png","hash":"cba042a07e1eed0b0ddd78e61fe006647bed5323","modified":1626486963241},{"_id":"public/2021/06/13/MaxMedian/MaxMedian.png","hash":"a51a9bbdc1ba4026d2073b0c4abe23ffdafb2f55","modified":1626486963241},{"_id":"public/2021/06/11/数据备份/backUp.png","hash":"7591cff1c6a13315edb921cec93ef64d8781ae75","modified":1626486963241},{"_id":"public/2021/06/09/Postons/Potions(Hard_version).png","hash":"33ffe55a747ea25b14fcda469327c8213ee6716a","modified":1626486963241},{"_id":"source/_posts/数据离散化.md","hash":"d33d48bd6971b1b5b1fa1c5abd3cb6466d87e1f3","modified":1628564749326},{"_id":"source/_posts/第一周周赛.md","hash":"69e3b5627f439a318da3207af3d37f7a428760fd","modified":1626855939327},{"_id":"public/archives/2021/08/index.html","hash":"2d7c0d32a43f3d5270fe3d0e42e03c0015c365fc","modified":1628564774329},{"_id":"public/2021/08/10/数据离散化/index.html","hash":"7e4682e50ea1aa90d55f334fb416546ff206be57","modified":1628564774329},{"_id":"public/2021/07/19/第一周周赛/index.html","hash":"4996a6c08cb0374cda14e4791c4187354218ef5d","modified":1628564774329},{"_id":"public/tags/离散化/index.html","hash":"78ce9358e316f353895a15b9f29a73e037a9525d","modified":1628564774329}],"Category":[{"name":"div1","_id":"ckr74cdss000740tk6a2tgh0r"},{"name":"Diary","_id":"ckr74cdsv000c40tk6skq12cg"},{"name":"-算法","_id":"ckr74cdsz000m40tkcvpxh87g"},{"name":"-div1","_id":"ckr74cdt9001h40tkb3bphp6y"},{"name":"牛客","_id":"ckr74cdtc001o40tk9farfti9"},{"name":"比赛","parent":"ckr74cdtc001o40tk9farfti9","_id":"ckr74cdtd001r40tk94jwfkh8"}],"Data":[],"Page":[{"title":"分类","date":"2021-06-25T14:12:37.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2021-06-25 22:12:37\ntype: \"categories\"\n---\n","updated":"2021-07-15T10:15:26.494Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ckr74cdsg000040tk17frhkie","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"About me","date":"2021-03-21T15:19:57.000Z","_content":"","source":"About-me/index.md","raw":"---\ntitle: About me\ndate: 2021-03-21 23:19:57\n---\n","updated":"2021-07-15T10:15:26.438Z","path":"About-me/index.html","comments":1,"layout":"page","_id":"ckr74cdsl000240tkdv279uqq","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","date":"2021-06-25T13:13:56.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2021-06-25 21:13:56\ntype: \"tags\"\n---\n","updated":"2021-07-15T10:15:26.496Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ckr74cdsr000540tk91qk2n8o","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"EducationalCodeforcesRound111","date":"2021-07-16T14:26:19.000Z","catagories":["CF"],"_content":"# Educational Codeforces Round 111 \n\n## C题 [Manhattan Subarrays](https://codeforces.com/contest/1550/problem/C)  \n\n### 题目大意\n题目大概意思是，定义两个点$a(x_1,y_1)$,$b(x_2,y_2)$的距离$d=|x_1-x_2|+|y_1-y_2|$  。对于三个点p，q，r如果$d(p,r)=d(p,q)+d(q,r)$,则认为这三个点是一个“坏三连”。问给定一个数组$a_1,a_2...a_n$每个元素$a_i$与i构成一个点$(a_i,i)$，问有多少个任意三个点都不能构成“坏三连”的连续子串(如果连续子串只有一个或者两个元素，则也为不能构成“坏三连”的子串)\n#### 分析\n\n分析题目可以发现，连续子串每个元素$a_i$对应的点横坐标不确定，但是纵坐标是严格递增的。\n* 考察可以构成“坏三连”的三个点，由题意可知纵坐标为中间那个点一定在另外两个点中间(包含边边)，如图。、\n   [![WQRUU0.png](https://z3.ax1x.com/2021/07/17/WQRUU0.png)](https://imgtu.com/i/WQRUU0)\n* 先考察高度连续两个点$p(a_i,i)$,$q(a_{i+1},i+1)$\n    1. 如果$a_{i+1}>a_i$，则后面的点都不能在q右边。图片红色的区域不可再落点第三个点。\n    [![WQRNEq.png](https://z3.ax1x.com/2021/07/17/WQRNEq.png)](https://imgtu.com/i/WQRNEq)\n    2. $a_{i+1}<a_i$，也类似。\n    3. 如果$a_{i+1}=a_i$，则无论下一个点放在哪里，都是“坏三连”，不能放第三个点。\n* 考察三个点$p(a_i,i)$,$q(a_{i+1},i+1)$,$r(a_{i+2},i+2)$，只分析$a_{i+1}>a_i$，并且第三个点以落的情况，$a_{i+1}<a_i$情况类似。\n   1. 如果$a_{i+2}<a_i$，则r的左上角也不能再放置点\n   ![Ieqjaf.png](https://s3.jpg.cm/2021/07/17/Ieqjaf.png)\n   2. 如果$a_i<a_{i+2}<a_i+1$,则受到p和q的同时影响，r左上角和右上角都无法再放置点，则不可再放置下一个点\n   3. 如果$a_{i+2}=a_i$，则不能无法再放置下一个点，r一定会在下一个点到p之间。\n*  考察能放下四个点，则不可能再放下第五个点，则最多四个点。只有在放三个点的第一条基础上，才能放置四个点。\n    ![IeqhvL.png](https://s3.jpg.cm/2021/07/17/IeqhvL.png)\n下面暴力模拟一遍过的，但是有点笨。其实有更好的方法\n\n```c++\n#include<iostream>\nusing namespace std;\nint t; // 测试用例数\nint n; // 数组长度\nlong long a[200002];\nlong long ans;\nint main(){\n    //freopen(\"test/C.txt\",\"r\",stdin);\n    cin>>t;\n    while(t--){\n       ans=0;\n       cin>>n;\n       for(int i = 0;i<n;++i){\n           cin>>a[i];\n       }\n       int right;   // 坐标右下线\n       int left;    // 坐标左上限\n       for(int i = 0;i<n-2;++i){\n           right=0;\n           left=0;\n           // 先判断第二个点\n           if(a[i+1]>a[i]){\n               right=a[i+1];\n           }else if(a[i+1]<a[i]){\n               left=a[i+1];\n           }else{\n               continue;\n           }\n           \n           // 判断第三个点\n           if(right!=0){   // 如果第一个点偏右\n              if(a[i+2]>=right){\n                  continue;\n              }else if(a[i+2]<a[i]){\n                  left=a[i+2];\n                  ans++;\n              }else{\n                    ans++;\n                  continue;\n              }\n           }else{\n               if(a[i+2]<=left){\n                  continue;\n              }else if(a[i+2]>a[i]){\n                  right=a[i+2];\n                  ans++;\n              }else{\n                    ans++;\n                  continue;\n              }\n           }\n\n           // 判断第四个点\n           if(i!=n-3&&a[i+3]<right&&a[i+3]>left){\n               ans++;\n           }\n       }\n\n       ans+=n;   // 单独也是答案\n       ans+=n-1; // 每两个也是答案\n       cout<<ans<<endl;\n       \n    }\n}\n```","source":"_posts/EducationalCodeforcesRound111.md","raw":"---\ntitle: EducationalCodeforcesRound111\ndate: 2021-07-16 22:26:19\ncatagories:\n  - CF\ntags:\n  - 暴力\n  - 几何\n---\n# Educational Codeforces Round 111 \n\n## C题 [Manhattan Subarrays](https://codeforces.com/contest/1550/problem/C)  \n\n### 题目大意\n题目大概意思是，定义两个点$a(x_1,y_1)$,$b(x_2,y_2)$的距离$d=|x_1-x_2|+|y_1-y_2|$  。对于三个点p，q，r如果$d(p,r)=d(p,q)+d(q,r)$,则认为这三个点是一个“坏三连”。问给定一个数组$a_1,a_2...a_n$每个元素$a_i$与i构成一个点$(a_i,i)$，问有多少个任意三个点都不能构成“坏三连”的连续子串(如果连续子串只有一个或者两个元素，则也为不能构成“坏三连”的子串)\n#### 分析\n\n分析题目可以发现，连续子串每个元素$a_i$对应的点横坐标不确定，但是纵坐标是严格递增的。\n* 考察可以构成“坏三连”的三个点，由题意可知纵坐标为中间那个点一定在另外两个点中间(包含边边)，如图。、\n   [![WQRUU0.png](https://z3.ax1x.com/2021/07/17/WQRUU0.png)](https://imgtu.com/i/WQRUU0)\n* 先考察高度连续两个点$p(a_i,i)$,$q(a_{i+1},i+1)$\n    1. 如果$a_{i+1}>a_i$，则后面的点都不能在q右边。图片红色的区域不可再落点第三个点。\n    [![WQRNEq.png](https://z3.ax1x.com/2021/07/17/WQRNEq.png)](https://imgtu.com/i/WQRNEq)\n    2. $a_{i+1}<a_i$，也类似。\n    3. 如果$a_{i+1}=a_i$，则无论下一个点放在哪里，都是“坏三连”，不能放第三个点。\n* 考察三个点$p(a_i,i)$,$q(a_{i+1},i+1)$,$r(a_{i+2},i+2)$，只分析$a_{i+1}>a_i$，并且第三个点以落的情况，$a_{i+1}<a_i$情况类似。\n   1. 如果$a_{i+2}<a_i$，则r的左上角也不能再放置点\n   ![Ieqjaf.png](https://s3.jpg.cm/2021/07/17/Ieqjaf.png)\n   2. 如果$a_i<a_{i+2}<a_i+1$,则受到p和q的同时影响，r左上角和右上角都无法再放置点，则不可再放置下一个点\n   3. 如果$a_{i+2}=a_i$，则不能无法再放置下一个点，r一定会在下一个点到p之间。\n*  考察能放下四个点，则不可能再放下第五个点，则最多四个点。只有在放三个点的第一条基础上，才能放置四个点。\n    ![IeqhvL.png](https://s3.jpg.cm/2021/07/17/IeqhvL.png)\n下面暴力模拟一遍过的，但是有点笨。其实有更好的方法\n\n```c++\n#include<iostream>\nusing namespace std;\nint t; // 测试用例数\nint n; // 数组长度\nlong long a[200002];\nlong long ans;\nint main(){\n    //freopen(\"test/C.txt\",\"r\",stdin);\n    cin>>t;\n    while(t--){\n       ans=0;\n       cin>>n;\n       for(int i = 0;i<n;++i){\n           cin>>a[i];\n       }\n       int right;   // 坐标右下线\n       int left;    // 坐标左上限\n       for(int i = 0;i<n-2;++i){\n           right=0;\n           left=0;\n           // 先判断第二个点\n           if(a[i+1]>a[i]){\n               right=a[i+1];\n           }else if(a[i+1]<a[i]){\n               left=a[i+1];\n           }else{\n               continue;\n           }\n           \n           // 判断第三个点\n           if(right!=0){   // 如果第一个点偏右\n              if(a[i+2]>=right){\n                  continue;\n              }else if(a[i+2]<a[i]){\n                  left=a[i+2];\n                  ans++;\n              }else{\n                    ans++;\n                  continue;\n              }\n           }else{\n               if(a[i+2]<=left){\n                  continue;\n              }else if(a[i+2]>a[i]){\n                  right=a[i+2];\n                  ans++;\n              }else{\n                    ans++;\n                  continue;\n              }\n           }\n\n           // 判断第四个点\n           if(i!=n-3&&a[i+3]<right&&a[i+3]>left){\n               ans++;\n           }\n       }\n\n       ans+=n;   // 单独也是答案\n       ans+=n-1; // 每两个也是答案\n       cout<<ans<<endl;\n       \n    }\n}\n```","slug":"EducationalCodeforcesRound111","published":1,"updated":"2021-07-17T01:53:41.298Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckr74cdsi000140tkchu7edu5","content":"<h1 id=\"Educational-Codeforces-Round-111\"><a href=\"#Educational-Codeforces-Round-111\" class=\"headerlink\" title=\"Educational Codeforces Round 111\"></a>Educational Codeforces Round 111</h1><h2 id=\"C题-Manhattan-Subarrays\"><a href=\"#C题-Manhattan-Subarrays\" class=\"headerlink\" title=\"C题 Manhattan Subarrays\"></a>C题 <a href=\"https://codeforces.com/contest/1550/problem/C\">Manhattan Subarrays</a></h2><h3 id=\"题目大意\"><a href=\"#题目大意\" class=\"headerlink\" title=\"题目大意\"></a>题目大意</h3><p>题目大概意思是，定义两个点$a(x_1,y_1)$,$b(x_2,y_2)$的距离$d=|x_1-x_2|+|y_1-y_2|$  。对于三个点p，q，r如果$d(p,r)=d(p,q)+d(q,r)$,则认为这三个点是一个“坏三连”。问给定一个数组$a_1,a_2…a_n$每个元素$a_i$与i构成一个点$(a_i,i)$，问有多少个任意三个点都不能构成“坏三连”的连续子串(如果连续子串只有一个或者两个元素，则也为不能构成“坏三连”的子串)</p>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><p>分析题目可以发现，连续子串每个元素$a_i$对应的点横坐标不确定，但是纵坐标是严格递增的。</p>\n<ul>\n<li>考察可以构成“坏三连”的三个点，由题意可知纵坐标为中间那个点一定在另外两个点中间(包含边边)，如图。、<br> <a href=\"https://imgtu.com/i/WQRUU0\"><img src=\"https://z3.ax1x.com/2021/07/17/WQRUU0.png\" alt=\"WQRUU0.png\"></a></li>\n<li>先考察高度连续两个点$p(a_i,i)$,$q(a_{i+1},i+1)$<ol>\n<li>如果$a_{i+1}&gt;a_i$，则后面的点都不能在q右边。图片红色的区域不可再落点第三个点。<br><a href=\"https://imgtu.com/i/WQRNEq\"><img src=\"https://z3.ax1x.com/2021/07/17/WQRNEq.png\" alt=\"WQRNEq.png\"></a></li>\n<li>$a_{i+1}&lt;a_i$，也类似。</li>\n<li>如果$a_{i+1}=a_i$，则无论下一个点放在哪里，都是“坏三连”，不能放第三个点。</li>\n</ol>\n</li>\n<li>考察三个点$p(a_i,i)$,$q(a_{i+1},i+1)$,$r(a_{i+2},i+2)$，只分析$a_{i+1}&gt;a_i$，并且第三个点以落的情况，$a_{i+1}&lt;a_i$情况类似。<ol>\n<li>如果$a_{i+2}&lt;a_i$，则r的左上角也不能再放置点<br><img src=\"https://s3.jpg.cm/2021/07/17/Ieqjaf.png\" alt=\"Ieqjaf.png\"></li>\n<li>如果$a_i&lt;a_{i+2}&lt;a_i+1$,则受到p和q的同时影响，r左上角和右上角都无法再放置点，则不可再放置下一个点</li>\n<li>如果$a_{i+2}=a_i$，则不能无法再放置下一个点，r一定会在下一个点到p之间。</li>\n</ol>\n</li>\n<li>考察能放下四个点，则不可能再放下第五个点，则最多四个点。只有在放三个点的第一条基础上，才能放置四个点。<br> <img src=\"https://s3.jpg.cm/2021/07/17/IeqhvL.png\" alt=\"IeqhvL.png\"><br>下面暴力模拟一遍过的，但是有点笨。其实有更好的方法</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">int</span> t; <span class=\"comment\">// 测试用例数</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> n; <span class=\"comment\">// 数组长度</span></span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> a[<span class=\"number\">200002</span>];</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ans;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//freopen(&quot;test/C.txt&quot;,&quot;r&quot;,stdin);</span></span><br><span class=\"line\">    cin&gt;&gt;t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">       ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">       cin&gt;&gt;n;</span><br><span class=\"line\">       <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">           cin&gt;&gt;a[i];</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">int</span> right;   <span class=\"comment\">// 坐标右下线</span></span><br><span class=\"line\">       <span class=\"keyword\">int</span> left;    <span class=\"comment\">// 坐标左上限</span></span><br><span class=\"line\">       <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;n<span class=\"number\">-2</span>;++i)&#123;</span><br><span class=\"line\">           right=<span class=\"number\">0</span>;</span><br><span class=\"line\">           left=<span class=\"number\">0</span>;</span><br><span class=\"line\">           <span class=\"comment\">// 先判断第二个点</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span>(a[i+<span class=\"number\">1</span>]&gt;a[i])&#123;</span><br><span class=\"line\">               right=a[i+<span class=\"number\">1</span>];</span><br><span class=\"line\">           &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(a[i+<span class=\"number\">1</span>]&lt;a[i])&#123;</span><br><span class=\"line\">               left=a[i+<span class=\"number\">1</span>];</span><br><span class=\"line\">           &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">               <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           </span><br><span class=\"line\">           <span class=\"comment\">// 判断第三个点</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span>(right!=<span class=\"number\">0</span>)&#123;   <span class=\"comment\">// 如果第一个点偏右</span></span><br><span class=\"line\">              <span class=\"keyword\">if</span>(a[i+<span class=\"number\">2</span>]&gt;=right)&#123;</span><br><span class=\"line\">                  <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">              &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(a[i+<span class=\"number\">2</span>]&lt;a[i])&#123;</span><br><span class=\"line\">                  left=a[i+<span class=\"number\">2</span>];</span><br><span class=\"line\">                  ans++;</span><br><span class=\"line\">              &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    ans++;</span><br><span class=\"line\">                  <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">           &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">               <span class=\"keyword\">if</span>(a[i+<span class=\"number\">2</span>]&lt;=left)&#123;</span><br><span class=\"line\">                  <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">              &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(a[i+<span class=\"number\">2</span>]&gt;a[i])&#123;</span><br><span class=\"line\">                  right=a[i+<span class=\"number\">2</span>];</span><br><span class=\"line\">                  ans++;</span><br><span class=\"line\">              &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    ans++;</span><br><span class=\"line\">                  <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"comment\">// 判断第四个点</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span>(i!=n<span class=\"number\">-3</span>&amp;&amp;a[i+<span class=\"number\">3</span>]&lt;right&amp;&amp;a[i+<span class=\"number\">3</span>]&gt;left)&#123;</span><br><span class=\"line\">               ans++;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       ans+=n;   <span class=\"comment\">// 单独也是答案</span></span><br><span class=\"line\">       ans+=n<span class=\"number\">-1</span>; <span class=\"comment\">// 每两个也是答案</span></span><br><span class=\"line\">       cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">       </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Educational-Codeforces-Round-111\"><a href=\"#Educational-Codeforces-Round-111\" class=\"headerlink\" title=\"Educational Codeforces Round 111\"></a>Educational Codeforces Round 111</h1><h2 id=\"C题-Manhattan-Subarrays\"><a href=\"#C题-Manhattan-Subarrays\" class=\"headerlink\" title=\"C题 Manhattan Subarrays\"></a>C题 <a href=\"https://codeforces.com/contest/1550/problem/C\">Manhattan Subarrays</a></h2><h3 id=\"题目大意\"><a href=\"#题目大意\" class=\"headerlink\" title=\"题目大意\"></a>题目大意</h3><p>题目大概意思是，定义两个点$a(x_1,y_1)$,$b(x_2,y_2)$的距离$d=|x_1-x_2|+|y_1-y_2|$  。对于三个点p，q，r如果$d(p,r)=d(p,q)+d(q,r)$,则认为这三个点是一个“坏三连”。问给定一个数组$a_1,a_2…a_n$每个元素$a_i$与i构成一个点$(a_i,i)$，问有多少个任意三个点都不能构成“坏三连”的连续子串(如果连续子串只有一个或者两个元素，则也为不能构成“坏三连”的子串)</p>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><p>分析题目可以发现，连续子串每个元素$a_i$对应的点横坐标不确定，但是纵坐标是严格递增的。</p>\n<ul>\n<li>考察可以构成“坏三连”的三个点，由题意可知纵坐标为中间那个点一定在另外两个点中间(包含边边)，如图。、<br> <a href=\"https://imgtu.com/i/WQRUU0\"><img src=\"https://z3.ax1x.com/2021/07/17/WQRUU0.png\" alt=\"WQRUU0.png\"></a></li>\n<li>先考察高度连续两个点$p(a_i,i)$,$q(a_{i+1},i+1)$<ol>\n<li>如果$a_{i+1}&gt;a_i$，则后面的点都不能在q右边。图片红色的区域不可再落点第三个点。<br><a href=\"https://imgtu.com/i/WQRNEq\"><img src=\"https://z3.ax1x.com/2021/07/17/WQRNEq.png\" alt=\"WQRNEq.png\"></a></li>\n<li>$a_{i+1}&lt;a_i$，也类似。</li>\n<li>如果$a_{i+1}=a_i$，则无论下一个点放在哪里，都是“坏三连”，不能放第三个点。</li>\n</ol>\n</li>\n<li>考察三个点$p(a_i,i)$,$q(a_{i+1},i+1)$,$r(a_{i+2},i+2)$，只分析$a_{i+1}&gt;a_i$，并且第三个点以落的情况，$a_{i+1}&lt;a_i$情况类似。<ol>\n<li>如果$a_{i+2}&lt;a_i$，则r的左上角也不能再放置点<br><img src=\"https://s3.jpg.cm/2021/07/17/Ieqjaf.png\" alt=\"Ieqjaf.png\"></li>\n<li>如果$a_i&lt;a_{i+2}&lt;a_i+1$,则受到p和q的同时影响，r左上角和右上角都无法再放置点，则不可再放置下一个点</li>\n<li>如果$a_{i+2}=a_i$，则不能无法再放置下一个点，r一定会在下一个点到p之间。</li>\n</ol>\n</li>\n<li>考察能放下四个点，则不可能再放下第五个点，则最多四个点。只有在放三个点的第一条基础上，才能放置四个点。<br> <img src=\"https://s3.jpg.cm/2021/07/17/IeqhvL.png\" alt=\"IeqhvL.png\"><br>下面暴力模拟一遍过的，但是有点笨。其实有更好的方法</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">int</span> t; <span class=\"comment\">// 测试用例数</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> n; <span class=\"comment\">// 数组长度</span></span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> a[<span class=\"number\">200002</span>];</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ans;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//freopen(&quot;test/C.txt&quot;,&quot;r&quot;,stdin);</span></span><br><span class=\"line\">    cin&gt;&gt;t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">       ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">       cin&gt;&gt;n;</span><br><span class=\"line\">       <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">           cin&gt;&gt;a[i];</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">int</span> right;   <span class=\"comment\">// 坐标右下线</span></span><br><span class=\"line\">       <span class=\"keyword\">int</span> left;    <span class=\"comment\">// 坐标左上限</span></span><br><span class=\"line\">       <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;n<span class=\"number\">-2</span>;++i)&#123;</span><br><span class=\"line\">           right=<span class=\"number\">0</span>;</span><br><span class=\"line\">           left=<span class=\"number\">0</span>;</span><br><span class=\"line\">           <span class=\"comment\">// 先判断第二个点</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span>(a[i+<span class=\"number\">1</span>]&gt;a[i])&#123;</span><br><span class=\"line\">               right=a[i+<span class=\"number\">1</span>];</span><br><span class=\"line\">           &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(a[i+<span class=\"number\">1</span>]&lt;a[i])&#123;</span><br><span class=\"line\">               left=a[i+<span class=\"number\">1</span>];</span><br><span class=\"line\">           &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">               <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           </span><br><span class=\"line\">           <span class=\"comment\">// 判断第三个点</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span>(right!=<span class=\"number\">0</span>)&#123;   <span class=\"comment\">// 如果第一个点偏右</span></span><br><span class=\"line\">              <span class=\"keyword\">if</span>(a[i+<span class=\"number\">2</span>]&gt;=right)&#123;</span><br><span class=\"line\">                  <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">              &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(a[i+<span class=\"number\">2</span>]&lt;a[i])&#123;</span><br><span class=\"line\">                  left=a[i+<span class=\"number\">2</span>];</span><br><span class=\"line\">                  ans++;</span><br><span class=\"line\">              &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    ans++;</span><br><span class=\"line\">                  <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">           &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">               <span class=\"keyword\">if</span>(a[i+<span class=\"number\">2</span>]&lt;=left)&#123;</span><br><span class=\"line\">                  <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">              &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(a[i+<span class=\"number\">2</span>]&gt;a[i])&#123;</span><br><span class=\"line\">                  right=a[i+<span class=\"number\">2</span>];</span><br><span class=\"line\">                  ans++;</span><br><span class=\"line\">              &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    ans++;</span><br><span class=\"line\">                  <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"comment\">// 判断第四个点</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span>(i!=n<span class=\"number\">-3</span>&amp;&amp;a[i+<span class=\"number\">3</span>]&lt;right&amp;&amp;a[i+<span class=\"number\">3</span>]&gt;left)&#123;</span><br><span class=\"line\">               ans++;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       ans+=n;   <span class=\"comment\">// 单独也是答案</span></span><br><span class=\"line\">       ans+=n<span class=\"number\">-1</span>; <span class=\"comment\">// 每两个也是答案</span></span><br><span class=\"line\">       cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">       </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"BestCowFences","date":"2021-06-12T16:35:27.000Z","_content":"# 题目\n{% asset_img BestCowFence.png %}\n### 题目简介\n题目大概就是围起连续不小于f的数，使他们的平均值最大，求出这个最大值。\n### 分析\n 如果是求连续子序列最大和，那么问题就很简单。但是他这里要求的是最大平均数，由于最大平均数不仅和连续子序列的和有关，还和连续子序列的长度有关。即average=sum/length。则事情就变得不那么简单了。\n\n##### 二分答案\n这里用到二分答案策略，所谓的二分答案，就是假设所求的值刚开始在一个区间段[l,r]，然后选取这个区间段的中间值mid作为答案，如果算出这个中间值取大了，就从左半区间[l,mid],否则从[mid,r]找最后直到区间缩到无穷小，则此时区间的逼近值即为正确答案。这个其实在数值分析里面学过。\n\n##### 变向思维\n我们要求连续区间的最大平均值，很困难，因为这个平均值不仅和连续区间和sum有关，还与区间长度length有关，这就需要我们将问题进行转换。\n\n假设最大平均值为ans，则对于平均值最大的那段区间[i,j]有(a<sub>i</sub>+a<sub>i+1</sub>+...+a<sub>j</sub>)/length=ans。即(a<sub>i</sub>+a<sub>i+1</sub>+...+a<sub>j</sub>)-ans*length=0。\n\n- 如果有大于ans的区间段平均值，则对于最大的区间段[p,q],有(a<sub>p</sub>+a<sub>p+1</sub>+...+a<sub>q</sub>)/length>ans，即(a<sub>p</sub>+a<sub>p+1</sub>+...+a<sub>q</sub>)-ans*length>0。那么我们的ans就偏小了。这就是一个二分的判断偏小依据。\n\n- 如果全部的区间段平均值都小于ans，则对于最大的区间段，有(a<sub>p</sub>+a<sub>p+1</sub>+...+a<sub>q</sub>)/length<ans,即(a<sub>p</sub>+a<sub>p+1</sub>+...+a<sub>q</sub>)-ans*length<0,则此时ans偏大了。得到一个二分偏大的判断。\n\n那么问题就从求连续子序列最大平均值，转换成了求(a<sub>i</sub>+a<sub>i+1</sub>+...+a<sub>j</sub>)-ans * length的值。我们将整个区间段[0,n-1]的值全部减去ans，那么我们在求连续子序列的和时，就相当于求a<sub>i</sub>+a<sub>i+1</sub>+...+a<sub>j</sub>-ans * lengths的值。则问题最终变成了一个连续子序列求和问题。\n\n##### 长度不小于f的最大连续子序列问题\n我们可以先求出[0,n]的前缀和sum[i] i=0,1,2...n。由于子序列的长度不能小于f，则以i结尾的连续子序列dp[i] (i>=f)，前f个数一定是要的。先让dp[i]=sum[i],则sum[i]-sum[i-k-1]这段肯定要留在dp[i]里面。所以只需要找到sum[0] ~ sum[i-k]中小于0的最小值sum[m]，然后令dp=sum[i]-sum[m]即为以i结尾的连续子序列的最大值（就是把前面连续的最自己没有正作用的子序列干掉）。则我们要维护从sum[0]~sum[i-k]的最小值，并且每次用dp[i]更新整个区间内连续子序列的最大值即可。\n```c++\nfor(int i=f;i<n;++i){\n           Min=min(Min,sum[i-f]);   \n           Max=max(Max,sum[i]-Min);   // sum[i]-Min是以i结尾的最大连续子段和，Max是之前求出的最大连续子段和\n       }\n```\n\n## 算法\n先假定二分区间为很大，然后二分假设答案mid，令原数组所有的数减去mid得到新数组。求新数组中长度不小于k的连续子序列的最大和，如果结果大于0，说明ans设小了，区间往右边分，否则区间往左边分。直到最后区间逼近一个数为止。\n## 代码\n\n```c++\n#include<iostream>\n#include<cmath>\nusing namespace std;\ndouble a[100002];\ndouble b[100002];\ndouble sum[100002]; // 记录第i个数之前的和\nint n;\nint f;\nint main(){\n    //freopen(\"test/div1A.txt\",\"r\",stdin);\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    double mid;       // 假设的答案 \n    cin>>n>>f;\n    for(int i=0;i<n;++i){\n        //scanf(\"%lf\",&a[i]);  // 用cin会套老鹅\n        cin>>a[i];\n    }\n    double l=-1e6;    // 答案区间的左边\n    double r=1e6;     // 答案区间的右边\n    while(r-l>1e-4){\n       mid = (l+r)/2;\n       // 先求出减去平均值后的数组\n       for(int i=0;i<n;++i){\n           b[i]=a[i]-mid;   \n       }\n       \n       sum[0]=b[0];\n       for(int i = 1;i<n;++i){\n            sum[i]=sum[i-1]+b[i];\n       }\n       double Min=0;     // 记录以j(0<=j<i-f)结尾大子段和的最小值，初始值应该为0，因为比0小的我们才不要\n                         // 如果这里初始化为一个很大的值，那么若sum[0]大于0，就会被认为是要被抛弃的，然而我们只需要抛弃小于0的\n       double Max=-1e9;      // 记录长度大于f的最大子段和\n       // 求限定长度为f的最大连续子段和\n       for(int i=f;i<n;++i){\n           Min=min(Min,sum[i-f]);   \n           Max=max(Max,sum[i]-Min);   // sum[i]-Min是以i结尾的最大连续子段和，Max是之前求出的最大连续子段和\n       }\n       Max=max(Max,sum[f-1]);   // 观察可知上面没有判断sum[f-1]的情况\n       if(Max>0){  // Max>0说明答案不够大\n         l=mid;\n       }else{      // 否则就是答案不够小\n         r=mid;\n       }\n\n    }\n    cout<<(int)(1000*r)<<endl;\n}\n```\n\n\n\n","source":"_posts/BestCowFences.md","raw":"---\ntitle: BestCowFences\ndate: 2021-06-13 00:35:27\ncategories:\n    - div1\ntags:\n    - 限定长度最大子段和\n    - 思维\n    - 二分答案\n---\n# 题目\n{% asset_img BestCowFence.png %}\n### 题目简介\n题目大概就是围起连续不小于f的数，使他们的平均值最大，求出这个最大值。\n### 分析\n 如果是求连续子序列最大和，那么问题就很简单。但是他这里要求的是最大平均数，由于最大平均数不仅和连续子序列的和有关，还和连续子序列的长度有关。即average=sum/length。则事情就变得不那么简单了。\n\n##### 二分答案\n这里用到二分答案策略，所谓的二分答案，就是假设所求的值刚开始在一个区间段[l,r]，然后选取这个区间段的中间值mid作为答案，如果算出这个中间值取大了，就从左半区间[l,mid],否则从[mid,r]找最后直到区间缩到无穷小，则此时区间的逼近值即为正确答案。这个其实在数值分析里面学过。\n\n##### 变向思维\n我们要求连续区间的最大平均值，很困难，因为这个平均值不仅和连续区间和sum有关，还与区间长度length有关，这就需要我们将问题进行转换。\n\n假设最大平均值为ans，则对于平均值最大的那段区间[i,j]有(a<sub>i</sub>+a<sub>i+1</sub>+...+a<sub>j</sub>)/length=ans。即(a<sub>i</sub>+a<sub>i+1</sub>+...+a<sub>j</sub>)-ans*length=0。\n\n- 如果有大于ans的区间段平均值，则对于最大的区间段[p,q],有(a<sub>p</sub>+a<sub>p+1</sub>+...+a<sub>q</sub>)/length>ans，即(a<sub>p</sub>+a<sub>p+1</sub>+...+a<sub>q</sub>)-ans*length>0。那么我们的ans就偏小了。这就是一个二分的判断偏小依据。\n\n- 如果全部的区间段平均值都小于ans，则对于最大的区间段，有(a<sub>p</sub>+a<sub>p+1</sub>+...+a<sub>q</sub>)/length<ans,即(a<sub>p</sub>+a<sub>p+1</sub>+...+a<sub>q</sub>)-ans*length<0,则此时ans偏大了。得到一个二分偏大的判断。\n\n那么问题就从求连续子序列最大平均值，转换成了求(a<sub>i</sub>+a<sub>i+1</sub>+...+a<sub>j</sub>)-ans * length的值。我们将整个区间段[0,n-1]的值全部减去ans，那么我们在求连续子序列的和时，就相当于求a<sub>i</sub>+a<sub>i+1</sub>+...+a<sub>j</sub>-ans * lengths的值。则问题最终变成了一个连续子序列求和问题。\n\n##### 长度不小于f的最大连续子序列问题\n我们可以先求出[0,n]的前缀和sum[i] i=0,1,2...n。由于子序列的长度不能小于f，则以i结尾的连续子序列dp[i] (i>=f)，前f个数一定是要的。先让dp[i]=sum[i],则sum[i]-sum[i-k-1]这段肯定要留在dp[i]里面。所以只需要找到sum[0] ~ sum[i-k]中小于0的最小值sum[m]，然后令dp=sum[i]-sum[m]即为以i结尾的连续子序列的最大值（就是把前面连续的最自己没有正作用的子序列干掉）。则我们要维护从sum[0]~sum[i-k]的最小值，并且每次用dp[i]更新整个区间内连续子序列的最大值即可。\n```c++\nfor(int i=f;i<n;++i){\n           Min=min(Min,sum[i-f]);   \n           Max=max(Max,sum[i]-Min);   // sum[i]-Min是以i结尾的最大连续子段和，Max是之前求出的最大连续子段和\n       }\n```\n\n## 算法\n先假定二分区间为很大，然后二分假设答案mid，令原数组所有的数减去mid得到新数组。求新数组中长度不小于k的连续子序列的最大和，如果结果大于0，说明ans设小了，区间往右边分，否则区间往左边分。直到最后区间逼近一个数为止。\n## 代码\n\n```c++\n#include<iostream>\n#include<cmath>\nusing namespace std;\ndouble a[100002];\ndouble b[100002];\ndouble sum[100002]; // 记录第i个数之前的和\nint n;\nint f;\nint main(){\n    //freopen(\"test/div1A.txt\",\"r\",stdin);\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    double mid;       // 假设的答案 \n    cin>>n>>f;\n    for(int i=0;i<n;++i){\n        //scanf(\"%lf\",&a[i]);  // 用cin会套老鹅\n        cin>>a[i];\n    }\n    double l=-1e6;    // 答案区间的左边\n    double r=1e6;     // 答案区间的右边\n    while(r-l>1e-4){\n       mid = (l+r)/2;\n       // 先求出减去平均值后的数组\n       for(int i=0;i<n;++i){\n           b[i]=a[i]-mid;   \n       }\n       \n       sum[0]=b[0];\n       for(int i = 1;i<n;++i){\n            sum[i]=sum[i-1]+b[i];\n       }\n       double Min=0;     // 记录以j(0<=j<i-f)结尾大子段和的最小值，初始值应该为0，因为比0小的我们才不要\n                         // 如果这里初始化为一个很大的值，那么若sum[0]大于0，就会被认为是要被抛弃的，然而我们只需要抛弃小于0的\n       double Max=-1e9;      // 记录长度大于f的最大子段和\n       // 求限定长度为f的最大连续子段和\n       for(int i=f;i<n;++i){\n           Min=min(Min,sum[i-f]);   \n           Max=max(Max,sum[i]-Min);   // sum[i]-Min是以i结尾的最大连续子段和，Max是之前求出的最大连续子段和\n       }\n       Max=max(Max,sum[f-1]);   // 观察可知上面没有判断sum[f-1]的情况\n       if(Max>0){  // Max>0说明答案不够大\n         l=mid;\n       }else{      // 否则就是答案不够小\n         r=mid;\n       }\n\n    }\n    cout<<(int)(1000*r)<<endl;\n}\n```\n\n\n\n","slug":"BestCowFences","published":1,"updated":"2021-07-15T10:15:26.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckr74cdso000340tk48701fcu","content":"<h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><img src=\"/2021/06/13/BestCowFences/BestCowFence.png\" class=\"\">\n<h3 id=\"题目简介\"><a href=\"#题目简介\" class=\"headerlink\" title=\"题目简介\"></a>题目简介</h3><p>题目大概就是围起连续不小于f的数，使他们的平均值最大，求出这个最大值。</p>\n<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p> 如果是求连续子序列最大和，那么问题就很简单。但是他这里要求的是最大平均数，由于最大平均数不仅和连续子序列的和有关，还和连续子序列的长度有关。即average=sum/length。则事情就变得不那么简单了。</p>\n<h5 id=\"二分答案\"><a href=\"#二分答案\" class=\"headerlink\" title=\"二分答案\"></a>二分答案</h5><p>这里用到二分答案策略，所谓的二分答案，就是假设所求的值刚开始在一个区间段[l,r]，然后选取这个区间段的中间值mid作为答案，如果算出这个中间值取大了，就从左半区间[l,mid],否则从[mid,r]找最后直到区间缩到无穷小，则此时区间的逼近值即为正确答案。这个其实在数值分析里面学过。</p>\n<h5 id=\"变向思维\"><a href=\"#变向思维\" class=\"headerlink\" title=\"变向思维\"></a>变向思维</h5><p>我们要求连续区间的最大平均值，很困难，因为这个平均值不仅和连续区间和sum有关，还与区间长度length有关，这就需要我们将问题进行转换。</p>\n<p>假设最大平均值为ans，则对于平均值最大的那段区间[i,j]有(a<sub>i</sub>+a<sub>i+1</sub>+…+a<sub>j</sub>)/length=ans。即(a<sub>i</sub>+a<sub>i+1</sub>+…+a<sub>j</sub>)-ans*length=0。</p>\n<ul>\n<li><p>如果有大于ans的区间段平均值，则对于最大的区间段[p,q],有(a<sub>p</sub>+a<sub>p+1</sub>+…+a<sub>q</sub>)/length&gt;ans，即(a<sub>p</sub>+a<sub>p+1</sub>+…+a<sub>q</sub>)-ans*length&gt;0。那么我们的ans就偏小了。这就是一个二分的判断偏小依据。</p>\n</li>\n<li><p>如果全部的区间段平均值都小于ans，则对于最大的区间段，有(a<sub>p</sub>+a<sub>p+1</sub>+…+a<sub>q</sub>)/length<ans,即(a<sub>p&lt;/sub&gt;+a<sub>p+1</sub>+…+a<sub>q</sub>)-ans*length&lt;0,则此时ans偏大了。得到一个二分偏大的判断。</p>\n</li>\n</ul>\n<p>那么问题就从求连续子序列最大平均值，转换成了求(a<sub>i</sub>+a<sub>i+1</sub>+…+a<sub>j</sub>)-ans <em> length的值。我们将整个区间段[0,n-1]的值全部减去ans，那么我们在求连续子序列的和时，就相当于求a<sub>i</sub>+a<sub>i+1</sub>+…+a<sub>j</sub>-ans </em> lengths的值。则问题最终变成了一个连续子序列求和问题。</p>\n<h5 id=\"长度不小于f的最大连续子序列问题\"><a href=\"#长度不小于f的最大连续子序列问题\" class=\"headerlink\" title=\"长度不小于f的最大连续子序列问题\"></a>长度不小于f的最大连续子序列问题</h5><p>我们可以先求出[0,n]的前缀和sum[i] i=0,1,2…n。由于子序列的长度不能小于f，则以i结尾的连续子序列dp[i] (i&gt;=f)，前f个数一定是要的。先让dp[i]=sum[i],则sum[i]-sum[i-k-1]这段肯定要留在dp[i]里面。所以只需要找到sum[0] ~ sum[i-k]中小于0的最小值sum[m]，然后令dp=sum[i]-sum[m]即为以i结尾的连续子序列的最大值（就是把前面连续的最自己没有正作用的子序列干掉）。则我们要维护从sum[0]~sum[i-k]的最小值，并且每次用dp[i]更新整个区间内连续子序列的最大值即可。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=f;i&lt;n;++i)&#123;</span><br><span class=\"line\">           Min=<span class=\"built_in\">min</span>(Min,sum[i-f]);   </span><br><span class=\"line\">           Max=<span class=\"built_in\">max</span>(Max,sum[i]-Min);   <span class=\"comment\">// sum[i]-Min是以i结尾的最大连续子段和，Max是之前求出的最大连续子段和</span></span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h2><p>先假定二分区间为很大，然后二分假设答案mid，令原数组所有的数减去mid得到新数组。求新数组中长度不小于k的连续子序列的最大和，如果结果大于0，说明ans设小了，区间往右边分，否则区间往左边分。直到最后区间逼近一个数为止。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">double</span> a[<span class=\"number\">100002</span>];</span><br><span class=\"line\"><span class=\"keyword\">double</span> b[<span class=\"number\">100002</span>];</span><br><span class=\"line\"><span class=\"keyword\">double</span> sum[<span class=\"number\">100002</span>]; <span class=\"comment\">// 记录第i个数之前的和</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"><span class=\"keyword\">int</span> f;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//freopen(&quot;test/div1A.txt&quot;,&quot;r&quot;,stdin);</span></span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">double</span> mid;       <span class=\"comment\">// 假设的答案 </span></span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;f;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//scanf(&quot;%lf&quot;,&amp;a[i]);  // 用cin会套老鹅</span></span><br><span class=\"line\">        cin&gt;&gt;a[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> l=<span class=\"number\">-1e6</span>;    <span class=\"comment\">// 答案区间的左边</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> r=<span class=\"number\">1e6</span>;     <span class=\"comment\">// 答案区间的右边</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(r-l&gt;<span class=\"number\">1e-4</span>)&#123;</span><br><span class=\"line\">       mid = (l+r)/<span class=\"number\">2</span>;</span><br><span class=\"line\">       <span class=\"comment\">// 先求出减去平均值后的数组</span></span><br><span class=\"line\">       <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">           b[i]=a[i]-mid;   </span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       </span><br><span class=\"line\">       sum[<span class=\"number\">0</span>]=b[<span class=\"number\">0</span>];</span><br><span class=\"line\">       <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">            sum[i]=sum[i<span class=\"number\">-1</span>]+b[i];</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">double</span> Min=<span class=\"number\">0</span>;     <span class=\"comment\">// 记录以j(0&lt;=j&lt;i-f)结尾大子段和的最小值，初始值应该为0，因为比0小的我们才不要</span></span><br><span class=\"line\">                         <span class=\"comment\">// 如果这里初始化为一个很大的值，那么若sum[0]大于0，就会被认为是要被抛弃的，然而我们只需要抛弃小于0的</span></span><br><span class=\"line\">       <span class=\"keyword\">double</span> Max=<span class=\"number\">-1e9</span>;      <span class=\"comment\">// 记录长度大于f的最大子段和</span></span><br><span class=\"line\">       <span class=\"comment\">// 求限定长度为f的最大连续子段和</span></span><br><span class=\"line\">       <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=f;i&lt;n;++i)&#123;</span><br><span class=\"line\">           Min=<span class=\"built_in\">min</span>(Min,sum[i-f]);   </span><br><span class=\"line\">           Max=<span class=\"built_in\">max</span>(Max,sum[i]-Min);   <span class=\"comment\">// sum[i]-Min是以i结尾的最大连续子段和，Max是之前求出的最大连续子段和</span></span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       Max=<span class=\"built_in\">max</span>(Max,sum[f<span class=\"number\">-1</span>]);   <span class=\"comment\">// 观察可知上面没有判断sum[f-1]的情况</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span>(Max&gt;<span class=\"number\">0</span>)&#123;  <span class=\"comment\">// Max&gt;0说明答案不够大</span></span><br><span class=\"line\">         l=mid;</span><br><span class=\"line\">       &#125;<span class=\"keyword\">else</span>&#123;      <span class=\"comment\">// 否则就是答案不够小</span></span><br><span class=\"line\">         r=mid;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;(<span class=\"keyword\">int</span>)(<span class=\"number\">1000</span>*r)&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><img src=\"/2021/06/13/BestCowFences/BestCowFence.png\" class=\"\">\n<h3 id=\"题目简介\"><a href=\"#题目简介\" class=\"headerlink\" title=\"题目简介\"></a>题目简介</h3><p>题目大概就是围起连续不小于f的数，使他们的平均值最大，求出这个最大值。</p>\n<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p> 如果是求连续子序列最大和，那么问题就很简单。但是他这里要求的是最大平均数，由于最大平均数不仅和连续子序列的和有关，还和连续子序列的长度有关。即average=sum/length。则事情就变得不那么简单了。</p>\n<h5 id=\"二分答案\"><a href=\"#二分答案\" class=\"headerlink\" title=\"二分答案\"></a>二分答案</h5><p>这里用到二分答案策略，所谓的二分答案，就是假设所求的值刚开始在一个区间段[l,r]，然后选取这个区间段的中间值mid作为答案，如果算出这个中间值取大了，就从左半区间[l,mid],否则从[mid,r]找最后直到区间缩到无穷小，则此时区间的逼近值即为正确答案。这个其实在数值分析里面学过。</p>\n<h5 id=\"变向思维\"><a href=\"#变向思维\" class=\"headerlink\" title=\"变向思维\"></a>变向思维</h5><p>我们要求连续区间的最大平均值，很困难，因为这个平均值不仅和连续区间和sum有关，还与区间长度length有关，这就需要我们将问题进行转换。</p>\n<p>假设最大平均值为ans，则对于平均值最大的那段区间[i,j]有(a<sub>i</sub>+a<sub>i+1</sub>+…+a<sub>j</sub>)/length=ans。即(a<sub>i</sub>+a<sub>i+1</sub>+…+a<sub>j</sub>)-ans*length=0。</p>\n<ul>\n<li><p>如果有大于ans的区间段平均值，则对于最大的区间段[p,q],有(a<sub>p</sub>+a<sub>p+1</sub>+…+a<sub>q</sub>)/length&gt;ans，即(a<sub>p</sub>+a<sub>p+1</sub>+…+a<sub>q</sub>)-ans*length&gt;0。那么我们的ans就偏小了。这就是一个二分的判断偏小依据。</p>\n</li>\n<li><p>如果全部的区间段平均值都小于ans，则对于最大的区间段，有(a<sub>p</sub>+a<sub>p+1</sub>+…+a<sub>q</sub>)/length<ans,即(a<sub>p&lt;/sub&gt;+a<sub>p+1</sub>+…+a<sub>q</sub>)-ans*length&lt;0,则此时ans偏大了。得到一个二分偏大的判断。</p>\n</li>\n</ul>\n<p>那么问题就从求连续子序列最大平均值，转换成了求(a<sub>i</sub>+a<sub>i+1</sub>+…+a<sub>j</sub>)-ans <em> length的值。我们将整个区间段[0,n-1]的值全部减去ans，那么我们在求连续子序列的和时，就相当于求a<sub>i</sub>+a<sub>i+1</sub>+…+a<sub>j</sub>-ans </em> lengths的值。则问题最终变成了一个连续子序列求和问题。</p>\n<h5 id=\"长度不小于f的最大连续子序列问题\"><a href=\"#长度不小于f的最大连续子序列问题\" class=\"headerlink\" title=\"长度不小于f的最大连续子序列问题\"></a>长度不小于f的最大连续子序列问题</h5><p>我们可以先求出[0,n]的前缀和sum[i] i=0,1,2…n。由于子序列的长度不能小于f，则以i结尾的连续子序列dp[i] (i&gt;=f)，前f个数一定是要的。先让dp[i]=sum[i],则sum[i]-sum[i-k-1]这段肯定要留在dp[i]里面。所以只需要找到sum[0] ~ sum[i-k]中小于0的最小值sum[m]，然后令dp=sum[i]-sum[m]即为以i结尾的连续子序列的最大值（就是把前面连续的最自己没有正作用的子序列干掉）。则我们要维护从sum[0]~sum[i-k]的最小值，并且每次用dp[i]更新整个区间内连续子序列的最大值即可。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=f;i&lt;n;++i)&#123;</span><br><span class=\"line\">           Min=<span class=\"built_in\">min</span>(Min,sum[i-f]);   </span><br><span class=\"line\">           Max=<span class=\"built_in\">max</span>(Max,sum[i]-Min);   <span class=\"comment\">// sum[i]-Min是以i结尾的最大连续子段和，Max是之前求出的最大连续子段和</span></span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h2><p>先假定二分区间为很大，然后二分假设答案mid，令原数组所有的数减去mid得到新数组。求新数组中长度不小于k的连续子序列的最大和，如果结果大于0，说明ans设小了，区间往右边分，否则区间往左边分。直到最后区间逼近一个数为止。</p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">double</span> a[<span class=\"number\">100002</span>];</span><br><span class=\"line\"><span class=\"keyword\">double</span> b[<span class=\"number\">100002</span>];</span><br><span class=\"line\"><span class=\"keyword\">double</span> sum[<span class=\"number\">100002</span>]; <span class=\"comment\">// 记录第i个数之前的和</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"><span class=\"keyword\">int</span> f;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//freopen(&quot;test/div1A.txt&quot;,&quot;r&quot;,stdin);</span></span><br><span class=\"line\">    ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">    cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">double</span> mid;       <span class=\"comment\">// 假设的答案 </span></span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;f;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//scanf(&quot;%lf&quot;,&amp;a[i]);  // 用cin会套老鹅</span></span><br><span class=\"line\">        cin&gt;&gt;a[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> l=<span class=\"number\">-1e6</span>;    <span class=\"comment\">// 答案区间的左边</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> r=<span class=\"number\">1e6</span>;     <span class=\"comment\">// 答案区间的右边</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(r-l&gt;<span class=\"number\">1e-4</span>)&#123;</span><br><span class=\"line\">       mid = (l+r)/<span class=\"number\">2</span>;</span><br><span class=\"line\">       <span class=\"comment\">// 先求出减去平均值后的数组</span></span><br><span class=\"line\">       <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">           b[i]=a[i]-mid;   </span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       </span><br><span class=\"line\">       sum[<span class=\"number\">0</span>]=b[<span class=\"number\">0</span>];</span><br><span class=\"line\">       <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">            sum[i]=sum[i<span class=\"number\">-1</span>]+b[i];</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">double</span> Min=<span class=\"number\">0</span>;     <span class=\"comment\">// 记录以j(0&lt;=j&lt;i-f)结尾大子段和的最小值，初始值应该为0，因为比0小的我们才不要</span></span><br><span class=\"line\">                         <span class=\"comment\">// 如果这里初始化为一个很大的值，那么若sum[0]大于0，就会被认为是要被抛弃的，然而我们只需要抛弃小于0的</span></span><br><span class=\"line\">       <span class=\"keyword\">double</span> Max=<span class=\"number\">-1e9</span>;      <span class=\"comment\">// 记录长度大于f的最大子段和</span></span><br><span class=\"line\">       <span class=\"comment\">// 求限定长度为f的最大连续子段和</span></span><br><span class=\"line\">       <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=f;i&lt;n;++i)&#123;</span><br><span class=\"line\">           Min=<span class=\"built_in\">min</span>(Min,sum[i-f]);   </span><br><span class=\"line\">           Max=<span class=\"built_in\">max</span>(Max,sum[i]-Min);   <span class=\"comment\">// sum[i]-Min是以i结尾的最大连续子段和，Max是之前求出的最大连续子段和</span></span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       Max=<span class=\"built_in\">max</span>(Max,sum[f<span class=\"number\">-1</span>]);   <span class=\"comment\">// 观察可知上面没有判断sum[f-1]的情况</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span>(Max&gt;<span class=\"number\">0</span>)&#123;  <span class=\"comment\">// Max&gt;0说明答案不够大</span></span><br><span class=\"line\">         l=mid;</span><br><span class=\"line\">       &#125;<span class=\"keyword\">else</span>&#123;      <span class=\"comment\">// 否则就是答案不够小</span></span><br><span class=\"line\">         r=mid;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;(<span class=\"keyword\">int</span>)(<span class=\"number\">1000</span>*r)&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"IDEApush到github被拒绝的问题","date":"2021-03-22T14:49:21.000Z","_content":"\n##  上传时被拒绝\n\n上传代码到github出现rejected的问题是因为新传的文件和原来的不是同一时间上传等，解决办法：\n\n```\ngit pull --rebase origin master\ngit push -u origin master -f     //这句不一定要\n```\n\n\n##  删除Github上面的文件夹\n\n先pull（把github上的文件pull下来）\n再执行\n```\ngit rm --cached -r \"要删除的文件夹\"\n```\n然后再commit，再push就行了。\n","source":"_posts/IDEApush到github被拒绝的问题.md","raw":"---\ntitle: IDEApush到github被拒绝的问题\ndate: 2021-03-22 22:49:21\ncategories:\n- Diary\ntags:\n- JAVA\n---\n\n##  上传时被拒绝\n\n上传代码到github出现rejected的问题是因为新传的文件和原来的不是同一时间上传等，解决办法：\n\n```\ngit pull --rebase origin master\ngit push -u origin master -f     //这句不一定要\n```\n\n\n##  删除Github上面的文件夹\n\n先pull（把github上的文件pull下来）\n再执行\n```\ngit rm --cached -r \"要删除的文件夹\"\n```\n然后再commit，再push就行了。\n","slug":"IDEApush到github被拒绝的问题","published":1,"updated":"2021-07-15T10:15:26.457Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckr74cdsr000640tk3onpbnj5","content":"<h2 id=\"上传时被拒绝\"><a href=\"#上传时被拒绝\" class=\"headerlink\" title=\"上传时被拒绝\"></a>上传时被拒绝</h2><p>上传代码到github出现rejected的问题是因为新传的文件和原来的不是同一时间上传等，解决办法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull --rebase origin master</span><br><span class=\"line\">git push -u origin master -f     &#x2F;&#x2F;这句不一定要</span><br></pre></td></tr></table></figure>\n<h2 id=\"删除Github上面的文件夹\"><a href=\"#删除Github上面的文件夹\" class=\"headerlink\" title=\"删除Github上面的文件夹\"></a>删除Github上面的文件夹</h2><p>先pull（把github上的文件pull下来）<br>再执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rm --cached -r &quot;要删除的文件夹&quot;</span><br></pre></td></tr></table></figure><br>然后再commit，再push就行了。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"上传时被拒绝\"><a href=\"#上传时被拒绝\" class=\"headerlink\" title=\"上传时被拒绝\"></a>上传时被拒绝</h2><p>上传代码到github出现rejected的问题是因为新传的文件和原来的不是同一时间上传等，解决办法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git pull --rebase origin master</span><br><span class=\"line\">git push -u origin master -f     &#x2F;&#x2F;这句不一定要</span><br></pre></td></tr></table></figure>\n<h2 id=\"删除Github上面的文件夹\"><a href=\"#删除Github上面的文件夹\" class=\"headerlink\" title=\"删除Github上面的文件夹\"></a>删除Github上面的文件夹</h2><p>先pull（把github上的文件pull下来）<br>再执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rm --cached -r &quot;要删除的文件夹&quot;</span><br></pre></td></tr></table></figure><br>然后再commit，再push就行了。</p>\n"},{"title":"MaxMedian","date":"2021-06-13T03:57:10.000Z","_content":"# 题目\n{% asset_img MaxMedian.png %}\n\n### 题目简述\n这题是长度不小于k连续子序列排队后的最大中位数。其中排序后+中位数定义下标为$\\lfloor(r-l+1)/2\\rfloor$.\n\n###分析\n这是一道求长度不小于k的连续子序列问题，但它又不是简单求连续子序列的问题。而是求中位数，而且是子序列排序后的中位数，并且要中位数最大。这种场景很难不让人想到二分答案+问题转化。\n通过观察不难发现\n- 如果连续子序列长度是偶数，如[1,2,3,4,5,6],那么大于等于中位数的数会比小于中位数的数多两个。\n- 如果连续子序列的长度是奇数，如[1,2,3,4,5]那么大于等于中位数的数会比小于中位数的数一两个。\n除上面所述两中情况之外不会有其他情况。\n\n## 算法\n根据分析可以巧妙设计算法，假设答案ans，如果序列中的值大于等于ans，令其等于1，否等于-1。如果变换后的序列中长度不小于k的最大连续子序列的值小于0，就说明中位数ans设大了，则答案往小取，否则答案往大取，直到二分区间无穷小。\n\n```c++\n#include<iostream>\nusing namespace std;\nint a[200002];\nint sum[200002];\nint main(){\n    int n,k;\n    //freopen(\"test/div1C.txt\",\"r\",stdin);\n    // 关同步流\n     ios::sync_with_stdio(false);\n     cin.tie(0);\n    cin>>n>>k;\n    for(int i = 0;i<n;++i){\n        cin>>a[i];\n    }\n    double l=-1e9;   // 答案左区间\n    double r=1e9;    // 答案右区间\n    while(r-l>1e-5){\n        //cout<<l<<\" \"<<r<<endl;\n        double mid=(l+r)/2;\n        //求变形之后地前缀和\n        if(a[0]>=mid){\n            sum[0]=1;\n        }else{\n            sum[0]=-1;\n        }\n        for(int j = 1;j<n;++j){\n           if(a[j]>=mid){\n               sum[j]=sum[j-1]+1;\n           }else{\n               sum[j]=sum[j-1]-1;\n           }\n        }\n\n       // 求最大子段和\n       int Min=0;\n       int Max=-1e9;\n       for(int i = k;i<n;++i){\n           Min=min(Min,sum[i-k]);\n           Max=max(Max,sum[i]-Min);\n       }\n\n       Max=max(Max,sum[k-1]);\n       if(Max>0){\n           l=mid;\n       }else{\n           r=mid;\n       }\n       \n    }\n    cout<<(int)r<<endl;\n}\n```\n\n\n\n\n","source":"_posts/MaxMedian.md","raw":"---\ntitle: MaxMedian\ndate: 2021-06-13 11:57:10\ncategories:\n    - div1\ntags:\n    - 限定长度最大子段和\n    - 思维\n    - 二分答案\n---\n# 题目\n{% asset_img MaxMedian.png %}\n\n### 题目简述\n这题是长度不小于k连续子序列排队后的最大中位数。其中排序后+中位数定义下标为$\\lfloor(r-l+1)/2\\rfloor$.\n\n###分析\n这是一道求长度不小于k的连续子序列问题，但它又不是简单求连续子序列的问题。而是求中位数，而且是子序列排序后的中位数，并且要中位数最大。这种场景很难不让人想到二分答案+问题转化。\n通过观察不难发现\n- 如果连续子序列长度是偶数，如[1,2,3,4,5,6],那么大于等于中位数的数会比小于中位数的数多两个。\n- 如果连续子序列的长度是奇数，如[1,2,3,4,5]那么大于等于中位数的数会比小于中位数的数一两个。\n除上面所述两中情况之外不会有其他情况。\n\n## 算法\n根据分析可以巧妙设计算法，假设答案ans，如果序列中的值大于等于ans，令其等于1，否等于-1。如果变换后的序列中长度不小于k的最大连续子序列的值小于0，就说明中位数ans设大了，则答案往小取，否则答案往大取，直到二分区间无穷小。\n\n```c++\n#include<iostream>\nusing namespace std;\nint a[200002];\nint sum[200002];\nint main(){\n    int n,k;\n    //freopen(\"test/div1C.txt\",\"r\",stdin);\n    // 关同步流\n     ios::sync_with_stdio(false);\n     cin.tie(0);\n    cin>>n>>k;\n    for(int i = 0;i<n;++i){\n        cin>>a[i];\n    }\n    double l=-1e9;   // 答案左区间\n    double r=1e9;    // 答案右区间\n    while(r-l>1e-5){\n        //cout<<l<<\" \"<<r<<endl;\n        double mid=(l+r)/2;\n        //求变形之后地前缀和\n        if(a[0]>=mid){\n            sum[0]=1;\n        }else{\n            sum[0]=-1;\n        }\n        for(int j = 1;j<n;++j){\n           if(a[j]>=mid){\n               sum[j]=sum[j-1]+1;\n           }else{\n               sum[j]=sum[j-1]-1;\n           }\n        }\n\n       // 求最大子段和\n       int Min=0;\n       int Max=-1e9;\n       for(int i = k;i<n;++i){\n           Min=min(Min,sum[i-k]);\n           Max=max(Max,sum[i]-Min);\n       }\n\n       Max=max(Max,sum[k-1]);\n       if(Max>0){\n           l=mid;\n       }else{\n           r=mid;\n       }\n       \n    }\n    cout<<(int)r<<endl;\n}\n```\n\n\n\n\n","slug":"MaxMedian","published":1,"updated":"2021-07-15T10:15:26.457Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckr74cdst000840tk19k81729","content":"<h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><img src=\"/2021/06/13/MaxMedian/MaxMedian.png\" class=\"\">\n<h3 id=\"题目简述\"><a href=\"#题目简述\" class=\"headerlink\" title=\"题目简述\"></a>题目简述</h3><p>这题是长度不小于k连续子序列排队后的最大中位数。其中排序后+中位数定义下标为$\\lfloor(r-l+1)/2\\rfloor$.</p>\n<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p>这是一道求长度不小于k的连续子序列问题，但它又不是简单求连续子序列的问题。而是求中位数，而且是子序列排序后的中位数，并且要中位数最大。这种场景很难不让人想到二分答案+问题转化。<br>通过观察不难发现</p>\n<ul>\n<li>如果连续子序列长度是偶数，如[1,2,3,4,5,6],那么大于等于中位数的数会比小于中位数的数多两个。</li>\n<li>如果连续子序列的长度是奇数，如[1,2,3,4,5]那么大于等于中位数的数会比小于中位数的数一两个。<br>除上面所述两中情况之外不会有其他情况。</li>\n</ul>\n<h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h2><p>根据分析可以巧妙设计算法，假设答案ans，如果序列中的值大于等于ans，令其等于1，否等于-1。如果变换后的序列中长度不小于k的最大连续子序列的值小于0，就说明中位数ans设大了，则答案往小取，否则答案往大取，直到二分区间无穷小。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">int</span> a[<span class=\"number\">200002</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> sum[<span class=\"number\">200002</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n,k;</span><br><span class=\"line\">    <span class=\"comment\">//freopen(&quot;test/div1C.txt&quot;,&quot;r&quot;,stdin);</span></span><br><span class=\"line\">    <span class=\"comment\">// 关同步流</span></span><br><span class=\"line\">     ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">     cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">        cin&gt;&gt;a[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> l=<span class=\"number\">-1e9</span>;   <span class=\"comment\">// 答案左区间</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> r=<span class=\"number\">1e9</span>;    <span class=\"comment\">// 答案右区间</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(r-l&gt;<span class=\"number\">1e-5</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//cout&lt;&lt;l&lt;&lt;&quot; &quot;&lt;&lt;r&lt;&lt;endl;</span></span><br><span class=\"line\">        <span class=\"keyword\">double</span> mid=(l+r)/<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"comment\">//求变形之后地前缀和</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a[<span class=\"number\">0</span>]&gt;=mid)&#123;</span><br><span class=\"line\">            sum[<span class=\"number\">0</span>]=<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            sum[<span class=\"number\">0</span>]=<span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;j&lt;n;++j)&#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span>(a[j]&gt;=mid)&#123;</span><br><span class=\"line\">               sum[j]=sum[j<span class=\"number\">-1</span>]+<span class=\"number\">1</span>;</span><br><span class=\"line\">           &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">               sum[j]=sum[j<span class=\"number\">-1</span>]<span class=\"number\">-1</span>;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">// 求最大子段和</span></span><br><span class=\"line\">       <span class=\"keyword\">int</span> Min=<span class=\"number\">0</span>;</span><br><span class=\"line\">       <span class=\"keyword\">int</span> Max=<span class=\"number\">-1e9</span>;</span><br><span class=\"line\">       <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = k;i&lt;n;++i)&#123;</span><br><span class=\"line\">           Min=<span class=\"built_in\">min</span>(Min,sum[i-k]);</span><br><span class=\"line\">           Max=<span class=\"built_in\">max</span>(Max,sum[i]-Min);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       Max=<span class=\"built_in\">max</span>(Max,sum[k<span class=\"number\">-1</span>]);</span><br><span class=\"line\">       <span class=\"keyword\">if</span>(Max&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">           l=mid;</span><br><span class=\"line\">       &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">           r=mid;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;(<span class=\"keyword\">int</span>)r&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><img src=\"/2021/06/13/MaxMedian/MaxMedian.png\" class=\"\">\n<h3 id=\"题目简述\"><a href=\"#题目简述\" class=\"headerlink\" title=\"题目简述\"></a>题目简述</h3><p>这题是长度不小于k连续子序列排队后的最大中位数。其中排序后+中位数定义下标为$\\lfloor(r-l+1)/2\\rfloor$.</p>\n<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p>这是一道求长度不小于k的连续子序列问题，但它又不是简单求连续子序列的问题。而是求中位数，而且是子序列排序后的中位数，并且要中位数最大。这种场景很难不让人想到二分答案+问题转化。<br>通过观察不难发现</p>\n<ul>\n<li>如果连续子序列长度是偶数，如[1,2,3,4,5,6],那么大于等于中位数的数会比小于中位数的数多两个。</li>\n<li>如果连续子序列的长度是奇数，如[1,2,3,4,5]那么大于等于中位数的数会比小于中位数的数一两个。<br>除上面所述两中情况之外不会有其他情况。</li>\n</ul>\n<h2 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h2><p>根据分析可以巧妙设计算法，假设答案ans，如果序列中的值大于等于ans，令其等于1，否等于-1。如果变换后的序列中长度不小于k的最大连续子序列的值小于0，就说明中位数ans设大了，则答案往小取，否则答案往大取，直到二分区间无穷小。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">int</span> a[<span class=\"number\">200002</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> sum[<span class=\"number\">200002</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n,k;</span><br><span class=\"line\">    <span class=\"comment\">//freopen(&quot;test/div1C.txt&quot;,&quot;r&quot;,stdin);</span></span><br><span class=\"line\">    <span class=\"comment\">// 关同步流</span></span><br><span class=\"line\">     ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">     cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">        cin&gt;&gt;a[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> l=<span class=\"number\">-1e9</span>;   <span class=\"comment\">// 答案左区间</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> r=<span class=\"number\">1e9</span>;    <span class=\"comment\">// 答案右区间</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(r-l&gt;<span class=\"number\">1e-5</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//cout&lt;&lt;l&lt;&lt;&quot; &quot;&lt;&lt;r&lt;&lt;endl;</span></span><br><span class=\"line\">        <span class=\"keyword\">double</span> mid=(l+r)/<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"comment\">//求变形之后地前缀和</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a[<span class=\"number\">0</span>]&gt;=mid)&#123;</span><br><span class=\"line\">            sum[<span class=\"number\">0</span>]=<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            sum[<span class=\"number\">0</span>]=<span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;j&lt;n;++j)&#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span>(a[j]&gt;=mid)&#123;</span><br><span class=\"line\">               sum[j]=sum[j<span class=\"number\">-1</span>]+<span class=\"number\">1</span>;</span><br><span class=\"line\">           &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">               sum[j]=sum[j<span class=\"number\">-1</span>]<span class=\"number\">-1</span>;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">// 求最大子段和</span></span><br><span class=\"line\">       <span class=\"keyword\">int</span> Min=<span class=\"number\">0</span>;</span><br><span class=\"line\">       <span class=\"keyword\">int</span> Max=<span class=\"number\">-1e9</span>;</span><br><span class=\"line\">       <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = k;i&lt;n;++i)&#123;</span><br><span class=\"line\">           Min=<span class=\"built_in\">min</span>(Min,sum[i-k]);</span><br><span class=\"line\">           Max=<span class=\"built_in\">max</span>(Max,sum[i]-Min);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       Max=<span class=\"built_in\">max</span>(Max,sum[k<span class=\"number\">-1</span>]);</span><br><span class=\"line\">       <span class=\"keyword\">if</span>(Max&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">           l=mid;</span><br><span class=\"line\">       &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">           r=mid;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;(<span class=\"keyword\">int</span>)r&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Postons","date":"2021-06-09T06:44:47.000Z","_content":"\n# 题目\n{% asset_img Potions(Hard_version).png %}\n#### 题目分析\n题目大概意思就是给出n个药水，每种药水会让生命值变化，你从左到右走，经过这个位置的时候可以拿起这瓶药水也可以忽略这瓶药水。你的初始生命值为0，并且整个过程中你的生命值不能低于0，问你最多能拿多少药水。\n\n#### 题解\n这个题目和最大连续子序列不同，这个是可以不连续的。\n\n- 贪心：使用贪心的策略，每次只要生命值允许，就拿这瓶药，并且记录自己拿了那些药。\n\n- 反悔：如果走到一个地方，拿了这瓶药之后，自己的生命会比0小，则比较：\n     - 若将之前所有药中生命值最小的一瓶比现在碰到的这瓶还小，那么丢弃之前那瓶药，而选择这瓶药，即反悔。\n     - 否则跳过这瓶药\n\n- 优先队列：由于每次都要比较之前已经拿了的药最小的，所以要用小根堆来记录之前已经喝过的药。\n\n#### 代码\n```c++\n#include<iostream>\n#include<queue>\nusing namespace std;\nlong long Now=0;    // 当前生命值\nint ans=0;    // 能够捡起的数量 \nint a[200004];\nint n;     // position数\nint main(){\n    //freopen(\"test/div1A.txt\",\"r\",stdin);\n    cin>>n;\n    priority_queue<int,vector<int>,greater<int>> Q;   // 小根堆\n    for(int i = 0;i<n;++i){\n        cin>>a[i];\n    }\n\n    for(int i =0;i<n;++i){\n        if(Now+a[i]<0){\n            if(!Q.empty()&&Q.top()<a[i]){\n                // 将小根堆顶部替换掉，由于Now本来就大于0，所以反悔后Now也大于0\n                Now=Now+a[i]-Q.top();\n                Q.pop();\n                Q.push(a[i]);\n                \n            }else{\n                continue;\n            }\n        }else{\n            Now+=a[i];\n            Q.push(a[i]);    // 把之前要的记录下来\n            ans++;\n        }\n    }\n    cout<<ans<<endl;\n}\n```\n\n\n","source":"_posts/Postons.md","raw":"---\ntitle: Postons\ndate: 2021-06-09 14:44:47\ncategories:\n   - div1\ntags:\n   - 反悔\n   - 贪心\n   - 优先队列\n---\n\n# 题目\n{% asset_img Potions(Hard_version).png %}\n#### 题目分析\n题目大概意思就是给出n个药水，每种药水会让生命值变化，你从左到右走，经过这个位置的时候可以拿起这瓶药水也可以忽略这瓶药水。你的初始生命值为0，并且整个过程中你的生命值不能低于0，问你最多能拿多少药水。\n\n#### 题解\n这个题目和最大连续子序列不同，这个是可以不连续的。\n\n- 贪心：使用贪心的策略，每次只要生命值允许，就拿这瓶药，并且记录自己拿了那些药。\n\n- 反悔：如果走到一个地方，拿了这瓶药之后，自己的生命会比0小，则比较：\n     - 若将之前所有药中生命值最小的一瓶比现在碰到的这瓶还小，那么丢弃之前那瓶药，而选择这瓶药，即反悔。\n     - 否则跳过这瓶药\n\n- 优先队列：由于每次都要比较之前已经拿了的药最小的，所以要用小根堆来记录之前已经喝过的药。\n\n#### 代码\n```c++\n#include<iostream>\n#include<queue>\nusing namespace std;\nlong long Now=0;    // 当前生命值\nint ans=0;    // 能够捡起的数量 \nint a[200004];\nint n;     // position数\nint main(){\n    //freopen(\"test/div1A.txt\",\"r\",stdin);\n    cin>>n;\n    priority_queue<int,vector<int>,greater<int>> Q;   // 小根堆\n    for(int i = 0;i<n;++i){\n        cin>>a[i];\n    }\n\n    for(int i =0;i<n;++i){\n        if(Now+a[i]<0){\n            if(!Q.empty()&&Q.top()<a[i]){\n                // 将小根堆顶部替换掉，由于Now本来就大于0，所以反悔后Now也大于0\n                Now=Now+a[i]-Q.top();\n                Q.pop();\n                Q.push(a[i]);\n                \n            }else{\n                continue;\n            }\n        }else{\n            Now+=a[i];\n            Q.push(a[i]);    // 把之前要的记录下来\n            ans++;\n        }\n    }\n    cout<<ans<<endl;\n}\n```\n\n\n","slug":"Postons","published":1,"updated":"2021-07-15T10:15:26.463Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckr74cdst000940tk70b1hjvy","content":"<h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><img src=\"/2021/06/09/Postons/Potions(Hard_version).png\" class=\"\">\n<h4 id=\"题目分析\"><a href=\"#题目分析\" class=\"headerlink\" title=\"题目分析\"></a>题目分析</h4><p>题目大概意思就是给出n个药水，每种药水会让生命值变化，你从左到右走，经过这个位置的时候可以拿起这瓶药水也可以忽略这瓶药水。你的初始生命值为0，并且整个过程中你的生命值不能低于0，问你最多能拿多少药水。</p>\n<h4 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h4><p>这个题目和最大连续子序列不同，这个是可以不连续的。</p>\n<ul>\n<li><p>贪心：使用贪心的策略，每次只要生命值允许，就拿这瓶药，并且记录自己拿了那些药。</p>\n</li>\n<li><p>反悔：如果走到一个地方，拿了这瓶药之后，自己的生命会比0小，则比较：</p>\n<ul>\n<li>若将之前所有药中生命值最小的一瓶比现在碰到的这瓶还小，那么丢弃之前那瓶药，而选择这瓶药，即反悔。</li>\n<li>否则跳过这瓶药</li>\n</ul>\n</li>\n<li><p>优先队列：由于每次都要比较之前已经拿了的药最小的，所以要用小根堆来记录之前已经喝过的药。</p>\n</li>\n</ul>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> Now=<span class=\"number\">0</span>;    <span class=\"comment\">// 当前生命值</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> ans=<span class=\"number\">0</span>;    <span class=\"comment\">// 能够捡起的数量 </span></span><br><span class=\"line\"><span class=\"keyword\">int</span> a[<span class=\"number\">200004</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> n;     <span class=\"comment\">// position数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//freopen(&quot;test/div1A.txt&quot;,&quot;r&quot;,stdin);</span></span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    priority_queue&lt;<span class=\"keyword\">int</span>,vector&lt;<span class=\"keyword\">int</span>&gt;,greater&lt;<span class=\"keyword\">int</span>&gt;&gt; Q;   <span class=\"comment\">// 小根堆</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">        cin&gt;&gt;a[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i =<span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(Now+a[i]&lt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!Q.<span class=\"built_in\">empty</span>()&amp;&amp;Q.<span class=\"built_in\">top</span>()&lt;a[i])&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 将小根堆顶部替换掉，由于Now本来就大于0，所以反悔后Now也大于0</span></span><br><span class=\"line\">                Now=Now+a[i]-Q.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">                Q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">                Q.<span class=\"built_in\">push</span>(a[i]);</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            Now+=a[i];</span><br><span class=\"line\">            Q.<span class=\"built_in\">push</span>(a[i]);    <span class=\"comment\">// 把之前要的记录下来</span></span><br><span class=\"line\">            ans++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><img src=\"/2021/06/09/Postons/Potions(Hard_version).png\" class=\"\">\n<h4 id=\"题目分析\"><a href=\"#题目分析\" class=\"headerlink\" title=\"题目分析\"></a>题目分析</h4><p>题目大概意思就是给出n个药水，每种药水会让生命值变化，你从左到右走，经过这个位置的时候可以拿起这瓶药水也可以忽略这瓶药水。你的初始生命值为0，并且整个过程中你的生命值不能低于0，问你最多能拿多少药水。</p>\n<h4 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"></a>题解</h4><p>这个题目和最大连续子序列不同，这个是可以不连续的。</p>\n<ul>\n<li><p>贪心：使用贪心的策略，每次只要生命值允许，就拿这瓶药，并且记录自己拿了那些药。</p>\n</li>\n<li><p>反悔：如果走到一个地方，拿了这瓶药之后，自己的生命会比0小，则比较：</p>\n<ul>\n<li>若将之前所有药中生命值最小的一瓶比现在碰到的这瓶还小，那么丢弃之前那瓶药，而选择这瓶药，即反悔。</li>\n<li>否则跳过这瓶药</li>\n</ul>\n</li>\n<li><p>优先队列：由于每次都要比较之前已经拿了的药最小的，所以要用小根堆来记录之前已经喝过的药。</p>\n</li>\n</ul>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> Now=<span class=\"number\">0</span>;    <span class=\"comment\">// 当前生命值</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> ans=<span class=\"number\">0</span>;    <span class=\"comment\">// 能够捡起的数量 </span></span><br><span class=\"line\"><span class=\"keyword\">int</span> a[<span class=\"number\">200004</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> n;     <span class=\"comment\">// position数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//freopen(&quot;test/div1A.txt&quot;,&quot;r&quot;,stdin);</span></span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    priority_queue&lt;<span class=\"keyword\">int</span>,vector&lt;<span class=\"keyword\">int</span>&gt;,greater&lt;<span class=\"keyword\">int</span>&gt;&gt; Q;   <span class=\"comment\">// 小根堆</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">        cin&gt;&gt;a[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i =<span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(Now+a[i]&lt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!Q.<span class=\"built_in\">empty</span>()&amp;&amp;Q.<span class=\"built_in\">top</span>()&lt;a[i])&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 将小根堆顶部替换掉，由于Now本来就大于0，所以反悔后Now也大于0</span></span><br><span class=\"line\">                Now=Now+a[i]-Q.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">                Q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">                Q.<span class=\"built_in\">push</span>(a[i]);</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            Now+=a[i];</span><br><span class=\"line\">            Q.<span class=\"built_in\">push</span>(a[i]);    <span class=\"comment\">// 把之前要的记录下来</span></span><br><span class=\"line\">            ans++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"USST题解报告","date":"2021-06-25T08:44:06.000Z","catagories":["题解报告"],"_content":"# 上海理工校赛题解报告\n\n## 小结\n数学题，不会\n\n## B题 [Bheith i ngra le](https://ac.nowcoder.com/acm/contest/17574/B)\n当初挣扎了一下，然后不会求给定i行j列的格子有多少单调曲线，就放弃了。\n\n## 分析\n* 题目的核心是是求给定i行j列的格子能够构造多少调单调曲线。可以用dp或者组合求解，不喜欢数学的我毅然投奔了dp。  \n* 不难发现，当给定了宽为i，高为j的格子矩阵的时候，我们分析右上角那块，如果这块不画，那么所有情况就会变成dp[i][j-1],如果这块画上，那么情况就会是dp[i-1][j]。则得到状态转移方程dp[i][j]=dp[i][j-1]+dp[i-1][j]。当然，边界条件还是值得考虑一下的。\n* 算出dp数组后，性高彩烈的用n<sup>3</sup>去套老鹅。其实我们确定了山顶左边位置l之后不用去确定右边的r，dp[n-l][h]就是右边包含山顶在内的全部可能。所以ans=ans+dp[l-1][h-1]*dp[n-l][h]即可。\n```c++\n#include<iostream>\nusing namespace std;\nlong long dp[2003][2003];\nlong long mod=1e9+7;\nlong long ans;\nint main(){\n\tint n,m;\n\tcin >>n>>m;\n    // 初始化高度为1时\n\tdp[1][1]=2;\n\tfor(int i = 2;i<=n;++i){\n\t\tdp[i][1]=dp[i-1][1]+1;\n\t}\n\t// 初始化宽度为1的时候\n\tfor(int j = 2;j<=m;++j){\n\t\tdp[1][j]=dp[1][j-1]+1;\n\t} \n    // 求dp，i为宽，j为高\n\tfor(int i = 2;i<=n;++i){\n\t\tfor(int j = 2;j<=m;++j){\n           dp[i][j]=(dp[i][j-1]+dp[i-1][j])%mod;\n\t\t}\n\t}\n\t\n\t// 宽度为0时答案应该为1，因为下面用的乘法\n\tfor(int j=0;j<=m;++j){\n\t\tdp[0][j]=1;\n\t} \n\n   // 高度为0时，也应该是1，即取0\n   for(int i = 0;i<=n;++i){\n\t   dp[i][0]=1;\n   }\n\t\n\t// cout<<dp[1][1]<<endl<<dp[2][1]<<endl<<dp[1][2]<<endl<<dp[2][2]<<endl<<dp[1][3]<<endl<<dp[2][3]<<endl; \n\n\t// 枚举山顶的情况,l是左边，r是右边，h是山高\n\tfor(int l = 1;l<=n;++l){\n\t\t\tfor(int h = 1;h<=m;++h){\n               ans = (ans+(dp[l-1][h-1]*dp[n-l][h])%mod)%mod;   // 是左边的情况乘以右边的情况\n\t\t\t}\n\t}\n\t\n\t// 加上山顶全为0的情况，只有一种\n\t ans=(ans+1)%mod;\n\n\tcout<<ans<<endl;\n}\n```\n\n## J题 [JXC&JESUS](https://ac.nowcoder.com/acm/contest/17574/J)\n这是一个数学题\n## 分析\n题目大概的意思是定义了一个函数  \n$$f(i,m)=p_{1}^{ \\lfloor\\frac{a1}{m}  \\rfloor}*p_{2}^{a_2} * ... * p^{k}_ {a^k}$$   \n其中p<sub>1</sub>,p<sub>2</sub> ...p<sub>k</sub>为i的质因数。给定参数n,m,L求  \n$$\\sum\\limits_{i=L+1}^{L+n}-f(i,m)$$\n这关系到i的质因数的问题，可以用线性筛求质因数。又f(i,m)只和m与其最小质因子有关，我们在线性筛的时候合数也是被其最小质因子筛掉。所以想到从线性筛的基础上进行状态转移，由小的质数推出合数的f(i,m)，从而使求答案也变成线性。另一种是求出了素数之后直接暴力，也能过。  \n根据以下算法枚举&nbsp;i&nbsp;进行计算\n* 当i是质数的时候，当m=1时，f[i]=i,否则f[i]=1。（注意：1不是质因数）  \n* 枚举质数prime[j]利用i对i*prime[j]进行推算。\n   * 当prime[j]不能整除i时，则prime[j]是$i\\ast prime[j]$的最小质因子，且只有一个，$cnt[i\\ast prime[j]]=1$。当m&nbsp;=&nbsp;1时，$f[i\\ast prime[j]]=i\\ast prime[j]$,否则$f[i\\ast prime[j]]=i$。(因为此时$\\lfloor  \\frac{a1}{m}  \\rfloor$为0)\n   * 当prime[j]能整除i时，则prime[j]也是i的最小质因子，此时$cnt[i\\ast prime[j]]=cnt[i]+1$。当$cnt[i \\ast prime[j]]\\%m=0$ 时，$f[i\\ast prime[j]]=i\\ast prime[j]$,否则$f[i\\ast prime[j]]=i$。（此时应该枚举新的i，就如线性筛那样。）  \n\n```c++\n#include <iostream>\n#include<cstring>\nusing namespace std;\n#define MAX 20000003\nint prime[MAX];   // 存素数\nbool isprime[MAX]; // 判断是否素数\nint n,m,L;\nint ans=0;   // 存放答案\nint cnt[MAX]; // 存放最小质因数的个数\nint CNT=1;\nint f[MAX];  // f存起来，因为可能提前求得\nint minp[MAX]; // 记录合数的最小质因子\n\n// 求素数\nvoid calPrime(){\n    prime[0]=1;\n    isprime[0]=isprime[1]=isprime[2]=true;\n    for(int i = 2;i<=MAX;++i){\n        if(isprime[i]){\n            prime[CNT++]=i;\n        }\n        // 将i的倍数标记为合数，合数只会被其最小质因子标记，所以很方便可求出最小质因子\n        for(int j = 1;j<CNT&&i*prime[j]<=MAX;++j){\n            isprime[i*prime[j]]=false;\n            // 如果i能够整除prime[j]，则退出\n            if(i%prime[j]==0){\n                break;\n            }\n        }\n    }\n}\n// 直接求f\nvoid  F(){\n    for(int i =2;i<=L+n;++i){\n       \n        // i是质数的情况,其最小质因数为其本身,则根据m讨论f\n        if(isprime[i]){\n            if(m==1){\n                f[i]=i;\n                cnt[i]=1;\n            }else{\n                f[i]=1;\n                cnt[i]=1;\n            }\n        }\n        // i不是质数的情况,枚举质数，不包括1\n        for(int j = 1;j<CNT&&i*prime[j]<=L+n;++j){\n            // 如果i不能整除prime[j],此时prime[j]是i*prime[j]的最小质因子，因为i非质数\n           if(i%prime[j]!=0){  \n               if(m==1){\n                   f[i*prime[j]]=i*prime[j];\n               }else{   //m!=1时，最最小质因数就无贡献了\n                   f[i*prime[j]]=i;\n               }\n               cnt[i*prime[j]]=1;\n           }else{ // 如果prime[j]能整除当前的i，则prime[j]也是i的最小质因子\n               cnt[i*prime[j]]=cnt[i]+1;\n               // 只有当cnt是m的倍数的时候，prime[j]才有贡献\n               if(cnt[i*prime[j]]%m==0){  \n                   f[i*prime[j]]=f[i]*prime[j];\n               }else{\n                   f[i*prime[j]]=f[i];\n               }\n               break;\n               \n           }\n        }\n    }\n}\n\nint main(){\n    memset(isprime,true,sizeof(isprime));\n    memset(cnt,1,sizeof(cnt));\n    memset(f,0,sizeof(f));\n    cin>>n>>m>>L;\n    calPrime(); //求素数\n    F();\n    for(int i = L+1;i<=L+n;++i){\n        ans+=i-f[i];\n    }\n    cout<<ans<<endl;\n}\n```\n\n## M题 [Minecraft](https://ac.nowcoder.com/acm/contest/17574/M)\n这题挺简单，毕竟人家说了时签到题，不过这个输入格式确实有点费脑。\n\n## 分析\n根据题目，差不多重点就是下面\n* 每次从房子的每根“柱子”最底下建起方块(因为不能流沙)。\n* 每次选定一个字母之后所以该字母的位置都要建方块！  \n* 最后要以最大字典序输出！  \n\n可以通过有向图和拓扑排序解决，先填充入度为0的字母，然后更新图，如果全部入度为0的都已经访问了还有入度不为0，就重建失败。  \n对于字典序问题，没有用优先队列，直接在while里面套一个for即可，并且要从字母Z遍历到A，特别注意的是，一旦找到一个字母后，要重新进行for循环，不然达不到字典序。就因为这个卡88.9%给我整吐了。\n\n``` c++\n#include<iostream>\n#include<cstring>\nusing namespace std;\n#define MAX 27     \nint t;   // 测试数\nint n,m,h;  // 长宽高\nint let[35][35][35];   // 在房子某个坐标的字母,用int存\nchar c;\ntypedef struct NODE{\n    int in=0;   // 入度\n    int out=0;  // 出度\n    int next[30000];  // 连接的下一个点，注意点的个数\n    bool isused=false;  // 记录是否已经访问过 \n    bool isExit=false;\n}NODE;\nchar ans[MAX]; // 存放答案的字母\nint  cnt=0;   // 答案中共有多少个字母\nNODE Node[MAX];    // 设置结点\nint main(){\n    //freopen(\"test/USSTM.txt\",\"r\",stdin);\n    cin>>t;\n    while(t--){\n        // 每次开始的时候记得还原\n\n        cnt=0;\n        c=0;\n        for(int i = 0;i<MAX;++i){\n            Node[i].in=0;\n            Node[i].isExit=false;\n            Node[i].isused=false;\n            Node[i].out=0;\n        }\n        cin>>n>>m>>h;\n        if(n==0||m==0||h==0){\n            cout<<\"-1\"<<endl;\n            continue;\n        }\n\n       // 输入考了一波理解\n        for(int k = h-1;k>=0;--k){\n        for(int i = 0;i<n;++i){\n            for(int j = 0;j<m;++j){\n                \n                cin>>c;\n               let[i][j][k]=(int)c-'A';\n               Node[let[i][j][k]].isExit=true;\n               \n            }\n         }\n         \n        }\n\n\n        // 开始构造图\n        for(int k = 1;k<h;++k){\n        for(int i = 0;i<n;++i){\n            for(int j = 0;j<m;++j){\n                // 如果和下面的不相等，则要生成边\n                if(let[i][j][k]!=let[i][j][k-1]){\n                    int tempU=let[i][j][k];\n                    int tempL=let[i][j][k-1];\n                    Node[tempU].in++;\n                    Node[tempL].next[Node[tempL].out++]=tempU;\n                }\n            }\n        }\n    }\n\n        bool canUsed=true;    // 记录能否找到入度为0且没有访问过的结点\n\n        while(canUsed){\n        canUsed=false;\n        // 从字母大的找起,这里就不用优先队列了\n        for(int i = 25;i>=0;--i){\n           // 本来有这个点才去判断\n           if(Node[i].isExit){\n                // 入度为0且没有访问过\n                if(Node[i].in==0&&!Node[i].isused){\n                    canUsed=true;\n                    ans[cnt++]=char(i+'A');\n                    // 更新结点状态,并更新其连接的边的状态\n                     Node[i].isused=true; \n                    for(int j = 0;j<Node[i].out;++j){\n                         Node[Node[i].next[j]].in--;\n                    }\n\n                    // 找到一个之后，一定要重新再来，不然达不到字典序\n                    break;\n                }\n           }\n        }\n\n    }\n\n        // 判断是否还有没有访问过的本来存在的点\n        bool flag=false;\n        for(int i = 25;i>=0;--i){\n           // 本来有这个点才去判断\n           if(Node[i].isExit){\n                if(!Node[i].isused){\n                    flag =true;\n                    break;\n                }\n           }\n        }\n        \n        if(flag){\n            cout<<\"-1\"<<endl;\n        }else{\n            for(int i = 0;i<cnt;++i){\n                cout<<ans[i];\n            }\n            cout<<endl;\n        }\n   \n    }\n\n}\n```\n\n","source":"_posts/USST题解报告.md","raw":"---\ntitle: USST题解报告\ndate: 2021-06-25 16:44:06\ncatagories:\n  - 题解报告\n---\n# 上海理工校赛题解报告\n\n## 小结\n数学题，不会\n\n## B题 [Bheith i ngra le](https://ac.nowcoder.com/acm/contest/17574/B)\n当初挣扎了一下，然后不会求给定i行j列的格子有多少单调曲线，就放弃了。\n\n## 分析\n* 题目的核心是是求给定i行j列的格子能够构造多少调单调曲线。可以用dp或者组合求解，不喜欢数学的我毅然投奔了dp。  \n* 不难发现，当给定了宽为i，高为j的格子矩阵的时候，我们分析右上角那块，如果这块不画，那么所有情况就会变成dp[i][j-1],如果这块画上，那么情况就会是dp[i-1][j]。则得到状态转移方程dp[i][j]=dp[i][j-1]+dp[i-1][j]。当然，边界条件还是值得考虑一下的。\n* 算出dp数组后，性高彩烈的用n<sup>3</sup>去套老鹅。其实我们确定了山顶左边位置l之后不用去确定右边的r，dp[n-l][h]就是右边包含山顶在内的全部可能。所以ans=ans+dp[l-1][h-1]*dp[n-l][h]即可。\n```c++\n#include<iostream>\nusing namespace std;\nlong long dp[2003][2003];\nlong long mod=1e9+7;\nlong long ans;\nint main(){\n\tint n,m;\n\tcin >>n>>m;\n    // 初始化高度为1时\n\tdp[1][1]=2;\n\tfor(int i = 2;i<=n;++i){\n\t\tdp[i][1]=dp[i-1][1]+1;\n\t}\n\t// 初始化宽度为1的时候\n\tfor(int j = 2;j<=m;++j){\n\t\tdp[1][j]=dp[1][j-1]+1;\n\t} \n    // 求dp，i为宽，j为高\n\tfor(int i = 2;i<=n;++i){\n\t\tfor(int j = 2;j<=m;++j){\n           dp[i][j]=(dp[i][j-1]+dp[i-1][j])%mod;\n\t\t}\n\t}\n\t\n\t// 宽度为0时答案应该为1，因为下面用的乘法\n\tfor(int j=0;j<=m;++j){\n\t\tdp[0][j]=1;\n\t} \n\n   // 高度为0时，也应该是1，即取0\n   for(int i = 0;i<=n;++i){\n\t   dp[i][0]=1;\n   }\n\t\n\t// cout<<dp[1][1]<<endl<<dp[2][1]<<endl<<dp[1][2]<<endl<<dp[2][2]<<endl<<dp[1][3]<<endl<<dp[2][3]<<endl; \n\n\t// 枚举山顶的情况,l是左边，r是右边，h是山高\n\tfor(int l = 1;l<=n;++l){\n\t\t\tfor(int h = 1;h<=m;++h){\n               ans = (ans+(dp[l-1][h-1]*dp[n-l][h])%mod)%mod;   // 是左边的情况乘以右边的情况\n\t\t\t}\n\t}\n\t\n\t// 加上山顶全为0的情况，只有一种\n\t ans=(ans+1)%mod;\n\n\tcout<<ans<<endl;\n}\n```\n\n## J题 [JXC&JESUS](https://ac.nowcoder.com/acm/contest/17574/J)\n这是一个数学题\n## 分析\n题目大概的意思是定义了一个函数  \n$$f(i,m)=p_{1}^{ \\lfloor\\frac{a1}{m}  \\rfloor}*p_{2}^{a_2} * ... * p^{k}_ {a^k}$$   \n其中p<sub>1</sub>,p<sub>2</sub> ...p<sub>k</sub>为i的质因数。给定参数n,m,L求  \n$$\\sum\\limits_{i=L+1}^{L+n}-f(i,m)$$\n这关系到i的质因数的问题，可以用线性筛求质因数。又f(i,m)只和m与其最小质因子有关，我们在线性筛的时候合数也是被其最小质因子筛掉。所以想到从线性筛的基础上进行状态转移，由小的质数推出合数的f(i,m)，从而使求答案也变成线性。另一种是求出了素数之后直接暴力，也能过。  \n根据以下算法枚举&nbsp;i&nbsp;进行计算\n* 当i是质数的时候，当m=1时，f[i]=i,否则f[i]=1。（注意：1不是质因数）  \n* 枚举质数prime[j]利用i对i*prime[j]进行推算。\n   * 当prime[j]不能整除i时，则prime[j]是$i\\ast prime[j]$的最小质因子，且只有一个，$cnt[i\\ast prime[j]]=1$。当m&nbsp;=&nbsp;1时，$f[i\\ast prime[j]]=i\\ast prime[j]$,否则$f[i\\ast prime[j]]=i$。(因为此时$\\lfloor  \\frac{a1}{m}  \\rfloor$为0)\n   * 当prime[j]能整除i时，则prime[j]也是i的最小质因子，此时$cnt[i\\ast prime[j]]=cnt[i]+1$。当$cnt[i \\ast prime[j]]\\%m=0$ 时，$f[i\\ast prime[j]]=i\\ast prime[j]$,否则$f[i\\ast prime[j]]=i$。（此时应该枚举新的i，就如线性筛那样。）  \n\n```c++\n#include <iostream>\n#include<cstring>\nusing namespace std;\n#define MAX 20000003\nint prime[MAX];   // 存素数\nbool isprime[MAX]; // 判断是否素数\nint n,m,L;\nint ans=0;   // 存放答案\nint cnt[MAX]; // 存放最小质因数的个数\nint CNT=1;\nint f[MAX];  // f存起来，因为可能提前求得\nint minp[MAX]; // 记录合数的最小质因子\n\n// 求素数\nvoid calPrime(){\n    prime[0]=1;\n    isprime[0]=isprime[1]=isprime[2]=true;\n    for(int i = 2;i<=MAX;++i){\n        if(isprime[i]){\n            prime[CNT++]=i;\n        }\n        // 将i的倍数标记为合数，合数只会被其最小质因子标记，所以很方便可求出最小质因子\n        for(int j = 1;j<CNT&&i*prime[j]<=MAX;++j){\n            isprime[i*prime[j]]=false;\n            // 如果i能够整除prime[j]，则退出\n            if(i%prime[j]==0){\n                break;\n            }\n        }\n    }\n}\n// 直接求f\nvoid  F(){\n    for(int i =2;i<=L+n;++i){\n       \n        // i是质数的情况,其最小质因数为其本身,则根据m讨论f\n        if(isprime[i]){\n            if(m==1){\n                f[i]=i;\n                cnt[i]=1;\n            }else{\n                f[i]=1;\n                cnt[i]=1;\n            }\n        }\n        // i不是质数的情况,枚举质数，不包括1\n        for(int j = 1;j<CNT&&i*prime[j]<=L+n;++j){\n            // 如果i不能整除prime[j],此时prime[j]是i*prime[j]的最小质因子，因为i非质数\n           if(i%prime[j]!=0){  \n               if(m==1){\n                   f[i*prime[j]]=i*prime[j];\n               }else{   //m!=1时，最最小质因数就无贡献了\n                   f[i*prime[j]]=i;\n               }\n               cnt[i*prime[j]]=1;\n           }else{ // 如果prime[j]能整除当前的i，则prime[j]也是i的最小质因子\n               cnt[i*prime[j]]=cnt[i]+1;\n               // 只有当cnt是m的倍数的时候，prime[j]才有贡献\n               if(cnt[i*prime[j]]%m==0){  \n                   f[i*prime[j]]=f[i]*prime[j];\n               }else{\n                   f[i*prime[j]]=f[i];\n               }\n               break;\n               \n           }\n        }\n    }\n}\n\nint main(){\n    memset(isprime,true,sizeof(isprime));\n    memset(cnt,1,sizeof(cnt));\n    memset(f,0,sizeof(f));\n    cin>>n>>m>>L;\n    calPrime(); //求素数\n    F();\n    for(int i = L+1;i<=L+n;++i){\n        ans+=i-f[i];\n    }\n    cout<<ans<<endl;\n}\n```\n\n## M题 [Minecraft](https://ac.nowcoder.com/acm/contest/17574/M)\n这题挺简单，毕竟人家说了时签到题，不过这个输入格式确实有点费脑。\n\n## 分析\n根据题目，差不多重点就是下面\n* 每次从房子的每根“柱子”最底下建起方块(因为不能流沙)。\n* 每次选定一个字母之后所以该字母的位置都要建方块！  \n* 最后要以最大字典序输出！  \n\n可以通过有向图和拓扑排序解决，先填充入度为0的字母，然后更新图，如果全部入度为0的都已经访问了还有入度不为0，就重建失败。  \n对于字典序问题，没有用优先队列，直接在while里面套一个for即可，并且要从字母Z遍历到A，特别注意的是，一旦找到一个字母后，要重新进行for循环，不然达不到字典序。就因为这个卡88.9%给我整吐了。\n\n``` c++\n#include<iostream>\n#include<cstring>\nusing namespace std;\n#define MAX 27     \nint t;   // 测试数\nint n,m,h;  // 长宽高\nint let[35][35][35];   // 在房子某个坐标的字母,用int存\nchar c;\ntypedef struct NODE{\n    int in=0;   // 入度\n    int out=0;  // 出度\n    int next[30000];  // 连接的下一个点，注意点的个数\n    bool isused=false;  // 记录是否已经访问过 \n    bool isExit=false;\n}NODE;\nchar ans[MAX]; // 存放答案的字母\nint  cnt=0;   // 答案中共有多少个字母\nNODE Node[MAX];    // 设置结点\nint main(){\n    //freopen(\"test/USSTM.txt\",\"r\",stdin);\n    cin>>t;\n    while(t--){\n        // 每次开始的时候记得还原\n\n        cnt=0;\n        c=0;\n        for(int i = 0;i<MAX;++i){\n            Node[i].in=0;\n            Node[i].isExit=false;\n            Node[i].isused=false;\n            Node[i].out=0;\n        }\n        cin>>n>>m>>h;\n        if(n==0||m==0||h==0){\n            cout<<\"-1\"<<endl;\n            continue;\n        }\n\n       // 输入考了一波理解\n        for(int k = h-1;k>=0;--k){\n        for(int i = 0;i<n;++i){\n            for(int j = 0;j<m;++j){\n                \n                cin>>c;\n               let[i][j][k]=(int)c-'A';\n               Node[let[i][j][k]].isExit=true;\n               \n            }\n         }\n         \n        }\n\n\n        // 开始构造图\n        for(int k = 1;k<h;++k){\n        for(int i = 0;i<n;++i){\n            for(int j = 0;j<m;++j){\n                // 如果和下面的不相等，则要生成边\n                if(let[i][j][k]!=let[i][j][k-1]){\n                    int tempU=let[i][j][k];\n                    int tempL=let[i][j][k-1];\n                    Node[tempU].in++;\n                    Node[tempL].next[Node[tempL].out++]=tempU;\n                }\n            }\n        }\n    }\n\n        bool canUsed=true;    // 记录能否找到入度为0且没有访问过的结点\n\n        while(canUsed){\n        canUsed=false;\n        // 从字母大的找起,这里就不用优先队列了\n        for(int i = 25;i>=0;--i){\n           // 本来有这个点才去判断\n           if(Node[i].isExit){\n                // 入度为0且没有访问过\n                if(Node[i].in==0&&!Node[i].isused){\n                    canUsed=true;\n                    ans[cnt++]=char(i+'A');\n                    // 更新结点状态,并更新其连接的边的状态\n                     Node[i].isused=true; \n                    for(int j = 0;j<Node[i].out;++j){\n                         Node[Node[i].next[j]].in--;\n                    }\n\n                    // 找到一个之后，一定要重新再来，不然达不到字典序\n                    break;\n                }\n           }\n        }\n\n    }\n\n        // 判断是否还有没有访问过的本来存在的点\n        bool flag=false;\n        for(int i = 25;i>=0;--i){\n           // 本来有这个点才去判断\n           if(Node[i].isExit){\n                if(!Node[i].isused){\n                    flag =true;\n                    break;\n                }\n           }\n        }\n        \n        if(flag){\n            cout<<\"-1\"<<endl;\n        }else{\n            for(int i = 0;i<cnt;++i){\n                cout<<ans[i];\n            }\n            cout<<endl;\n        }\n   \n    }\n\n}\n```\n\n","slug":"USST题解报告","published":1,"updated":"2021-07-15T16:45:17.545Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckr74cdsu000b40tk7ucw7bum","content":"<h1 id=\"上海理工校赛题解报告\"><a href=\"#上海理工校赛题解报告\" class=\"headerlink\" title=\"上海理工校赛题解报告\"></a>上海理工校赛题解报告</h1><h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>数学题，不会</p>\n<h2 id=\"B题-Bheith-i-ngra-le\"><a href=\"#B题-Bheith-i-ngra-le\" class=\"headerlink\" title=\"B题 Bheith i ngra le\"></a>B题 <a href=\"https://ac.nowcoder.com/acm/contest/17574/B\">Bheith i ngra le</a></h2><p>当初挣扎了一下，然后不会求给定i行j列的格子有多少单调曲线，就放弃了。</p>\n<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><ul>\n<li>题目的核心是是求给定i行j列的格子能够构造多少调单调曲线。可以用dp或者组合求解，不喜欢数学的我毅然投奔了dp。  </li>\n<li>不难发现，当给定了宽为i，高为j的格子矩阵的时候，我们分析右上角那块，如果这块不画，那么所有情况就会变成dp[i][j-1],如果这块画上，那么情况就会是dp[i-1][j]。则得到状态转移方程dp[i][j]=dp[i][j-1]+dp[i-1][j]。当然，边界条件还是值得考虑一下的。</li>\n<li>算出dp数组后，性高彩烈的用n<sup>3</sup>去套老鹅。其实我们确定了山顶左边位置l之后不用去确定右边的r，dp[n-l][h]就是右边包含山顶在内的全部可能。所以ans=ans+dp[l-1][h-1]*dp[n-l][h]即可。<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> dp[<span class=\"number\">2003</span>][<span class=\"number\">2003</span>];</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> mod=<span class=\"number\">1e9</span>+<span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ans;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n,m;</span><br><span class=\"line\">\tcin &gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化高度为1时</span></span><br><span class=\"line\">\tdp[<span class=\"number\">1</span>][<span class=\"number\">1</span>]=<span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>;i&lt;=n;++i)&#123;</span><br><span class=\"line\">\t\tdp[i][<span class=\"number\">1</span>]=dp[i<span class=\"number\">-1</span>][<span class=\"number\">1</span>]+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 初始化宽度为1的时候</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">2</span>;j&lt;=m;++j)&#123;</span><br><span class=\"line\">\t\tdp[<span class=\"number\">1</span>][j]=dp[<span class=\"number\">1</span>][j<span class=\"number\">-1</span>]+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\">    <span class=\"comment\">// 求dp，i为宽，j为高</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>;i&lt;=n;++i)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">2</span>;j&lt;=m;++j)&#123;</span><br><span class=\"line\">           dp[i][j]=(dp[i][j<span class=\"number\">-1</span>]+dp[i<span class=\"number\">-1</span>][j])%mod;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 宽度为0时答案应该为1，因为下面用的乘法</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;=m;++j)&#123;</span><br><span class=\"line\">\t\tdp[<span class=\"number\">0</span>][j]=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 高度为0时，也应该是1，即取0</span></span><br><span class=\"line\">   <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;=n;++i)&#123;</span><br><span class=\"line\">\t   dp[i][<span class=\"number\">0</span>]=<span class=\"number\">1</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;dp[1][1]&lt;&lt;endl&lt;&lt;dp[2][1]&lt;&lt;endl&lt;&lt;dp[1][2]&lt;&lt;endl&lt;&lt;dp[2][2]&lt;&lt;endl&lt;&lt;dp[1][3]&lt;&lt;endl&lt;&lt;dp[2][3]&lt;&lt;endl; </span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 枚举山顶的情况,l是左边，r是右边，h是山高</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> l = <span class=\"number\">1</span>;l&lt;=n;++l)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> h = <span class=\"number\">1</span>;h&lt;=m;++h)&#123;</span><br><span class=\"line\">               ans = (ans+(dp[l<span class=\"number\">-1</span>][h<span class=\"number\">-1</span>]*dp[n-l][h])%mod)%mod;   <span class=\"comment\">// 是左边的情况乘以右边的情况</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 加上山顶全为0的情况，只有一种</span></span><br><span class=\"line\">\t ans=(ans+<span class=\"number\">1</span>)%mod;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"J题-JXC-amp-JESUS\"><a href=\"#J题-JXC-amp-JESUS\" class=\"headerlink\" title=\"J题 JXC&amp;JESUS\"></a>J题 <a href=\"https://ac.nowcoder.com/acm/contest/17574/J\">JXC&amp;JESUS</a></h2><p>这是一个数学题</p>\n<h2 id=\"分析-1\"><a href=\"#分析-1\" class=\"headerlink\" title=\"分析\"></a>分析</h2><p>题目大概的意思是定义了一个函数  </p>\n<script type=\"math/tex; mode=display\">f(i,m)=p_{1}^{ \\lfloor\\frac{a1}{m}  \\rfloor}*p_{2}^{a_2} * ... * p^{k}_ {a^k}</script><p>其中p<sub>1</sub>,p<sub>2</sub> …p<sub>k</sub>为i的质因数。给定参数n,m,L求  </p>\n<script type=\"math/tex; mode=display\">\\sum\\limits_{i=L+1}^{L+n}-f(i,m)</script><p>这关系到i的质因数的问题，可以用线性筛求质因数。又f(i,m)只和m与其最小质因子有关，我们在线性筛的时候合数也是被其最小质因子筛掉。所以想到从线性筛的基础上进行状态转移，由小的质数推出合数的f(i,m)，从而使求答案也变成线性。另一种是求出了素数之后直接暴力，也能过。<br>根据以下算法枚举&nbsp;i&nbsp;进行计算</p>\n<ul>\n<li>当i是质数的时候，当m=1时，f[i]=i,否则f[i]=1。（注意：1不是质因数）  </li>\n<li>枚举质数prime[j]利用i对i*prime[j]进行推算。<ul>\n<li>当prime[j]不能整除i时，则prime[j]是$i\\ast prime[j]$的最小质因子，且只有一个，$cnt[i\\ast prime[j]]=1$。当m&nbsp;=&nbsp;1时，$f[i\\ast prime[j]]=i\\ast prime[j]$,否则$f[i\\ast prime[j]]=i$。(因为此时$\\lfloor  \\frac{a1}{m}  \\rfloor$为0)</li>\n<li>当prime[j]能整除i时，则prime[j]也是i的最小质因子，此时$cnt[i\\ast prime[j]]=cnt[i]+1$。当$cnt[i \\ast prime[j]]\\%m=0$ 时，$f[i\\ast prime[j]]=i\\ast prime[j]$,否则$f[i\\ast prime[j]]=i$。（此时应该枚举新的i，就如线性筛那样。）  </li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAX 20000003</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> prime[MAX];   <span class=\"comment\">// 存素数</span></span><br><span class=\"line\"><span class=\"keyword\">bool</span> isprime[MAX]; <span class=\"comment\">// 判断是否素数</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m,L;</span><br><span class=\"line\"><span class=\"keyword\">int</span> ans=<span class=\"number\">0</span>;   <span class=\"comment\">// 存放答案</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> cnt[MAX]; <span class=\"comment\">// 存放最小质因数的个数</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> CNT=<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> f[MAX];  <span class=\"comment\">// f存起来，因为可能提前求得</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> minp[MAX]; <span class=\"comment\">// 记录合数的最小质因子</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 求素数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">calPrime</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    prime[<span class=\"number\">0</span>]=<span class=\"number\">1</span>;</span><br><span class=\"line\">    isprime[<span class=\"number\">0</span>]=isprime[<span class=\"number\">1</span>]=isprime[<span class=\"number\">2</span>]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>;i&lt;=MAX;++i)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(isprime[i])&#123;</span><br><span class=\"line\">            prime[CNT++]=i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 将i的倍数标记为合数，合数只会被其最小质因子标记，所以很方便可求出最小质因子</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;j&lt;CNT&amp;&amp;i*prime[j]&lt;=MAX;++j)&#123;</span><br><span class=\"line\">            isprime[i*prime[j]]=<span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 如果i能够整除prime[j]，则退出</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i%prime[j]==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 直接求f</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span>  <span class=\"title\">F</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i =<span class=\"number\">2</span>;i&lt;=L+n;++i)&#123;</span><br><span class=\"line\">       </span><br><span class=\"line\">        <span class=\"comment\">// i是质数的情况,其最小质因数为其本身,则根据m讨论f</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(isprime[i])&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(m==<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                f[i]=i;</span><br><span class=\"line\">                cnt[i]=<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                f[i]=<span class=\"number\">1</span>;</span><br><span class=\"line\">                cnt[i]=<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// i不是质数的情况,枚举质数，不包括1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;j&lt;CNT&amp;&amp;i*prime[j]&lt;=L+n;++j)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果i不能整除prime[j],此时prime[j]是i*prime[j]的最小质因子，因为i非质数</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span>(i%prime[j]!=<span class=\"number\">0</span>)&#123;  </span><br><span class=\"line\">               <span class=\"keyword\">if</span>(m==<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                   f[i*prime[j]]=i*prime[j];</span><br><span class=\"line\">               &#125;<span class=\"keyword\">else</span>&#123;   <span class=\"comment\">//m!=1时，最最小质因数就无贡献了</span></span><br><span class=\"line\">                   f[i*prime[j]]=i;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">               cnt[i*prime[j]]=<span class=\"number\">1</span>;</span><br><span class=\"line\">           &#125;<span class=\"keyword\">else</span>&#123; <span class=\"comment\">// 如果prime[j]能整除当前的i，则prime[j]也是i的最小质因子</span></span><br><span class=\"line\">               cnt[i*prime[j]]=cnt[i]+<span class=\"number\">1</span>;</span><br><span class=\"line\">               <span class=\"comment\">// 只有当cnt是m的倍数的时候，prime[j]才有贡献</span></span><br><span class=\"line\">               <span class=\"keyword\">if</span>(cnt[i*prime[j]]%m==<span class=\"number\">0</span>)&#123;  </span><br><span class=\"line\">                   f[i*prime[j]]=f[i]*prime[j];</span><br><span class=\"line\">               &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                   f[i*prime[j]]=f[i];</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">               </span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(isprime,<span class=\"literal\">true</span>,<span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(isprime));</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(cnt,<span class=\"number\">1</span>,<span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(cnt));</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(f,<span class=\"number\">0</span>,<span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(f));</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;L;</span><br><span class=\"line\">    <span class=\"built_in\">calPrime</span>(); <span class=\"comment\">//求素数</span></span><br><span class=\"line\">    <span class=\"built_in\">F</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = L+<span class=\"number\">1</span>;i&lt;=L+n;++i)&#123;</span><br><span class=\"line\">        ans+=i-f[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"M题-Minecraft\"><a href=\"#M题-Minecraft\" class=\"headerlink\" title=\"M题 Minecraft\"></a>M题 <a href=\"https://ac.nowcoder.com/acm/contest/17574/M\">Minecraft</a></h2><p>这题挺简单，毕竟人家说了时签到题，不过这个输入格式确实有点费脑。</p>\n<h2 id=\"分析-2\"><a href=\"#分析-2\" class=\"headerlink\" title=\"分析\"></a>分析</h2><p>根据题目，差不多重点就是下面</p>\n<ul>\n<li>每次从房子的每根“柱子”最底下建起方块(因为不能流沙)。</li>\n<li>每次选定一个字母之后所以该字母的位置都要建方块！  </li>\n<li>最后要以最大字典序输出！  </li>\n</ul>\n<p>可以通过有向图和拓扑排序解决，先填充入度为0的字母，然后更新图，如果全部入度为0的都已经访问了还有入度不为0，就重建失败。<br>对于字典序问题，没有用优先队列，直接在while里面套一个for即可，并且要从字母Z遍历到A，特别注意的是，一旦找到一个字母后，要重新进行for循环，不然达不到字典序。就因为这个卡88.9%给我整吐了。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAX 27     </span></span><br><span class=\"line\"><span class=\"keyword\">int</span> t;   <span class=\"comment\">// 测试数</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m,h;  <span class=\"comment\">// 长宽高</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> let[<span class=\"number\">35</span>][<span class=\"number\">35</span>][<span class=\"number\">35</span>];   <span class=\"comment\">// 在房子某个坐标的字母,用int存</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> c;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">NODE</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> in=<span class=\"number\">0</span>;   <span class=\"comment\">// 入度</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> out=<span class=\"number\">0</span>;  <span class=\"comment\">// 出度</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> next[<span class=\"number\">30000</span>];  <span class=\"comment\">// 连接的下一个点，注意点的个数</span></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> isused=<span class=\"literal\">false</span>;  <span class=\"comment\">// 记录是否已经访问过 </span></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> isExit=<span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;NODE;</span><br><span class=\"line\"><span class=\"keyword\">char</span> ans[MAX]; <span class=\"comment\">// 存放答案的字母</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>  cnt=<span class=\"number\">0</span>;   <span class=\"comment\">// 答案中共有多少个字母</span></span><br><span class=\"line\">NODE Node[MAX];    <span class=\"comment\">// 设置结点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//freopen(&quot;test/USSTM.txt&quot;,&quot;r&quot;,stdin);</span></span><br><span class=\"line\">    cin&gt;&gt;t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 每次开始的时候记得还原</span></span><br><span class=\"line\"></span><br><span class=\"line\">        cnt=<span class=\"number\">0</span>;</span><br><span class=\"line\">        c=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;MAX;++i)&#123;</span><br><span class=\"line\">            Node[i].in=<span class=\"number\">0</span>;</span><br><span class=\"line\">            Node[i].isExit=<span class=\"literal\">false</span>;</span><br><span class=\"line\">            Node[i].isused=<span class=\"literal\">false</span>;</span><br><span class=\"line\">            Node[i].out=<span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cin&gt;&gt;n&gt;&gt;m&gt;&gt;h;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n==<span class=\"number\">0</span>||m==<span class=\"number\">0</span>||h==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            cout&lt;&lt;<span class=\"string\">&quot;-1&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">// 输入考了一波理解</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = h<span class=\"number\">-1</span>;k&gt;=<span class=\"number\">0</span>;--k)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j&lt;m;++j)&#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">                cin&gt;&gt;c;</span><br><span class=\"line\">               let[i][j][k]=(<span class=\"keyword\">int</span>)c-<span class=\"string\">&#x27;A&#x27;</span>;</span><br><span class=\"line\">               Node[let[i][j][k]].isExit=<span class=\"literal\">true</span>;</span><br><span class=\"line\">               </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 开始构造图</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = <span class=\"number\">1</span>;k&lt;h;++k)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j&lt;m;++j)&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果和下面的不相等，则要生成边</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(let[i][j][k]!=let[i][j][k<span class=\"number\">-1</span>])&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> tempU=let[i][j][k];</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> tempL=let[i][j][k<span class=\"number\">-1</span>];</span><br><span class=\"line\">                    Node[tempU].in++;</span><br><span class=\"line\">                    Node[tempL].next[Node[tempL].out++]=tempU;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">bool</span> canUsed=<span class=\"literal\">true</span>;    <span class=\"comment\">// 记录能否找到入度为0且没有访问过的结点</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(canUsed)&#123;</span><br><span class=\"line\">        canUsed=<span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 从字母大的找起,这里就不用优先队列了</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">25</span>;i&gt;=<span class=\"number\">0</span>;--i)&#123;</span><br><span class=\"line\">           <span class=\"comment\">// 本来有这个点才去判断</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span>(Node[i].isExit)&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 入度为0且没有访问过</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(Node[i].in==<span class=\"number\">0</span>&amp;&amp;!Node[i].isused)&#123;</span><br><span class=\"line\">                    canUsed=<span class=\"literal\">true</span>;</span><br><span class=\"line\">                    ans[cnt++]=<span class=\"built_in\"><span class=\"keyword\">char</span></span>(i+<span class=\"string\">&#x27;A&#x27;</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// 更新结点状态,并更新其连接的边的状态</span></span><br><span class=\"line\">                     Node[i].isused=<span class=\"literal\">true</span>; </span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j&lt;Node[i].out;++j)&#123;</span><br><span class=\"line\">                         Node[Node[i].next[j]].in--;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// 找到一个之后，一定要重新再来，不然达不到字典序</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 判断是否还有没有访问过的本来存在的点</span></span><br><span class=\"line\">        <span class=\"keyword\">bool</span> flag=<span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">25</span>;i&gt;=<span class=\"number\">0</span>;--i)&#123;</span><br><span class=\"line\">           <span class=\"comment\">// 本来有这个点才去判断</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span>(Node[i].isExit)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(!Node[i].isused)&#123;</span><br><span class=\"line\">                    flag =<span class=\"literal\">true</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(flag)&#123;</span><br><span class=\"line\">            cout&lt;&lt;<span class=\"string\">&quot;-1&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;cnt;++i)&#123;</span><br><span class=\"line\">                cout&lt;&lt;ans[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cout&lt;&lt;endl;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"上海理工校赛题解报告\"><a href=\"#上海理工校赛题解报告\" class=\"headerlink\" title=\"上海理工校赛题解报告\"></a>上海理工校赛题解报告</h1><h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>数学题，不会</p>\n<h2 id=\"B题-Bheith-i-ngra-le\"><a href=\"#B题-Bheith-i-ngra-le\" class=\"headerlink\" title=\"B题 Bheith i ngra le\"></a>B题 <a href=\"https://ac.nowcoder.com/acm/contest/17574/B\">Bheith i ngra le</a></h2><p>当初挣扎了一下，然后不会求给定i行j列的格子有多少单调曲线，就放弃了。</p>\n<h2 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h2><ul>\n<li>题目的核心是是求给定i行j列的格子能够构造多少调单调曲线。可以用dp或者组合求解，不喜欢数学的我毅然投奔了dp。  </li>\n<li>不难发现，当给定了宽为i，高为j的格子矩阵的时候，我们分析右上角那块，如果这块不画，那么所有情况就会变成dp[i][j-1],如果这块画上，那么情况就会是dp[i-1][j]。则得到状态转移方程dp[i][j]=dp[i][j-1]+dp[i-1][j]。当然，边界条件还是值得考虑一下的。</li>\n<li>算出dp数组后，性高彩烈的用n<sup>3</sup>去套老鹅。其实我们确定了山顶左边位置l之后不用去确定右边的r，dp[n-l][h]就是右边包含山顶在内的全部可能。所以ans=ans+dp[l-1][h-1]*dp[n-l][h]即可。<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> dp[<span class=\"number\">2003</span>][<span class=\"number\">2003</span>];</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> mod=<span class=\"number\">1e9</span>+<span class=\"number\">7</span>;</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ans;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n,m;</span><br><span class=\"line\">\tcin &gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化高度为1时</span></span><br><span class=\"line\">\tdp[<span class=\"number\">1</span>][<span class=\"number\">1</span>]=<span class=\"number\">2</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>;i&lt;=n;++i)&#123;</span><br><span class=\"line\">\t\tdp[i][<span class=\"number\">1</span>]=dp[i<span class=\"number\">-1</span>][<span class=\"number\">1</span>]+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"comment\">// 初始化宽度为1的时候</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">2</span>;j&lt;=m;++j)&#123;</span><br><span class=\"line\">\t\tdp[<span class=\"number\">1</span>][j]=dp[<span class=\"number\">1</span>][j<span class=\"number\">-1</span>]+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\">    <span class=\"comment\">// 求dp，i为宽，j为高</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>;i&lt;=n;++i)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">2</span>;j&lt;=m;++j)&#123;</span><br><span class=\"line\">           dp[i][j]=(dp[i][j<span class=\"number\">-1</span>]+dp[i<span class=\"number\">-1</span>][j])%mod;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 宽度为0时答案应该为1，因为下面用的乘法</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;=m;++j)&#123;</span><br><span class=\"line\">\t\tdp[<span class=\"number\">0</span>][j]=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 高度为0时，也应该是1，即取0</span></span><br><span class=\"line\">   <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;=n;++i)&#123;</span><br><span class=\"line\">\t   dp[i][<span class=\"number\">0</span>]=<span class=\"number\">1</span>;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// cout&lt;&lt;dp[1][1]&lt;&lt;endl&lt;&lt;dp[2][1]&lt;&lt;endl&lt;&lt;dp[1][2]&lt;&lt;endl&lt;&lt;dp[2][2]&lt;&lt;endl&lt;&lt;dp[1][3]&lt;&lt;endl&lt;&lt;dp[2][3]&lt;&lt;endl; </span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 枚举山顶的情况,l是左边，r是右边，h是山高</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> l = <span class=\"number\">1</span>;l&lt;=n;++l)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> h = <span class=\"number\">1</span>;h&lt;=m;++h)&#123;</span><br><span class=\"line\">               ans = (ans+(dp[l<span class=\"number\">-1</span>][h<span class=\"number\">-1</span>]*dp[n-l][h])%mod)%mod;   <span class=\"comment\">// 是左边的情况乘以右边的情况</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">// 加上山顶全为0的情况，只有一种</span></span><br><span class=\"line\">\t ans=(ans+<span class=\"number\">1</span>)%mod;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"J题-JXC-amp-JESUS\"><a href=\"#J题-JXC-amp-JESUS\" class=\"headerlink\" title=\"J题 JXC&amp;JESUS\"></a>J题 <a href=\"https://ac.nowcoder.com/acm/contest/17574/J\">JXC&amp;JESUS</a></h2><p>这是一个数学题</p>\n<h2 id=\"分析-1\"><a href=\"#分析-1\" class=\"headerlink\" title=\"分析\"></a>分析</h2><p>题目大概的意思是定义了一个函数  </p>\n<script type=\"math/tex; mode=display\">f(i,m)=p_{1}^{ \\lfloor\\frac{a1}{m}  \\rfloor}*p_{2}^{a_2} * ... * p^{k}_ {a^k}</script><p>其中p<sub>1</sub>,p<sub>2</sub> …p<sub>k</sub>为i的质因数。给定参数n,m,L求  </p>\n<script type=\"math/tex; mode=display\">\\sum\\limits_{i=L+1}^{L+n}-f(i,m)</script><p>这关系到i的质因数的问题，可以用线性筛求质因数。又f(i,m)只和m与其最小质因子有关，我们在线性筛的时候合数也是被其最小质因子筛掉。所以想到从线性筛的基础上进行状态转移，由小的质数推出合数的f(i,m)，从而使求答案也变成线性。另一种是求出了素数之后直接暴力，也能过。<br>根据以下算法枚举&nbsp;i&nbsp;进行计算</p>\n<ul>\n<li>当i是质数的时候，当m=1时，f[i]=i,否则f[i]=1。（注意：1不是质因数）  </li>\n<li>枚举质数prime[j]利用i对i*prime[j]进行推算。<ul>\n<li>当prime[j]不能整除i时，则prime[j]是$i\\ast prime[j]$的最小质因子，且只有一个，$cnt[i\\ast prime[j]]=1$。当m&nbsp;=&nbsp;1时，$f[i\\ast prime[j]]=i\\ast prime[j]$,否则$f[i\\ast prime[j]]=i$。(因为此时$\\lfloor  \\frac{a1}{m}  \\rfloor$为0)</li>\n<li>当prime[j]能整除i时，则prime[j]也是i的最小质因子，此时$cnt[i\\ast prime[j]]=cnt[i]+1$。当$cnt[i \\ast prime[j]]\\%m=0$ 时，$f[i\\ast prime[j]]=i\\ast prime[j]$,否则$f[i\\ast prime[j]]=i$。（此时应该枚举新的i，就如线性筛那样。）  </li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAX 20000003</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> prime[MAX];   <span class=\"comment\">// 存素数</span></span><br><span class=\"line\"><span class=\"keyword\">bool</span> isprime[MAX]; <span class=\"comment\">// 判断是否素数</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m,L;</span><br><span class=\"line\"><span class=\"keyword\">int</span> ans=<span class=\"number\">0</span>;   <span class=\"comment\">// 存放答案</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> cnt[MAX]; <span class=\"comment\">// 存放最小质因数的个数</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> CNT=<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> f[MAX];  <span class=\"comment\">// f存起来，因为可能提前求得</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> minp[MAX]; <span class=\"comment\">// 记录合数的最小质因子</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 求素数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">calPrime</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    prime[<span class=\"number\">0</span>]=<span class=\"number\">1</span>;</span><br><span class=\"line\">    isprime[<span class=\"number\">0</span>]=isprime[<span class=\"number\">1</span>]=isprime[<span class=\"number\">2</span>]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>;i&lt;=MAX;++i)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(isprime[i])&#123;</span><br><span class=\"line\">            prime[CNT++]=i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 将i的倍数标记为合数，合数只会被其最小质因子标记，所以很方便可求出最小质因子</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;j&lt;CNT&amp;&amp;i*prime[j]&lt;=MAX;++j)&#123;</span><br><span class=\"line\">            isprime[i*prime[j]]=<span class=\"literal\">false</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 如果i能够整除prime[j]，则退出</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i%prime[j]==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 直接求f</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span>  <span class=\"title\">F</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i =<span class=\"number\">2</span>;i&lt;=L+n;++i)&#123;</span><br><span class=\"line\">       </span><br><span class=\"line\">        <span class=\"comment\">// i是质数的情况,其最小质因数为其本身,则根据m讨论f</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(isprime[i])&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(m==<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                f[i]=i;</span><br><span class=\"line\">                cnt[i]=<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                f[i]=<span class=\"number\">1</span>;</span><br><span class=\"line\">                cnt[i]=<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// i不是质数的情况,枚举质数，不包括1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;j&lt;CNT&amp;&amp;i*prime[j]&lt;=L+n;++j)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 如果i不能整除prime[j],此时prime[j]是i*prime[j]的最小质因子，因为i非质数</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span>(i%prime[j]!=<span class=\"number\">0</span>)&#123;  </span><br><span class=\"line\">               <span class=\"keyword\">if</span>(m==<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                   f[i*prime[j]]=i*prime[j];</span><br><span class=\"line\">               &#125;<span class=\"keyword\">else</span>&#123;   <span class=\"comment\">//m!=1时，最最小质因数就无贡献了</span></span><br><span class=\"line\">                   f[i*prime[j]]=i;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">               cnt[i*prime[j]]=<span class=\"number\">1</span>;</span><br><span class=\"line\">           &#125;<span class=\"keyword\">else</span>&#123; <span class=\"comment\">// 如果prime[j]能整除当前的i，则prime[j]也是i的最小质因子</span></span><br><span class=\"line\">               cnt[i*prime[j]]=cnt[i]+<span class=\"number\">1</span>;</span><br><span class=\"line\">               <span class=\"comment\">// 只有当cnt是m的倍数的时候，prime[j]才有贡献</span></span><br><span class=\"line\">               <span class=\"keyword\">if</span>(cnt[i*prime[j]]%m==<span class=\"number\">0</span>)&#123;  </span><br><span class=\"line\">                   f[i*prime[j]]=f[i]*prime[j];</span><br><span class=\"line\">               &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                   f[i*prime[j]]=f[i];</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">               <span class=\"keyword\">break</span>;</span><br><span class=\"line\">               </span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(isprime,<span class=\"literal\">true</span>,<span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(isprime));</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(cnt,<span class=\"number\">1</span>,<span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(cnt));</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(f,<span class=\"number\">0</span>,<span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(f));</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;L;</span><br><span class=\"line\">    <span class=\"built_in\">calPrime</span>(); <span class=\"comment\">//求素数</span></span><br><span class=\"line\">    <span class=\"built_in\">F</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = L+<span class=\"number\">1</span>;i&lt;=L+n;++i)&#123;</span><br><span class=\"line\">        ans+=i-f[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"M题-Minecraft\"><a href=\"#M题-Minecraft\" class=\"headerlink\" title=\"M题 Minecraft\"></a>M题 <a href=\"https://ac.nowcoder.com/acm/contest/17574/M\">Minecraft</a></h2><p>这题挺简单，毕竟人家说了时签到题，不过这个输入格式确实有点费脑。</p>\n<h2 id=\"分析-2\"><a href=\"#分析-2\" class=\"headerlink\" title=\"分析\"></a>分析</h2><p>根据题目，差不多重点就是下面</p>\n<ul>\n<li>每次从房子的每根“柱子”最底下建起方块(因为不能流沙)。</li>\n<li>每次选定一个字母之后所以该字母的位置都要建方块！  </li>\n<li>最后要以最大字典序输出！  </li>\n</ul>\n<p>可以通过有向图和拓扑排序解决，先填充入度为0的字母，然后更新图，如果全部入度为0的都已经访问了还有入度不为0，就重建失败。<br>对于字典序问题，没有用优先队列，直接在while里面套一个for即可，并且要从字母Z遍历到A，特别注意的是，一旦找到一个字母后，要重新进行for循环，不然达不到字典序。就因为这个卡88.9%给我整吐了。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAX 27     </span></span><br><span class=\"line\"><span class=\"keyword\">int</span> t;   <span class=\"comment\">// 测试数</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m,h;  <span class=\"comment\">// 长宽高</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> let[<span class=\"number\">35</span>][<span class=\"number\">35</span>][<span class=\"number\">35</span>];   <span class=\"comment\">// 在房子某个坐标的字母,用int存</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> c;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">NODE</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> in=<span class=\"number\">0</span>;   <span class=\"comment\">// 入度</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> out=<span class=\"number\">0</span>;  <span class=\"comment\">// 出度</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> next[<span class=\"number\">30000</span>];  <span class=\"comment\">// 连接的下一个点，注意点的个数</span></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> isused=<span class=\"literal\">false</span>;  <span class=\"comment\">// 记录是否已经访问过 </span></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> isExit=<span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;NODE;</span><br><span class=\"line\"><span class=\"keyword\">char</span> ans[MAX]; <span class=\"comment\">// 存放答案的字母</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>  cnt=<span class=\"number\">0</span>;   <span class=\"comment\">// 答案中共有多少个字母</span></span><br><span class=\"line\">NODE Node[MAX];    <span class=\"comment\">// 设置结点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//freopen(&quot;test/USSTM.txt&quot;,&quot;r&quot;,stdin);</span></span><br><span class=\"line\">    cin&gt;&gt;t;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(t--)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 每次开始的时候记得还原</span></span><br><span class=\"line\"></span><br><span class=\"line\">        cnt=<span class=\"number\">0</span>;</span><br><span class=\"line\">        c=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;MAX;++i)&#123;</span><br><span class=\"line\">            Node[i].in=<span class=\"number\">0</span>;</span><br><span class=\"line\">            Node[i].isExit=<span class=\"literal\">false</span>;</span><br><span class=\"line\">            Node[i].isused=<span class=\"literal\">false</span>;</span><br><span class=\"line\">            Node[i].out=<span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cin&gt;&gt;n&gt;&gt;m&gt;&gt;h;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n==<span class=\"number\">0</span>||m==<span class=\"number\">0</span>||h==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            cout&lt;&lt;<span class=\"string\">&quot;-1&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">// 输入考了一波理解</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = h<span class=\"number\">-1</span>;k&gt;=<span class=\"number\">0</span>;--k)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j&lt;m;++j)&#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">                cin&gt;&gt;c;</span><br><span class=\"line\">               let[i][j][k]=(<span class=\"keyword\">int</span>)c-<span class=\"string\">&#x27;A&#x27;</span>;</span><br><span class=\"line\">               Node[let[i][j][k]].isExit=<span class=\"literal\">true</span>;</span><br><span class=\"line\">               </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 开始构造图</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = <span class=\"number\">1</span>;k&lt;h;++k)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j&lt;m;++j)&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果和下面的不相等，则要生成边</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(let[i][j][k]!=let[i][j][k<span class=\"number\">-1</span>])&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> tempU=let[i][j][k];</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> tempL=let[i][j][k<span class=\"number\">-1</span>];</span><br><span class=\"line\">                    Node[tempU].in++;</span><br><span class=\"line\">                    Node[tempL].next[Node[tempL].out++]=tempU;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">bool</span> canUsed=<span class=\"literal\">true</span>;    <span class=\"comment\">// 记录能否找到入度为0且没有访问过的结点</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(canUsed)&#123;</span><br><span class=\"line\">        canUsed=<span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 从字母大的找起,这里就不用优先队列了</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">25</span>;i&gt;=<span class=\"number\">0</span>;--i)&#123;</span><br><span class=\"line\">           <span class=\"comment\">// 本来有这个点才去判断</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span>(Node[i].isExit)&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 入度为0且没有访问过</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(Node[i].in==<span class=\"number\">0</span>&amp;&amp;!Node[i].isused)&#123;</span><br><span class=\"line\">                    canUsed=<span class=\"literal\">true</span>;</span><br><span class=\"line\">                    ans[cnt++]=<span class=\"built_in\"><span class=\"keyword\">char</span></span>(i+<span class=\"string\">&#x27;A&#x27;</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// 更新结点状态,并更新其连接的边的状态</span></span><br><span class=\"line\">                     Node[i].isused=<span class=\"literal\">true</span>; </span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j&lt;Node[i].out;++j)&#123;</span><br><span class=\"line\">                         Node[Node[i].next[j]].in--;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">// 找到一个之后，一定要重新再来，不然达不到字典序</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 判断是否还有没有访问过的本来存在的点</span></span><br><span class=\"line\">        <span class=\"keyword\">bool</span> flag=<span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">25</span>;i&gt;=<span class=\"number\">0</span>;--i)&#123;</span><br><span class=\"line\">           <span class=\"comment\">// 本来有这个点才去判断</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span>(Node[i].isExit)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(!Node[i].isused)&#123;</span><br><span class=\"line\">                    flag =<span class=\"literal\">true</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(flag)&#123;</span><br><span class=\"line\">            cout&lt;&lt;<span class=\"string\">&quot;-1&quot;</span>&lt;&lt;endl;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;cnt;++i)&#123;</span><br><span class=\"line\">                cout&lt;&lt;ans[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cout&lt;&lt;endl;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"sptingboot集成mybatis","date":"2021-03-30T04:23:17.000Z","catagories":["springboot"],"_content":"\n\n# SpringBoot集成mybatis\n\n\n> ### 添加依赖\n\n&emsp;&emsp;在pom.xml文件中添加MySQL驱动依赖和mybatis依赖,MySQL不用加版本号，继承了父类的版本号，也可以自己指定版本号。\n```\n<!--MySQL驱动-->\n\t\t<dependency>\n\t\t\t<groupId>mysql</groupId>\n\t\t\t<artifactId>mysql-connector-java</artifactId>\n\t\t</dependency>\n\n\n<!--MyBatis整合springboot框架的起步依赖-->\n\t\t<dependency>\n\t\t\t<groupId>org.mybatis.spring.boot</groupId>\n\t\t\t<artifactId>mybatis-spring-boot-starter</artifactId>\n\t\t\t<version>2.0.0</version>\n\t\t</dependency>\n```\n>### 属性设置\n&emsp;&emsp;在GeneratorMapper.xml文件中进行连接数据库的属性设置，设置完成后生成即可。","source":"_posts/sptingboot集成mybatis.md","raw":"---\ntitle: sptingboot集成mybatis\ndate: 2021-03-30 12:23:17\ncatagories:\n- springboot\ntags:\n- JAVA\n- SptingBoot\n- 数据库\n---\n\n\n# SpringBoot集成mybatis\n\n\n> ### 添加依赖\n\n&emsp;&emsp;在pom.xml文件中添加MySQL驱动依赖和mybatis依赖,MySQL不用加版本号，继承了父类的版本号，也可以自己指定版本号。\n```\n<!--MySQL驱动-->\n\t\t<dependency>\n\t\t\t<groupId>mysql</groupId>\n\t\t\t<artifactId>mysql-connector-java</artifactId>\n\t\t</dependency>\n\n\n<!--MyBatis整合springboot框架的起步依赖-->\n\t\t<dependency>\n\t\t\t<groupId>org.mybatis.spring.boot</groupId>\n\t\t\t<artifactId>mybatis-spring-boot-starter</artifactId>\n\t\t\t<version>2.0.0</version>\n\t\t</dependency>\n```\n>### 属性设置\n&emsp;&emsp;在GeneratorMapper.xml文件中进行连接数据库的属性设置，设置完成后生成即可。","slug":"sptingboot集成mybatis","published":1,"updated":"2021-07-15T10:15:26.479Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckr74cdsv000d40tkae3n4n9m","content":"<h1 id=\"SpringBoot集成mybatis\"><a href=\"#SpringBoot集成mybatis\" class=\"headerlink\" title=\"SpringBoot集成mybatis\"></a>SpringBoot集成mybatis</h1><blockquote>\n<h3 id=\"添加依赖\"><a href=\"#添加依赖\" class=\"headerlink\" title=\"添加依赖\"></a>添加依赖</h3></blockquote>\n<p>&emsp;&emsp;在pom.xml文件中添加MySQL驱动依赖和mybatis依赖,MySQL不用加版本号，继承了父类的版本号，也可以自己指定版本号。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--MySQL驱动--&gt;</span><br><span class=\"line\">\t\t&lt;dependency&gt;</span><br><span class=\"line\">\t\t\t&lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class=\"line\">\t\t\t&lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class=\"line\">\t\t&lt;&#x2F;dependency&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!--MyBatis整合springboot框架的起步依赖--&gt;</span><br><span class=\"line\">\t\t&lt;dependency&gt;</span><br><span class=\"line\">\t\t\t&lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;</span><br><span class=\"line\">\t\t\t&lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class=\"line\">\t\t\t&lt;version&gt;2.0.0&lt;&#x2F;version&gt;</span><br><span class=\"line\">\t\t&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<h3 id=\"属性设置\"><a href=\"#属性设置\" class=\"headerlink\" title=\"属性设置\"></a>属性设置</h3><p>&emsp;&emsp;在GeneratorMapper.xml文件中进行连接数据库的属性设置，设置完成后生成即可。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"SpringBoot集成mybatis\"><a href=\"#SpringBoot集成mybatis\" class=\"headerlink\" title=\"SpringBoot集成mybatis\"></a>SpringBoot集成mybatis</h1><blockquote>\n<h3 id=\"添加依赖\"><a href=\"#添加依赖\" class=\"headerlink\" title=\"添加依赖\"></a>添加依赖</h3></blockquote>\n<p>&emsp;&emsp;在pom.xml文件中添加MySQL驱动依赖和mybatis依赖,MySQL不用加版本号，继承了父类的版本号，也可以自己指定版本号。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--MySQL驱动--&gt;</span><br><span class=\"line\">\t\t&lt;dependency&gt;</span><br><span class=\"line\">\t\t\t&lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class=\"line\">\t\t\t&lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class=\"line\">\t\t&lt;&#x2F;dependency&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!--MyBatis整合springboot框架的起步依赖--&gt;</span><br><span class=\"line\">\t\t&lt;dependency&gt;</span><br><span class=\"line\">\t\t\t&lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;</span><br><span class=\"line\">\t\t\t&lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class=\"line\">\t\t\t&lt;version&gt;2.0.0&lt;&#x2F;version&gt;</span><br><span class=\"line\">\t\t&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<h3 id=\"属性设置\"><a href=\"#属性设置\" class=\"headerlink\" title=\"属性设置\"></a>属性设置</h3><p>&emsp;&emsp;在GeneratorMapper.xml文件中进行连接数据库的属性设置，设置完成后生成即可。</p>\n</blockquote>\n"},{"title":"在O(logn)的复杂度下两数组的混合中位数","date":"2021-04-10T15:32:41.000Z","_content":"### 题目 \n设X[ 0 : n - 1]和Y[ 0 : n – 1 ]为两个数组，每个数组中含有n个已排好序的数。找出X和Y的2n个数的中位数。要求：O(logn)时间内\n\n##### 解析\n要在O(logn)时间内求解，则自然想到分治算法。求解思路与如下：\n先分别求数组X和Y的两个中位数MedX和MedY。则会有以下情况\n* （1）MedX==MedY。则很明显MedX即是2n个数的中位数。因为两个数组是完全等长的，所以两个数组中位数两边的数的个数，也是完全一样的。\n\n* （2）MedX>MedY\n  * 如果n是奇数\n这种情况下，比X<sub>(n-1)/2+1</sub>,X<sub>(n-1)/2+2</sub>,...,X<sub>n-1</sub>小的数至少有n+1个，所以X<sub>(n-1)/2+1</sub>,X<sub>(n-1)/2+2</sub>,...,X<sub>n-1</sub>一定比中位数大。所以中位数不会在X<sub>(n-1)/2+1</sub>,X(n-1)/2+2</sub>,...,X<sub>n-1</sub>中。同样Y<sub>0</sub>,Y<sub>1</sub>,...,Y<sub>(n-1)/2-1</sub>一定比中位数小。所以中位数在X<sub>0</sub>,X<sub>1</sub>,...,X<sub>(n-1)/2</sub>和Y<sub>(n-1)/2</sub>,Y<sub>n/2+2</sub>,...,Y<sub>n-1</sub>中。则只需要考察X[0:(n-1)/2:n-1]和Y[0:(n-1)/2]。\n  * 如果n是偶数\n  则X<sub>(n-1)/2+2</sub>,X<sub>(n-1)/2+3</sub>,...,X<sub>n-1</sub>小的数至少有n+1个，所以X<sub>(n-1)/2+2</sub>,X<sub>(n-1)/2+3</sub>,...,X<sub>n-1</sub>一定比中位数大。同样Y<sub>0</sub>,Y<sub>1</sub>,...,Y<sub>(n-)/2-2</sub>一定比中位数小。则只需要考察X[0:(n-1)/2+1]和Y[(n-1)/2-1:n-1]。\n\n由于在中位数两边加上或减去任意等数量的数并不影响中位数的取值,所以上述方法成立。\n* （3）MedX<MedY\n这种情况和上面的同理\n\n分到最后每个数组只有两个元素，则不可以再分下去，利用X和Y的中位数用直接方法求解。\n  \n``` c++\n#include<iostream>\nusing namespace std;\n/*\n函数名：FindMedian\n功能：  求数组的某一区间的中位数\n参数：  double Z[]-所求数组，int zl-数组的最小下标，int zr-数组的最大下标\n返回值：double-中位数\n*/\ndouble FindMedian(double Z[],int zl,int zr){\n       if((zr-zl)%2==0){\n           return Z[(zr+zl)/2];\n       }else{\n           return (Z[(zr+zl)/2]+Z[(zr+zl)/2+1])/2;\n       }\n}\n/*\n函数名：FindMedian\n功能：  求分别有序数组X某一区间和有序数组Y某一区间的混合中位数\n参数：  int X[]-数组X，int xl-数组X要考察的最小下标，int xr-数组x要考察的最大下标\n返回值：double-混合中位数\n*/\ndouble FindMixMedian(double X[],int xl,int xr,double Y[],int yl,int yr){\n    \n    double MedX=FindMedian(X,xl,xr);// 求X考察区域的中位数\n    double MedY=FindMedian(Y,yl,yr);// 求y所考察区域的中位数\n    // 若两个中位数相等，则所求便是混合区间的中位数\n    if(abs(MedX-MedY)<0.00001){\n        return MedY;\n    }\n    // 若两边都只剩一个了，就取平均\n    if(xl==xr&&yl==yr){\n        return (X[xl]+Y[xl])/2;\n    }\n    // 若每个数组只剩两个，则讨论求出中位数\n    if(xr-xl+1==2&&yr-yl+1==2){\n        // 若MedX大，则X[xr]大于X[xl]和Y[YL],则判断X[xr]和Y[yr]\n        if(MedX>MedY){    \n            if(X[xr]>=Y[yr]){     // 若X[xr]>=Y[yr],则可以确定地关系是Y[yl]<=Y[yr]<=X[xr]\n                if(X[xl]<Y[yl]){  // X[xl]<Y[yl]<=Y[yr]<=X[xr] \n                    return ((Y[yl]+Y[yr])/2);\n                }else{            // Y[yl]<=Y[yr]<X[xl]<=X[xr]或 Y[yl]<=X[xl]<=Y[yr]<=X[xr]\n                    return ((X[xl]+Y[yr])/2);\n                }\n            }else{ // 如果X[xr]比Y[Yr]小，则X[xl]一定比Y[yl]大,则 Y[yl]<X[xl]<=X[xr]<Y[yr]\n             return MedX;\n            }\n        }\n        // 若MedY大，则与上面的对称\n        if(MedX<MedY){     \n            if(Y[yr]>=X[xr]){\n                if(Y[yl]<X[xl]){\n                    return ((X[xl]+X[xr])/2);\n                }else{    \n                    return ((Y[yl]+X[xr])/2);\n                }  \n            } else{\n                return MedY;\n            }\n         }\n\n    }\n    // 区间划分\n    if(MedX>MedY){   // MedX大时，X取小的部分，Y取大的部分\n        if((xl-xr+1)%2!=0){    // 若区间个数为奇数\n           return FindMixMedian(X,xl,(xl+xr)/2,Y,(yl+yr)/2,yr);\n        }else{\n           return FindMixMedian(X,xl,(xl+xr)/2+1,Y,(yl+yr)/2,yr);\n        }\n    }else{           // MedX小时，X取大的部分，Y取小的部分\n        if((xl-xr+1)%2!=0){    // 若区间个数为奇数\n           return FindMixMedian(X,(xl+xr)/2,xr,Y,yl,(yl+yr)/2);\n        }else{\n           return FindMixMedian(X,(xl+xr)/2,xr,Y,yl,(yl+yr)/2+1);\n        }\n    }\n}\nint main(){\n    freopen(\"input1.txt\",\"r\",stdin);\n    freopen(\"output1.txt\",\"w\",stdout);\n    int n;     // 数组X和Y中每个数组所含有的元素个数   \n    double X[202]; \n    double Y[202];\n    double ans;\n    cin>>n;\n    for(int i = 0;i<n;++i){\n        cin>>X[i];\n    }\n    for(int i = 0;i<n;++i){\n        cin>>Y[i];\n    }\n    ans = FindMixMedian(X,0,n-1,Y,0,n-1);\n    cout<<ans<<endl;\n}\n```","source":"_posts/在O-logn-的复杂度下两数组的混合中位数.md","raw":"---\ntitle: 在O(logn)的复杂度下两数组的混合中位数\ndate: 2021-04-10 23:32:41\ncategories:\n  -算法\ntags:\n  -分治法\n---\n### 题目 \n设X[ 0 : n - 1]和Y[ 0 : n – 1 ]为两个数组，每个数组中含有n个已排好序的数。找出X和Y的2n个数的中位数。要求：O(logn)时间内\n\n##### 解析\n要在O(logn)时间内求解，则自然想到分治算法。求解思路与如下：\n先分别求数组X和Y的两个中位数MedX和MedY。则会有以下情况\n* （1）MedX==MedY。则很明显MedX即是2n个数的中位数。因为两个数组是完全等长的，所以两个数组中位数两边的数的个数，也是完全一样的。\n\n* （2）MedX>MedY\n  * 如果n是奇数\n这种情况下，比X<sub>(n-1)/2+1</sub>,X<sub>(n-1)/2+2</sub>,...,X<sub>n-1</sub>小的数至少有n+1个，所以X<sub>(n-1)/2+1</sub>,X<sub>(n-1)/2+2</sub>,...,X<sub>n-1</sub>一定比中位数大。所以中位数不会在X<sub>(n-1)/2+1</sub>,X(n-1)/2+2</sub>,...,X<sub>n-1</sub>中。同样Y<sub>0</sub>,Y<sub>1</sub>,...,Y<sub>(n-1)/2-1</sub>一定比中位数小。所以中位数在X<sub>0</sub>,X<sub>1</sub>,...,X<sub>(n-1)/2</sub>和Y<sub>(n-1)/2</sub>,Y<sub>n/2+2</sub>,...,Y<sub>n-1</sub>中。则只需要考察X[0:(n-1)/2:n-1]和Y[0:(n-1)/2]。\n  * 如果n是偶数\n  则X<sub>(n-1)/2+2</sub>,X<sub>(n-1)/2+3</sub>,...,X<sub>n-1</sub>小的数至少有n+1个，所以X<sub>(n-1)/2+2</sub>,X<sub>(n-1)/2+3</sub>,...,X<sub>n-1</sub>一定比中位数大。同样Y<sub>0</sub>,Y<sub>1</sub>,...,Y<sub>(n-)/2-2</sub>一定比中位数小。则只需要考察X[0:(n-1)/2+1]和Y[(n-1)/2-1:n-1]。\n\n由于在中位数两边加上或减去任意等数量的数并不影响中位数的取值,所以上述方法成立。\n* （3）MedX<MedY\n这种情况和上面的同理\n\n分到最后每个数组只有两个元素，则不可以再分下去，利用X和Y的中位数用直接方法求解。\n  \n``` c++\n#include<iostream>\nusing namespace std;\n/*\n函数名：FindMedian\n功能：  求数组的某一区间的中位数\n参数：  double Z[]-所求数组，int zl-数组的最小下标，int zr-数组的最大下标\n返回值：double-中位数\n*/\ndouble FindMedian(double Z[],int zl,int zr){\n       if((zr-zl)%2==0){\n           return Z[(zr+zl)/2];\n       }else{\n           return (Z[(zr+zl)/2]+Z[(zr+zl)/2+1])/2;\n       }\n}\n/*\n函数名：FindMedian\n功能：  求分别有序数组X某一区间和有序数组Y某一区间的混合中位数\n参数：  int X[]-数组X，int xl-数组X要考察的最小下标，int xr-数组x要考察的最大下标\n返回值：double-混合中位数\n*/\ndouble FindMixMedian(double X[],int xl,int xr,double Y[],int yl,int yr){\n    \n    double MedX=FindMedian(X,xl,xr);// 求X考察区域的中位数\n    double MedY=FindMedian(Y,yl,yr);// 求y所考察区域的中位数\n    // 若两个中位数相等，则所求便是混合区间的中位数\n    if(abs(MedX-MedY)<0.00001){\n        return MedY;\n    }\n    // 若两边都只剩一个了，就取平均\n    if(xl==xr&&yl==yr){\n        return (X[xl]+Y[xl])/2;\n    }\n    // 若每个数组只剩两个，则讨论求出中位数\n    if(xr-xl+1==2&&yr-yl+1==2){\n        // 若MedX大，则X[xr]大于X[xl]和Y[YL],则判断X[xr]和Y[yr]\n        if(MedX>MedY){    \n            if(X[xr]>=Y[yr]){     // 若X[xr]>=Y[yr],则可以确定地关系是Y[yl]<=Y[yr]<=X[xr]\n                if(X[xl]<Y[yl]){  // X[xl]<Y[yl]<=Y[yr]<=X[xr] \n                    return ((Y[yl]+Y[yr])/2);\n                }else{            // Y[yl]<=Y[yr]<X[xl]<=X[xr]或 Y[yl]<=X[xl]<=Y[yr]<=X[xr]\n                    return ((X[xl]+Y[yr])/2);\n                }\n            }else{ // 如果X[xr]比Y[Yr]小，则X[xl]一定比Y[yl]大,则 Y[yl]<X[xl]<=X[xr]<Y[yr]\n             return MedX;\n            }\n        }\n        // 若MedY大，则与上面的对称\n        if(MedX<MedY){     \n            if(Y[yr]>=X[xr]){\n                if(Y[yl]<X[xl]){\n                    return ((X[xl]+X[xr])/2);\n                }else{    \n                    return ((Y[yl]+X[xr])/2);\n                }  \n            } else{\n                return MedY;\n            }\n         }\n\n    }\n    // 区间划分\n    if(MedX>MedY){   // MedX大时，X取小的部分，Y取大的部分\n        if((xl-xr+1)%2!=0){    // 若区间个数为奇数\n           return FindMixMedian(X,xl,(xl+xr)/2,Y,(yl+yr)/2,yr);\n        }else{\n           return FindMixMedian(X,xl,(xl+xr)/2+1,Y,(yl+yr)/2,yr);\n        }\n    }else{           // MedX小时，X取大的部分，Y取小的部分\n        if((xl-xr+1)%2!=0){    // 若区间个数为奇数\n           return FindMixMedian(X,(xl+xr)/2,xr,Y,yl,(yl+yr)/2);\n        }else{\n           return FindMixMedian(X,(xl+xr)/2,xr,Y,yl,(yl+yr)/2+1);\n        }\n    }\n}\nint main(){\n    freopen(\"input1.txt\",\"r\",stdin);\n    freopen(\"output1.txt\",\"w\",stdout);\n    int n;     // 数组X和Y中每个数组所含有的元素个数   \n    double X[202]; \n    double Y[202];\n    double ans;\n    cin>>n;\n    for(int i = 0;i<n;++i){\n        cin>>X[i];\n    }\n    for(int i = 0;i<n;++i){\n        cin>>Y[i];\n    }\n    ans = FindMixMedian(X,0,n-1,Y,0,n-1);\n    cout<<ans<<endl;\n}\n```","slug":"在O-logn-的复杂度下两数组的混合中位数","published":1,"updated":"2021-07-15T10:15:26.480Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckr74cdsw000f40tk8zsj4wrn","content":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p>设X[ 0 : n - 1]和Y[ 0 : n – 1 ]为两个数组，每个数组中含有n个已排好序的数。找出X和Y的2n个数的中位数。要求：O(logn)时间内</p>\n<h5 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h5><p>要在O(logn)时间内求解，则自然想到分治算法。求解思路与如下：<br>先分别求数组X和Y的两个中位数MedX和MedY。则会有以下情况</p>\n<ul>\n<li><p>（1）MedX==MedY。则很明显MedX即是2n个数的中位数。因为两个数组是完全等长的，所以两个数组中位数两边的数的个数，也是完全一样的。</p>\n</li>\n<li><p>（2）MedX&gt;MedY</p>\n<ul>\n<li>如果n是奇数<br>这种情况下，比X<sub>(n-1)/2+1</sub>,X<sub>(n-1)/2+2</sub>,…,X<sub>n-1</sub>小的数至少有n+1个，所以X<sub>(n-1)/2+1</sub>,X<sub>(n-1)/2+2</sub>,…,X<sub>n-1</sub>一定比中位数大。所以中位数不会在X<sub>(n-1)/2+1</sub>,X(n-1)/2+2&lt;/sub&gt;,…,X<sub>n-1</sub>中。同样Y<sub>0</sub>,Y<sub>1</sub>,…,Y<sub>(n-1)/2-1</sub>一定比中位数小。所以中位数在X<sub>0</sub>,X<sub>1</sub>,…,X<sub>(n-1)/2</sub>和Y<sub>(n-1)/2</sub>,Y<sub>n/2+2</sub>,…,Y<sub>n-1</sub>中。则只需要考察X[0:(n-1)/2:n-1]和Y[0:(n-1)/2]。</li>\n<li>如果n是偶数<br>则X<sub>(n-1)/2+2</sub>,X<sub>(n-1)/2+3</sub>,…,X<sub>n-1</sub>小的数至少有n+1个，所以X<sub>(n-1)/2+2</sub>,X<sub>(n-1)/2+3</sub>,…,X<sub>n-1</sub>一定比中位数大。同样Y<sub>0</sub>,Y<sub>1</sub>,…,Y<sub>(n-)/2-2</sub>一定比中位数小。则只需要考察X[0:(n-1)/2+1]和Y[(n-1)/2-1:n-1]。</li>\n</ul>\n</li>\n</ul>\n<p>由于在中位数两边加上或减去任意等数量的数并不影响中位数的取值,所以上述方法成立。</p>\n<ul>\n<li>（3）MedX&lt;MedY<br>这种情况和上面的同理</li>\n</ul>\n<p>分到最后每个数组只有两个元素，则不可以再分下去，利用X和Y的中位数用直接方法求解。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">函数名：FindMedian</span></span><br><span class=\"line\"><span class=\"comment\">功能：  求数组的某一区间的中位数</span></span><br><span class=\"line\"><span class=\"comment\">参数：  double Z[]-所求数组，int zl-数组的最小下标，int zr-数组的最大下标</span></span><br><span class=\"line\"><span class=\"comment\">返回值：double-中位数</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">FindMedian</span><span class=\"params\">(<span class=\"keyword\">double</span> Z[],<span class=\"keyword\">int</span> zl,<span class=\"keyword\">int</span> zr)</span></span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span>((zr-zl)%<span class=\"number\">2</span>==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> Z[(zr+zl)/<span class=\"number\">2</span>];</span><br><span class=\"line\">       &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">           <span class=\"built_in\"><span class=\"keyword\">return</span></span> (Z[(zr+zl)/<span class=\"number\">2</span>]+Z[(zr+zl)/<span class=\"number\">2</span>+<span class=\"number\">1</span>])/<span class=\"number\">2</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">函数名：FindMedian</span></span><br><span class=\"line\"><span class=\"comment\">功能：  求分别有序数组X某一区间和有序数组Y某一区间的混合中位数</span></span><br><span class=\"line\"><span class=\"comment\">参数：  int X[]-数组X，int xl-数组X要考察的最小下标，int xr-数组x要考察的最大下标</span></span><br><span class=\"line\"><span class=\"comment\">返回值：double-混合中位数</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">FindMixMedian</span><span class=\"params\">(<span class=\"keyword\">double</span> X[],<span class=\"keyword\">int</span> xl,<span class=\"keyword\">int</span> xr,<span class=\"keyword\">double</span> Y[],<span class=\"keyword\">int</span> yl,<span class=\"keyword\">int</span> yr)</span></span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">double</span> MedX=<span class=\"built_in\">FindMedian</span>(X,xl,xr);<span class=\"comment\">// 求X考察区域的中位数</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> MedY=<span class=\"built_in\">FindMedian</span>(Y,yl,yr);<span class=\"comment\">// 求y所考察区域的中位数</span></span><br><span class=\"line\">    <span class=\"comment\">// 若两个中位数相等，则所求便是混合区间的中位数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">abs</span>(MedX-MedY)&lt;<span class=\"number\">0.00001</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> MedY;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 若两边都只剩一个了，就取平均</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(xl==xr&amp;&amp;yl==yr)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (X[xl]+Y[xl])/<span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 若每个数组只剩两个，则讨论求出中位数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(xr-xl+<span class=\"number\">1</span>==<span class=\"number\">2</span>&amp;&amp;yr-yl+<span class=\"number\">1</span>==<span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 若MedX大，则X[xr]大于X[xl]和Y[YL],则判断X[xr]和Y[yr]</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(MedX&gt;MedY)&#123;    </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(X[xr]&gt;=Y[yr])&#123;     <span class=\"comment\">// 若X[xr]&gt;=Y[yr],则可以确定地关系是Y[yl]&lt;=Y[yr]&lt;=X[xr]</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(X[xl]&lt;Y[yl])&#123;  <span class=\"comment\">// X[xl]&lt;Y[yl]&lt;=Y[yr]&lt;=X[xr] </span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> ((Y[yl]+Y[yr])/<span class=\"number\">2</span>);</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;            <span class=\"comment\">// Y[yl]&lt;=Y[yr]&lt;X[xl]&lt;=X[xr]或 Y[yl]&lt;=X[xl]&lt;=Y[yr]&lt;=X[xr]</span></span><br><span class=\"line\">                    <span class=\"built_in\"><span class=\"keyword\">return</span></span> ((X[xl]+Y[yr])/<span class=\"number\">2</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123; <span class=\"comment\">// 如果X[xr]比Y[Yr]小，则X[xl]一定比Y[yl]大,则 Y[yl]&lt;X[xl]&lt;=X[xr]&lt;Y[yr]</span></span><br><span class=\"line\">             <span class=\"keyword\">return</span> MedX;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 若MedY大，则与上面的对称</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(MedX&lt;MedY)&#123;     </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(Y[yr]&gt;=X[xr])&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(Y[yl]&lt;X[xl])&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> ((X[xl]+X[xr])/<span class=\"number\">2</span>);</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;    </span><br><span class=\"line\">                    <span class=\"built_in\"><span class=\"keyword\">return</span></span> ((Y[yl]+X[xr])/<span class=\"number\">2</span>);</span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> MedY;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 区间划分</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(MedX&gt;MedY)&#123;   <span class=\"comment\">// MedX大时，X取小的部分，Y取大的部分</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>((xl-xr+<span class=\"number\">1</span>)%<span class=\"number\">2</span>!=<span class=\"number\">0</span>)&#123;    <span class=\"comment\">// 若区间个数为奇数</span></span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"built_in\">FindMixMedian</span>(X,xl,(xl+xr)/<span class=\"number\">2</span>,Y,(yl+yr)/<span class=\"number\">2</span>,yr);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"built_in\">FindMixMedian</span>(X,xl,(xl+xr)/<span class=\"number\">2</span>+<span class=\"number\">1</span>,Y,(yl+yr)/<span class=\"number\">2</span>,yr);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;           <span class=\"comment\">// MedX小时，X取大的部分，Y取小的部分</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>((xl-xr+<span class=\"number\">1</span>)%<span class=\"number\">2</span>!=<span class=\"number\">0</span>)&#123;    <span class=\"comment\">// 若区间个数为奇数</span></span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"built_in\">FindMixMedian</span>(X,(xl+xr)/<span class=\"number\">2</span>,xr,Y,yl,(yl+yr)/<span class=\"number\">2</span>);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"built_in\">FindMixMedian</span>(X,(xl+xr)/<span class=\"number\">2</span>,xr,Y,yl,(yl+yr)/<span class=\"number\">2</span>+<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">freopen</span>(<span class=\"string\">&quot;input1.txt&quot;</span>,<span class=\"string\">&quot;r&quot;</span>,stdin);</span><br><span class=\"line\">    <span class=\"built_in\">freopen</span>(<span class=\"string\">&quot;output1.txt&quot;</span>,<span class=\"string\">&quot;w&quot;</span>,stdout);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;     <span class=\"comment\">// 数组X和Y中每个数组所含有的元素个数   </span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> X[<span class=\"number\">202</span>]; </span><br><span class=\"line\">    <span class=\"keyword\">double</span> Y[<span class=\"number\">202</span>];</span><br><span class=\"line\">    <span class=\"keyword\">double</span> ans;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">        cin&gt;&gt;X[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">        cin&gt;&gt;Y[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ans = <span class=\"built_in\">FindMixMedian</span>(X,<span class=\"number\">0</span>,n<span class=\"number\">-1</span>,Y,<span class=\"number\">0</span>,n<span class=\"number\">-1</span>);</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h3><p>设X[ 0 : n - 1]和Y[ 0 : n – 1 ]为两个数组，每个数组中含有n个已排好序的数。找出X和Y的2n个数的中位数。要求：O(logn)时间内</p>\n<h5 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h5><p>要在O(logn)时间内求解，则自然想到分治算法。求解思路与如下：<br>先分别求数组X和Y的两个中位数MedX和MedY。则会有以下情况</p>\n<ul>\n<li><p>（1）MedX==MedY。则很明显MedX即是2n个数的中位数。因为两个数组是完全等长的，所以两个数组中位数两边的数的个数，也是完全一样的。</p>\n</li>\n<li><p>（2）MedX&gt;MedY</p>\n<ul>\n<li>如果n是奇数<br>这种情况下，比X<sub>(n-1)/2+1</sub>,X<sub>(n-1)/2+2</sub>,…,X<sub>n-1</sub>小的数至少有n+1个，所以X<sub>(n-1)/2+1</sub>,X<sub>(n-1)/2+2</sub>,…,X<sub>n-1</sub>一定比中位数大。所以中位数不会在X<sub>(n-1)/2+1</sub>,X(n-1)/2+2&lt;/sub&gt;,…,X<sub>n-1</sub>中。同样Y<sub>0</sub>,Y<sub>1</sub>,…,Y<sub>(n-1)/2-1</sub>一定比中位数小。所以中位数在X<sub>0</sub>,X<sub>1</sub>,…,X<sub>(n-1)/2</sub>和Y<sub>(n-1)/2</sub>,Y<sub>n/2+2</sub>,…,Y<sub>n-1</sub>中。则只需要考察X[0:(n-1)/2:n-1]和Y[0:(n-1)/2]。</li>\n<li>如果n是偶数<br>则X<sub>(n-1)/2+2</sub>,X<sub>(n-1)/2+3</sub>,…,X<sub>n-1</sub>小的数至少有n+1个，所以X<sub>(n-1)/2+2</sub>,X<sub>(n-1)/2+3</sub>,…,X<sub>n-1</sub>一定比中位数大。同样Y<sub>0</sub>,Y<sub>1</sub>,…,Y<sub>(n-)/2-2</sub>一定比中位数小。则只需要考察X[0:(n-1)/2+1]和Y[(n-1)/2-1:n-1]。</li>\n</ul>\n</li>\n</ul>\n<p>由于在中位数两边加上或减去任意等数量的数并不影响中位数的取值,所以上述方法成立。</p>\n<ul>\n<li>（3）MedX&lt;MedY<br>这种情况和上面的同理</li>\n</ul>\n<p>分到最后每个数组只有两个元素，则不可以再分下去，利用X和Y的中位数用直接方法求解。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">函数名：FindMedian</span></span><br><span class=\"line\"><span class=\"comment\">功能：  求数组的某一区间的中位数</span></span><br><span class=\"line\"><span class=\"comment\">参数：  double Z[]-所求数组，int zl-数组的最小下标，int zr-数组的最大下标</span></span><br><span class=\"line\"><span class=\"comment\">返回值：double-中位数</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">FindMedian</span><span class=\"params\">(<span class=\"keyword\">double</span> Z[],<span class=\"keyword\">int</span> zl,<span class=\"keyword\">int</span> zr)</span></span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span>((zr-zl)%<span class=\"number\">2</span>==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> Z[(zr+zl)/<span class=\"number\">2</span>];</span><br><span class=\"line\">       &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">           <span class=\"built_in\"><span class=\"keyword\">return</span></span> (Z[(zr+zl)/<span class=\"number\">2</span>]+Z[(zr+zl)/<span class=\"number\">2</span>+<span class=\"number\">1</span>])/<span class=\"number\">2</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">函数名：FindMedian</span></span><br><span class=\"line\"><span class=\"comment\">功能：  求分别有序数组X某一区间和有序数组Y某一区间的混合中位数</span></span><br><span class=\"line\"><span class=\"comment\">参数：  int X[]-数组X，int xl-数组X要考察的最小下标，int xr-数组x要考察的最大下标</span></span><br><span class=\"line\"><span class=\"comment\">返回值：double-混合中位数</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">FindMixMedian</span><span class=\"params\">(<span class=\"keyword\">double</span> X[],<span class=\"keyword\">int</span> xl,<span class=\"keyword\">int</span> xr,<span class=\"keyword\">double</span> Y[],<span class=\"keyword\">int</span> yl,<span class=\"keyword\">int</span> yr)</span></span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">double</span> MedX=<span class=\"built_in\">FindMedian</span>(X,xl,xr);<span class=\"comment\">// 求X考察区域的中位数</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> MedY=<span class=\"built_in\">FindMedian</span>(Y,yl,yr);<span class=\"comment\">// 求y所考察区域的中位数</span></span><br><span class=\"line\">    <span class=\"comment\">// 若两个中位数相等，则所求便是混合区间的中位数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">abs</span>(MedX-MedY)&lt;<span class=\"number\">0.00001</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> MedY;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 若两边都只剩一个了，就取平均</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(xl==xr&amp;&amp;yl==yr)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (X[xl]+Y[xl])/<span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 若每个数组只剩两个，则讨论求出中位数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(xr-xl+<span class=\"number\">1</span>==<span class=\"number\">2</span>&amp;&amp;yr-yl+<span class=\"number\">1</span>==<span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 若MedX大，则X[xr]大于X[xl]和Y[YL],则判断X[xr]和Y[yr]</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(MedX&gt;MedY)&#123;    </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(X[xr]&gt;=Y[yr])&#123;     <span class=\"comment\">// 若X[xr]&gt;=Y[yr],则可以确定地关系是Y[yl]&lt;=Y[yr]&lt;=X[xr]</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(X[xl]&lt;Y[yl])&#123;  <span class=\"comment\">// X[xl]&lt;Y[yl]&lt;=Y[yr]&lt;=X[xr] </span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> ((Y[yl]+Y[yr])/<span class=\"number\">2</span>);</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;            <span class=\"comment\">// Y[yl]&lt;=Y[yr]&lt;X[xl]&lt;=X[xr]或 Y[yl]&lt;=X[xl]&lt;=Y[yr]&lt;=X[xr]</span></span><br><span class=\"line\">                    <span class=\"built_in\"><span class=\"keyword\">return</span></span> ((X[xl]+Y[yr])/<span class=\"number\">2</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123; <span class=\"comment\">// 如果X[xr]比Y[Yr]小，则X[xl]一定比Y[yl]大,则 Y[yl]&lt;X[xl]&lt;=X[xr]&lt;Y[yr]</span></span><br><span class=\"line\">             <span class=\"keyword\">return</span> MedX;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 若MedY大，则与上面的对称</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(MedX&lt;MedY)&#123;     </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(Y[yr]&gt;=X[xr])&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(Y[yl]&lt;X[xl])&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> ((X[xl]+X[xr])/<span class=\"number\">2</span>);</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;    </span><br><span class=\"line\">                    <span class=\"built_in\"><span class=\"keyword\">return</span></span> ((Y[yl]+X[xr])/<span class=\"number\">2</span>);</span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> MedY;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 区间划分</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(MedX&gt;MedY)&#123;   <span class=\"comment\">// MedX大时，X取小的部分，Y取大的部分</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>((xl-xr+<span class=\"number\">1</span>)%<span class=\"number\">2</span>!=<span class=\"number\">0</span>)&#123;    <span class=\"comment\">// 若区间个数为奇数</span></span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"built_in\">FindMixMedian</span>(X,xl,(xl+xr)/<span class=\"number\">2</span>,Y,(yl+yr)/<span class=\"number\">2</span>,yr);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"built_in\">FindMixMedian</span>(X,xl,(xl+xr)/<span class=\"number\">2</span>+<span class=\"number\">1</span>,Y,(yl+yr)/<span class=\"number\">2</span>,yr);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;           <span class=\"comment\">// MedX小时，X取大的部分，Y取小的部分</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>((xl-xr+<span class=\"number\">1</span>)%<span class=\"number\">2</span>!=<span class=\"number\">0</span>)&#123;    <span class=\"comment\">// 若区间个数为奇数</span></span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"built_in\">FindMixMedian</span>(X,(xl+xr)/<span class=\"number\">2</span>,xr,Y,yl,(yl+yr)/<span class=\"number\">2</span>);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"built_in\">FindMixMedian</span>(X,(xl+xr)/<span class=\"number\">2</span>,xr,Y,yl,(yl+yr)/<span class=\"number\">2</span>+<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">freopen</span>(<span class=\"string\">&quot;input1.txt&quot;</span>,<span class=\"string\">&quot;r&quot;</span>,stdin);</span><br><span class=\"line\">    <span class=\"built_in\">freopen</span>(<span class=\"string\">&quot;output1.txt&quot;</span>,<span class=\"string\">&quot;w&quot;</span>,stdout);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;     <span class=\"comment\">// 数组X和Y中每个数组所含有的元素个数   </span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> X[<span class=\"number\">202</span>]; </span><br><span class=\"line\">    <span class=\"keyword\">double</span> Y[<span class=\"number\">202</span>];</span><br><span class=\"line\">    <span class=\"keyword\">double</span> ans;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">        cin&gt;&gt;X[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">        cin&gt;&gt;Y[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ans = <span class=\"built_in\">FindMixMedian</span>(X,<span class=\"number\">0</span>,n<span class=\"number\">-1</span>,Y,<span class=\"number\">0</span>,n<span class=\"number\">-1</span>);</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"数据备份","date":"2021-06-11T07:52:27.000Z","_content":"# 题目\n{% asset_img backUp.png %}\n### 题目简述\n大概就是有n个办公楼，要找出k对，每对之间拉一个电缆，并且每个楼只能用一次，求出最小的距离之和\n\n### 分析\n- 首先要明确，找出的n对楼里面，每对肯定是相邻的，若不相邻，则令其中间的任一一对代替，能得到更优结果\n- 如果每次只选择最小那对，也是不行的，如：\n    - 现在有一个原始的对序列 2 1 2 5 6，要找两队。则放到优先队列中有 1 2 2 5 6，如果先选最小的，则现在选的是1，由于1中两个城市在2 2 这两队中，所以2 2 要丢掉。则优先队列中能用的只剩下 5 6，则下次应该选择5。不难发现，如果不选1的话，选2 2明显会比选1 5好。到这里不难发现，我们要后悔。、\n- 那么怎么进行后悔呢？\n    - 我们在选择最小的1之后，2 2 本来是要废掉的，但是我们不直接丢掉他们，而是创建一个新的数为 2+2-1=3 放入优先队列中。则优先队列中剩下的为 3 5 6，这样我们下次选3就相当于选了 2+2-1+1，即 2 2，后悔成功。\n\n### 算法\n每次取最小的一个区间，然后将这个数两边得区间合并，并减去这个数，构成后悔结点（则原区间最左边和最右边还应该加一段无穷大）。一直做下去，最终即可得到结果。\n区间段用链表维护。需要注意的是链表的更新。\n\n### 代码\n```c++\n#include<iostream>\n#include<cstring>\n#include<queue>\nusing namespace std;\nlong long s[100002];     // 每个公司到起点的距离\n\n// 每个相邻区间作为一个结点\ntypedef struct Node{\n      long long  Len;            // 区间的长度\n      int pos;                   // 当前结点的位置c\n}NODE;\n\n// 仿函数\nstruct tmp{\n    bool operator() (Node a,Node b){\n        return a.Len>b.Len;\n    }\n};\n\nbool isUsed[100002];// 判断某个结点是否已经使用过\nint Next[100002];   // 存放某个结点的下一个结点\nint Prio[100002];   // 存放某个节点的一个结点 \nlong long val[100002]; // 要得到某个位置的值信息，不能从队列里获得，要另存  \n\nNODE sNode;\nint main(){\n    //freopen(\"test/div1C.txt\",\"r\",stdin);\n    // 初始化标记数组\n    memset(isUsed,false,sizeof(isUsed));\n    int n,k;    // 办公楼数和可以铺设的电网数\n    long long ans=0;\n    cin>>n>>k;\n    for(int i =0;i<n;++i){\n        cin>>s[i];\n    }\n    priority_queue<NODE,vector<NODE>,tmp> Q;    // 设置一个小根堆存放现有结点\n    \n    \n\n    // 初始化第一个结点\n    sNode.Len=s[1]-s[0];\n    sNode.pos=1;    // 从1开始\n    Prio[1]=0;     // 第一个结点前驱为空\n    Next[1]=2;       // 后继为1\n    val[1]=sNode.Len;\n    Q.push(sNode);  // 第一个结点入队\n\n    // 初始化其他结点,最后一个结点的下标是n-1，因为一共有n-1个结点\n    for(int i =1; i<n-1;++i){\n        sNode.Len=s[i+1]-s[i];\n        sNode.pos=i+1;    \n        Prio[i+1]=i;     \n        Next[i+1]=i+2;       \n        val[i+1]=sNode.Len;\n        Q.push(sNode);     \n    }\n\n    // 两端设极大\n    val[0]=2e9;\n    val[n]=2e9;\n\n\n    // 进行贪心选择\n    while(k!=0){\n        // 跳过无效结点\n        while(isUsed[Q.top().pos]){\n            Q.pop();\n        }\n        sNode=Q.top();  // 取出长度最小的那个有效结点\n        Q.pop();\n        ans+=sNode.Len;  // 取了这个点，答案要加上\n        \n        // 求新的结点的长度，实现隐式反悔\n        sNode.Len=val[Prio[sNode.pos]]+val[Next[sNode.pos]]-val[sNode.pos];\n        val[sNode.pos]=sNode.Len;\n        \n      \n        // 两端设置为已使用\n        isUsed[Prio[sNode.pos]]=true;\n        isUsed[Next[sNode.pos]]=true;\n        //更新新结点的前驱后继\n        Prio[sNode.pos]=Prio[Prio[sNode.pos]];\n        Next[sNode.pos]=Next[Next[sNode.pos]];\n\n        // 更新前面的前面的后继和后面的后面的前驱\n        // 注意Prio[sNode.pos]和Next[sNode.pos]已经变了\n        Next[Prio[sNode.pos]]=sNode.pos;\n        Prio[Next[sNode.pos]]=sNode.pos;\n\n        // 新结点入队\n        Q.push(sNode);\n        --k;\n    }\n    cout<<ans<<endl;\n}\n```","source":"_posts/数据备份.md","raw":"---\ntitle: 数据备份\ndate: 2021-06-11 15:52:27\ncategories:\n    -div1\ntags:\n    -贪心\n    -反悔\n    -优先队列\n---\n# 题目\n{% asset_img backUp.png %}\n### 题目简述\n大概就是有n个办公楼，要找出k对，每对之间拉一个电缆，并且每个楼只能用一次，求出最小的距离之和\n\n### 分析\n- 首先要明确，找出的n对楼里面，每对肯定是相邻的，若不相邻，则令其中间的任一一对代替，能得到更优结果\n- 如果每次只选择最小那对，也是不行的，如：\n    - 现在有一个原始的对序列 2 1 2 5 6，要找两队。则放到优先队列中有 1 2 2 5 6，如果先选最小的，则现在选的是1，由于1中两个城市在2 2 这两队中，所以2 2 要丢掉。则优先队列中能用的只剩下 5 6，则下次应该选择5。不难发现，如果不选1的话，选2 2明显会比选1 5好。到这里不难发现，我们要后悔。、\n- 那么怎么进行后悔呢？\n    - 我们在选择最小的1之后，2 2 本来是要废掉的，但是我们不直接丢掉他们，而是创建一个新的数为 2+2-1=3 放入优先队列中。则优先队列中剩下的为 3 5 6，这样我们下次选3就相当于选了 2+2-1+1，即 2 2，后悔成功。\n\n### 算法\n每次取最小的一个区间，然后将这个数两边得区间合并，并减去这个数，构成后悔结点（则原区间最左边和最右边还应该加一段无穷大）。一直做下去，最终即可得到结果。\n区间段用链表维护。需要注意的是链表的更新。\n\n### 代码\n```c++\n#include<iostream>\n#include<cstring>\n#include<queue>\nusing namespace std;\nlong long s[100002];     // 每个公司到起点的距离\n\n// 每个相邻区间作为一个结点\ntypedef struct Node{\n      long long  Len;            // 区间的长度\n      int pos;                   // 当前结点的位置c\n}NODE;\n\n// 仿函数\nstruct tmp{\n    bool operator() (Node a,Node b){\n        return a.Len>b.Len;\n    }\n};\n\nbool isUsed[100002];// 判断某个结点是否已经使用过\nint Next[100002];   // 存放某个结点的下一个结点\nint Prio[100002];   // 存放某个节点的一个结点 \nlong long val[100002]; // 要得到某个位置的值信息，不能从队列里获得，要另存  \n\nNODE sNode;\nint main(){\n    //freopen(\"test/div1C.txt\",\"r\",stdin);\n    // 初始化标记数组\n    memset(isUsed,false,sizeof(isUsed));\n    int n,k;    // 办公楼数和可以铺设的电网数\n    long long ans=0;\n    cin>>n>>k;\n    for(int i =0;i<n;++i){\n        cin>>s[i];\n    }\n    priority_queue<NODE,vector<NODE>,tmp> Q;    // 设置一个小根堆存放现有结点\n    \n    \n\n    // 初始化第一个结点\n    sNode.Len=s[1]-s[0];\n    sNode.pos=1;    // 从1开始\n    Prio[1]=0;     // 第一个结点前驱为空\n    Next[1]=2;       // 后继为1\n    val[1]=sNode.Len;\n    Q.push(sNode);  // 第一个结点入队\n\n    // 初始化其他结点,最后一个结点的下标是n-1，因为一共有n-1个结点\n    for(int i =1; i<n-1;++i){\n        sNode.Len=s[i+1]-s[i];\n        sNode.pos=i+1;    \n        Prio[i+1]=i;     \n        Next[i+1]=i+2;       \n        val[i+1]=sNode.Len;\n        Q.push(sNode);     \n    }\n\n    // 两端设极大\n    val[0]=2e9;\n    val[n]=2e9;\n\n\n    // 进行贪心选择\n    while(k!=0){\n        // 跳过无效结点\n        while(isUsed[Q.top().pos]){\n            Q.pop();\n        }\n        sNode=Q.top();  // 取出长度最小的那个有效结点\n        Q.pop();\n        ans+=sNode.Len;  // 取了这个点，答案要加上\n        \n        // 求新的结点的长度，实现隐式反悔\n        sNode.Len=val[Prio[sNode.pos]]+val[Next[sNode.pos]]-val[sNode.pos];\n        val[sNode.pos]=sNode.Len;\n        \n      \n        // 两端设置为已使用\n        isUsed[Prio[sNode.pos]]=true;\n        isUsed[Next[sNode.pos]]=true;\n        //更新新结点的前驱后继\n        Prio[sNode.pos]=Prio[Prio[sNode.pos]];\n        Next[sNode.pos]=Next[Next[sNode.pos]];\n\n        // 更新前面的前面的后继和后面的后面的前驱\n        // 注意Prio[sNode.pos]和Next[sNode.pos]已经变了\n        Next[Prio[sNode.pos]]=sNode.pos;\n        Prio[Next[sNode.pos]]=sNode.pos;\n\n        // 新结点入队\n        Q.push(sNode);\n        --k;\n    }\n    cout<<ans<<endl;\n}\n```","slug":"数据备份","published":1,"updated":"2021-07-15T10:15:26.481Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckr74cdt5001g40tkak32aj8x","content":"<h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><img src=\"/2021/06/11/%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/backUp.png\" class=\"\">\n<h3 id=\"题目简述\"><a href=\"#题目简述\" class=\"headerlink\" title=\"题目简述\"></a>题目简述</h3><p>大概就是有n个办公楼，要找出k对，每对之间拉一个电缆，并且每个楼只能用一次，求出最小的距离之和</p>\n<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><ul>\n<li>首先要明确，找出的n对楼里面，每对肯定是相邻的，若不相邻，则令其中间的任一一对代替，能得到更优结果</li>\n<li>如果每次只选择最小那对，也是不行的，如：<ul>\n<li>现在有一个原始的对序列 2 1 2 5 6，要找两队。则放到优先队列中有 1 2 2 5 6，如果先选最小的，则现在选的是1，由于1中两个城市在2 2 这两队中，所以2 2 要丢掉。则优先队列中能用的只剩下 5 6，则下次应该选择5。不难发现，如果不选1的话，选2 2明显会比选1 5好。到这里不难发现，我们要后悔。、</li>\n</ul>\n</li>\n<li>那么怎么进行后悔呢？<ul>\n<li>我们在选择最小的1之后，2 2 本来是要废掉的，但是我们不直接丢掉他们，而是创建一个新的数为 2+2-1=3 放入优先队列中。则优先队列中剩下的为 3 5 6，这样我们下次选3就相当于选了 2+2-1+1，即 2 2，后悔成功。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h3><p>每次取最小的一个区间，然后将这个数两边得区间合并，并减去这个数，构成后悔结点（则原区间最左边和最右边还应该加一段无穷大）。一直做下去，最终即可得到结果。<br>区间段用链表维护。需要注意的是链表的更新。</p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> s[<span class=\"number\">100002</span>];     <span class=\"comment\">// 每个公司到起点的距离</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 每个相邻区间作为一个结点</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span>&#123;</span></span><br><span class=\"line\">      <span class=\"keyword\">long</span> <span class=\"keyword\">long</span>  Len;            <span class=\"comment\">// 区间的长度</span></span><br><span class=\"line\">      <span class=\"keyword\">int</span> pos;                   <span class=\"comment\">// 当前结点的位置c</span></span><br><span class=\"line\">&#125;NODE;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 仿函数</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tmp</span>&#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">operator</span><span class=\"params\">()</span> <span class=\"params\">(Node a,Node b)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.Len&gt;b.Len;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">bool</span> isUsed[<span class=\"number\">100002</span>];<span class=\"comment\">// 判断某个结点是否已经使用过</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> Next[<span class=\"number\">100002</span>];   <span class=\"comment\">// 存放某个结点的下一个结点</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> Prio[<span class=\"number\">100002</span>];   <span class=\"comment\">// 存放某个节点的一个结点 </span></span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> val[<span class=\"number\">100002</span>]; <span class=\"comment\">// 要得到某个位置的值信息，不能从队列里获得，要另存  </span></span><br><span class=\"line\"></span><br><span class=\"line\">NODE sNode;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//freopen(&quot;test/div1C.txt&quot;,&quot;r&quot;,stdin);</span></span><br><span class=\"line\">    <span class=\"comment\">// 初始化标记数组</span></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(isUsed,<span class=\"literal\">false</span>,<span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(isUsed));</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n,k;    <span class=\"comment\">// 办公楼数和可以铺设的电网数</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i =<span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">        cin&gt;&gt;s[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    priority_queue&lt;NODE,vector&lt;NODE&gt;,tmp&gt; Q;    <span class=\"comment\">// 设置一个小根堆存放现有结点</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化第一个结点</span></span><br><span class=\"line\">    sNode.Len=s[<span class=\"number\">1</span>]-s[<span class=\"number\">0</span>];</span><br><span class=\"line\">    sNode.pos=<span class=\"number\">1</span>;    <span class=\"comment\">// 从1开始</span></span><br><span class=\"line\">    Prio[<span class=\"number\">1</span>]=<span class=\"number\">0</span>;     <span class=\"comment\">// 第一个结点前驱为空</span></span><br><span class=\"line\">    Next[<span class=\"number\">1</span>]=<span class=\"number\">2</span>;       <span class=\"comment\">// 后继为1</span></span><br><span class=\"line\">    val[<span class=\"number\">1</span>]=sNode.Len;</span><br><span class=\"line\">    Q.<span class=\"built_in\">push</span>(sNode);  <span class=\"comment\">// 第一个结点入队</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化其他结点,最后一个结点的下标是n-1，因为一共有n-1个结点</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i =<span class=\"number\">1</span>; i&lt;n<span class=\"number\">-1</span>;++i)&#123;</span><br><span class=\"line\">        sNode.Len=s[i+<span class=\"number\">1</span>]-s[i];</span><br><span class=\"line\">        sNode.pos=i+<span class=\"number\">1</span>;    </span><br><span class=\"line\">        Prio[i+<span class=\"number\">1</span>]=i;     </span><br><span class=\"line\">        Next[i+<span class=\"number\">1</span>]=i+<span class=\"number\">2</span>;       </span><br><span class=\"line\">        val[i+<span class=\"number\">1</span>]=sNode.Len;</span><br><span class=\"line\">        Q.<span class=\"built_in\">push</span>(sNode);     </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 两端设极大</span></span><br><span class=\"line\">    val[<span class=\"number\">0</span>]=<span class=\"number\">2e9</span>;</span><br><span class=\"line\">    val[n]=<span class=\"number\">2e9</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 进行贪心选择</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(k!=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 跳过无效结点</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(isUsed[Q.<span class=\"built_in\">top</span>().pos])&#123;</span><br><span class=\"line\">            Q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sNode=Q.<span class=\"built_in\">top</span>();  <span class=\"comment\">// 取出长度最小的那个有效结点</span></span><br><span class=\"line\">        Q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        ans+=sNode.Len;  <span class=\"comment\">// 取了这个点，答案要加上</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 求新的结点的长度，实现隐式反悔</span></span><br><span class=\"line\">        sNode.Len=val[Prio[sNode.pos]]+val[Next[sNode.pos]]-val[sNode.pos];</span><br><span class=\"line\">        val[sNode.pos]=sNode.Len;</span><br><span class=\"line\">        </span><br><span class=\"line\">      </span><br><span class=\"line\">        <span class=\"comment\">// 两端设置为已使用</span></span><br><span class=\"line\">        isUsed[Prio[sNode.pos]]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">        isUsed[Next[sNode.pos]]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"comment\">//更新新结点的前驱后继</span></span><br><span class=\"line\">        Prio[sNode.pos]=Prio[Prio[sNode.pos]];</span><br><span class=\"line\">        Next[sNode.pos]=Next[Next[sNode.pos]];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 更新前面的前面的后继和后面的后面的前驱</span></span><br><span class=\"line\">        <span class=\"comment\">// 注意Prio[sNode.pos]和Next[sNode.pos]已经变了</span></span><br><span class=\"line\">        Next[Prio[sNode.pos]]=sNode.pos;</span><br><span class=\"line\">        Prio[Next[sNode.pos]]=sNode.pos;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 新结点入队</span></span><br><span class=\"line\">        Q.<span class=\"built_in\">push</span>(sNode);</span><br><span class=\"line\">        --k;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"题目\"><a href=\"#题目\" class=\"headerlink\" title=\"题目\"></a>题目</h1><img src=\"/2021/06/11/%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/backUp.png\" class=\"\">\n<h3 id=\"题目简述\"><a href=\"#题目简述\" class=\"headerlink\" title=\"题目简述\"></a>题目简述</h3><p>大概就是有n个办公楼，要找出k对，每对之间拉一个电缆，并且每个楼只能用一次，求出最小的距离之和</p>\n<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><ul>\n<li>首先要明确，找出的n对楼里面，每对肯定是相邻的，若不相邻，则令其中间的任一一对代替，能得到更优结果</li>\n<li>如果每次只选择最小那对，也是不行的，如：<ul>\n<li>现在有一个原始的对序列 2 1 2 5 6，要找两队。则放到优先队列中有 1 2 2 5 6，如果先选最小的，则现在选的是1，由于1中两个城市在2 2 这两队中，所以2 2 要丢掉。则优先队列中能用的只剩下 5 6，则下次应该选择5。不难发现，如果不选1的话，选2 2明显会比选1 5好。到这里不难发现，我们要后悔。、</li>\n</ul>\n</li>\n<li>那么怎么进行后悔呢？<ul>\n<li>我们在选择最小的1之后，2 2 本来是要废掉的，但是我们不直接丢掉他们，而是创建一个新的数为 2+2-1=3 放入优先队列中。则优先队列中剩下的为 3 5 6，这样我们下次选3就相当于选了 2+2-1+1，即 2 2，后悔成功。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h3><p>每次取最小的一个区间，然后将这个数两边得区间合并，并减去这个数，构成后悔结点（则原区间最左边和最右边还应该加一段无穷大）。一直做下去，最终即可得到结果。<br>区间段用链表维护。需要注意的是链表的更新。</p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> s[<span class=\"number\">100002</span>];     <span class=\"comment\">// 每个公司到起点的距离</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 每个相邻区间作为一个结点</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span>&#123;</span></span><br><span class=\"line\">      <span class=\"keyword\">long</span> <span class=\"keyword\">long</span>  Len;            <span class=\"comment\">// 区间的长度</span></span><br><span class=\"line\">      <span class=\"keyword\">int</span> pos;                   <span class=\"comment\">// 当前结点的位置c</span></span><br><span class=\"line\">&#125;NODE;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 仿函数</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tmp</span>&#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">operator</span><span class=\"params\">()</span> <span class=\"params\">(Node a,Node b)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.Len&gt;b.Len;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">bool</span> isUsed[<span class=\"number\">100002</span>];<span class=\"comment\">// 判断某个结点是否已经使用过</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> Next[<span class=\"number\">100002</span>];   <span class=\"comment\">// 存放某个结点的下一个结点</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> Prio[<span class=\"number\">100002</span>];   <span class=\"comment\">// 存放某个节点的一个结点 </span></span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> val[<span class=\"number\">100002</span>]; <span class=\"comment\">// 要得到某个位置的值信息，不能从队列里获得，要另存  </span></span><br><span class=\"line\"></span><br><span class=\"line\">NODE sNode;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//freopen(&quot;test/div1C.txt&quot;,&quot;r&quot;,stdin);</span></span><br><span class=\"line\">    <span class=\"comment\">// 初始化标记数组</span></span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(isUsed,<span class=\"literal\">false</span>,<span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(isUsed));</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n,k;    <span class=\"comment\">// 办公楼数和可以铺设的电网数</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i =<span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">        cin&gt;&gt;s[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    priority_queue&lt;NODE,vector&lt;NODE&gt;,tmp&gt; Q;    <span class=\"comment\">// 设置一个小根堆存放现有结点</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化第一个结点</span></span><br><span class=\"line\">    sNode.Len=s[<span class=\"number\">1</span>]-s[<span class=\"number\">0</span>];</span><br><span class=\"line\">    sNode.pos=<span class=\"number\">1</span>;    <span class=\"comment\">// 从1开始</span></span><br><span class=\"line\">    Prio[<span class=\"number\">1</span>]=<span class=\"number\">0</span>;     <span class=\"comment\">// 第一个结点前驱为空</span></span><br><span class=\"line\">    Next[<span class=\"number\">1</span>]=<span class=\"number\">2</span>;       <span class=\"comment\">// 后继为1</span></span><br><span class=\"line\">    val[<span class=\"number\">1</span>]=sNode.Len;</span><br><span class=\"line\">    Q.<span class=\"built_in\">push</span>(sNode);  <span class=\"comment\">// 第一个结点入队</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化其他结点,最后一个结点的下标是n-1，因为一共有n-1个结点</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i =<span class=\"number\">1</span>; i&lt;n<span class=\"number\">-1</span>;++i)&#123;</span><br><span class=\"line\">        sNode.Len=s[i+<span class=\"number\">1</span>]-s[i];</span><br><span class=\"line\">        sNode.pos=i+<span class=\"number\">1</span>;    </span><br><span class=\"line\">        Prio[i+<span class=\"number\">1</span>]=i;     </span><br><span class=\"line\">        Next[i+<span class=\"number\">1</span>]=i+<span class=\"number\">2</span>;       </span><br><span class=\"line\">        val[i+<span class=\"number\">1</span>]=sNode.Len;</span><br><span class=\"line\">        Q.<span class=\"built_in\">push</span>(sNode);     </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 两端设极大</span></span><br><span class=\"line\">    val[<span class=\"number\">0</span>]=<span class=\"number\">2e9</span>;</span><br><span class=\"line\">    val[n]=<span class=\"number\">2e9</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 进行贪心选择</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(k!=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 跳过无效结点</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(isUsed[Q.<span class=\"built_in\">top</span>().pos])&#123;</span><br><span class=\"line\">            Q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sNode=Q.<span class=\"built_in\">top</span>();  <span class=\"comment\">// 取出长度最小的那个有效结点</span></span><br><span class=\"line\">        Q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        ans+=sNode.Len;  <span class=\"comment\">// 取了这个点，答案要加上</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 求新的结点的长度，实现隐式反悔</span></span><br><span class=\"line\">        sNode.Len=val[Prio[sNode.pos]]+val[Next[sNode.pos]]-val[sNode.pos];</span><br><span class=\"line\">        val[sNode.pos]=sNode.Len;</span><br><span class=\"line\">        </span><br><span class=\"line\">      </span><br><span class=\"line\">        <span class=\"comment\">// 两端设置为已使用</span></span><br><span class=\"line\">        isUsed[Prio[sNode.pos]]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">        isUsed[Next[sNode.pos]]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"comment\">//更新新结点的前驱后继</span></span><br><span class=\"line\">        Prio[sNode.pos]=Prio[Prio[sNode.pos]];</span><br><span class=\"line\">        Next[sNode.pos]=Next[Next[sNode.pos]];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 更新前面的前面的后继和后面的后面的前驱</span></span><br><span class=\"line\">        <span class=\"comment\">// 注意Prio[sNode.pos]和Next[sNode.pos]已经变了</span></span><br><span class=\"line\">        Next[Prio[sNode.pos]]=sNode.pos;</span><br><span class=\"line\">        Prio[Next[sNode.pos]]=sNode.pos;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 新结点入队</span></span><br><span class=\"line\">        Q.<span class=\"built_in\">push</span>(sNode);</span><br><span class=\"line\">        --k;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"关于对floyd算法的质疑","date":"2021-04-17T16:24:38.000Z","_content":"# floyd算法\n所谓floyd算法，就是求图的每两个顶点的最短路径问题。算法用的是动态规划。\n循环N次，每次选取一个顶点K，比较图的每个顶点经过K到达其他顶点的距离和本来该顶点到达其他顶点的距离，并进行距离的更新。最后可求出每两个点的最短距离。\n\n#### 疑惑\n例如一个有向图，只有1->2和1->0->4->3->2这两条路径。前者长度8，后者总长度6。那么在选取0作起始点的时候，0->2没有更新成为最短路径，并且后来会把0抛弃掉，不考虑经过0，所以在选择经过0的时候，我们就没能求出1经过0到达2的最短路径。那么怎么还能算出1->2的最短路径？\n#### 理解\n在对0进行考虑的时候，我们已经更新了1->4的路径，而这条路径是从1经过0到达2的最短路径的一部分。所以其实经过0到达2的最短路径就已经被求出了一部分，所以接下来和0就没关系了。接下来的求法也同理。\n\n","source":"_posts/关于对floyd算法的质疑.md","raw":"---\ntitle: 关于对floyd算法的质疑\ndate: 2021-04-18 00:24:38\ntags:\n  - 动态规划\n---\n# floyd算法\n所谓floyd算法，就是求图的每两个顶点的最短路径问题。算法用的是动态规划。\n循环N次，每次选取一个顶点K，比较图的每个顶点经过K到达其他顶点的距离和本来该顶点到达其他顶点的距离，并进行距离的更新。最后可求出每两个点的最短距离。\n\n#### 疑惑\n例如一个有向图，只有1->2和1->0->4->3->2这两条路径。前者长度8，后者总长度6。那么在选取0作起始点的时候，0->2没有更新成为最短路径，并且后来会把0抛弃掉，不考虑经过0，所以在选择经过0的时候，我们就没能求出1经过0到达2的最短路径。那么怎么还能算出1->2的最短路径？\n#### 理解\n在对0进行考虑的时候，我们已经更新了1->4的路径，而这条路径是从1经过0到达2的最短路径的一部分。所以其实经过0到达2的最短路径就已经被求出了一部分，所以接下来和0就没关系了。接下来的求法也同理。\n\n","slug":"关于对floyd算法的质疑","published":1,"updated":"2021-07-15T10:15:26.479Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckr74cdta001l40tkh68i216j","content":"<h1 id=\"floyd算法\"><a href=\"#floyd算法\" class=\"headerlink\" title=\"floyd算法\"></a>floyd算法</h1><p>所谓floyd算法，就是求图的每两个顶点的最短路径问题。算法用的是动态规划。<br>循环N次，每次选取一个顶点K，比较图的每个顶点经过K到达其他顶点的距离和本来该顶点到达其他顶点的距离，并进行距离的更新。最后可求出每两个点的最短距离。</p>\n<h4 id=\"疑惑\"><a href=\"#疑惑\" class=\"headerlink\" title=\"疑惑\"></a>疑惑</h4><p>例如一个有向图，只有1-&gt;2和1-&gt;0-&gt;4-&gt;3-&gt;2这两条路径。前者长度8，后者总长度6。那么在选取0作起始点的时候，0-&gt;2没有更新成为最短路径，并且后来会把0抛弃掉，不考虑经过0，所以在选择经过0的时候，我们就没能求出1经过0到达2的最短路径。那么怎么还能算出1-&gt;2的最短路径？</p>\n<h4 id=\"理解\"><a href=\"#理解\" class=\"headerlink\" title=\"理解\"></a>理解</h4><p>在对0进行考虑的时候，我们已经更新了1-&gt;4的路径，而这条路径是从1经过0到达2的最短路径的一部分。所以其实经过0到达2的最短路径就已经被求出了一部分，所以接下来和0就没关系了。接下来的求法也同理。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"floyd算法\"><a href=\"#floyd算法\" class=\"headerlink\" title=\"floyd算法\"></a>floyd算法</h1><p>所谓floyd算法，就是求图的每两个顶点的最短路径问题。算法用的是动态规划。<br>循环N次，每次选取一个顶点K，比较图的每个顶点经过K到达其他顶点的距离和本来该顶点到达其他顶点的距离，并进行距离的更新。最后可求出每两个点的最短距离。</p>\n<h4 id=\"疑惑\"><a href=\"#疑惑\" class=\"headerlink\" title=\"疑惑\"></a>疑惑</h4><p>例如一个有向图，只有1-&gt;2和1-&gt;0-&gt;4-&gt;3-&gt;2这两条路径。前者长度8，后者总长度6。那么在选取0作起始点的时候，0-&gt;2没有更新成为最短路径，并且后来会把0抛弃掉，不考虑经过0，所以在选择经过0的时候，我们就没能求出1经过0到达2的最短路径。那么怎么还能算出1-&gt;2的最短路径？</p>\n<h4 id=\"理解\"><a href=\"#理解\" class=\"headerlink\" title=\"理解\"></a>理解</h4><p>在对0进行考虑的时候，我们已经更新了1-&gt;4的路径，而这条路径是从1经过0到达2的最短路径的一部分。所以其实经过0到达2的最短路径就已经被求出了一部分，所以接下来和0就没关系了。接下来的求法也同理。</p>\n"},{"title":"牛客欢乐赛8E","date":"2021-07-14T23:57:06.000Z","_content":"## [题目链接](https://ac.nowcoder.com/acm/contest/17574/B)\n\n### 题目大意\n这题给你n个1和m个0，组成一个字符串，并且对任意一个前缀，1都不能比0少。\n### 分析\n这是一道比较典型的卡特兰数题。我们可以将问题看作是求解(n+m,n-m)有多少种01字符串组合方式,n+m是字符总数，n-m是1比0多的个数。  \n从(0,0)开始，记将1放进集合记作操作1，将0放进集合记作操作2。\n* 进行操作1，集合变成(x+1,y+1),及向右上角走。\n* 进行操作2，集合变成(x+1,y-1)，即往右下角走\n\n最后目标是走到(n+m,n-m)。而如果y碰到y=-1这条线，那么就是非法的。  \n于是问题就变成了从(0,0)状态走到(n+m,n-m)状态一共有多少种合法的走法。(走：即向空字符串从头到尾填充0和1，不同的走法就实现了0和1的不同组合)\n* 如果考虑所有状况，则很明显是C(n+m,n)   （1要走n步，从n+m步中选出n步的种类，即长度为n+m的字符串中有n个为1有多少种）\n* 所有合法种类我们不好求，但是非法可求，则用合法的减去非法的种类。\n    * 非法的情况即碰过了y=-1的情况如图。 \n    {% asset_img 1.png %}\n    * 将与y=-1的最后一个交点之前的部分以y=-1为轴对折，可以发现这种情况对应了一种从(0,-2)到(n+m,n-m)的情况。实际在我们这种对折规矩下，所有从(0,0)到(n+m,n-m)的非法情况都和由从(0,-2)到(n+m,n-m)的所有情况一一对应，则所有非法情况种类可以通过求(0,-2)到(n+m,n-m)的<b>所有</b>情况求出。(合法情况是不会对应从(0,-2)到(n+m,n-m)的，因为合法情况没有与y=-1的交点，所以无法与我们规定的这种翻折对应。)\n    {% asset_img 2.png %}\n    * 非法情况是从(0,-2)到(n+m,n-m)，那么路径就要变。但是总的操作数不能变，因为横坐标还是0到n+m;\n      * 设操作1变为a种，操作2变为b种则\n      $$\n      \\begin{cases}a+b=n+m\\\\a-b=n-m+2\\end{cases}\n      $$  \n      解得 \n      $$\n      \\begin{cases}a=n+1 \\\\ b=m-1 \\end{cases}$$\n    则非法情况总数为C(n+m,n+1)\n\n最后ans=C(n+m,n)-C(n+m,n+1)\n    \n\n### 组合数求解\n\n$$C{a\\atop m}\\pmod p=\\frac{n!}{m!(n-m!)}\\pmod p$$\n可以看出，如果直接求解组合数然后再取模，那么分子或者分母会溢出。而取模分配率对加减乘成立，如对乘法有  \n\n<center>(a&nbsp;*&nbsp;b)%p&nbsp;=&nbsp;[(a%p)&nbsp;*&nbsp;(b%p)]%p</center>  \n但是对除法却不存在\n<center>(a&nbsp;/&nbsp;b)%p&nbsp;=&nbsp;[(a%p)&nbsp;/&nbsp;(b%p)]%p&nbsp;(错误)</center> \n那怎么办呢，于是科学家们扔出了逆元这个玩意。  \n#### 逆元\n<b>定理</b>：若在mod&nbsp;p意义下，对于一个整数a，有\n$$\na*x\\equiv 1\\pmod p\n$$\n那么这个整数x即为a的乘法逆元，同时a也为x的乘法逆元。  \n\n<b>充要条件</b>：a存在模p的乘法逆元的充要条件是gcd(a,p)&nbsp;=1&nbsp;，即a与p互质。  \n\n<b>应用</b>：求$\\frac{a}{b}\\%p$等同于求a * (b的逆元)%p   \n- <b>证明</b>：  \n  我们假设 \n  $$\\frac{a}{b}\\%p=m(a和b满足a\\%b=0)\\tag{1}$$ \n  由乘法逆元符合分配律对(1)式两边乘以b有\n  $$a\\%p=(m(b\\%p))\\%p\\tag{2}$$\n  即\n  $$a\\equiv m*b\\pmod p\\tag{3}$$\n  假设b的逆元是x，则(3)式两边乘以一个x有\n  $$a*x\\equiv m*b*x\\pmod p\\tag{4}$$\n  由逆元的定理有\n  $b\\ast x\\equiv 1\\pmod p$\n  则\n  $$a\\ast x\\equiv m\\pmod p\\tag{5}$$\n  证毕\n\n于是我们就可以把除法的求模运算转换为乘法的求模运算，从而可以利用分配律。\n\n\n<b>类比</b>：其实逆元可以类比于普通乘法中的倒数，即当$b*x=1$时$\\frac{1}{b}=x$，但是在求模运算中，x与$\\frac{1}{b}$只是等同，而并非就是取倒数。\n#### 费马小定理\n那么逆元怎么求解呢，可不是像普通乘法那样直接是倒数。则可以通过定义$a*x\\equiv1\\pmod p$来求解逆元。  \n由于在ACM中大多数时候p是质数，否则容易找到余数的规律，所以用费马里小定理即可求解a的逆元。  \n\n<b>定理：</b>  假如a是一个整数，p是一个质数，那么\n  1. 如果a是p的倍数，$a^p\\equiv a \\pmod p$ \n  2. 如果a不是p的倍数，$a^{p-1}\\equiv 1 \\pmod p$  \n\n由乘法逆元的充要条件是gcd(a,p)&nbsp;=1&nbsp;，所以a不会是p的倍数，所以用第二条。将第二条转化以下有\n$$\na*a^{p-2}\\equiv 1\\pmod p\n$$\n则$a^{p-2}$就是a的逆元，证明自己去百度。\n\n最后利用快速幂求解即可。\n#### 快速幂\n快速幂即求解幂的快速算法。考察$3^{10}$,有\n$$3^{10}=9^{5}=9*81^{2}=9*6561^{1}=(9*6561)*1^{0}$$\n设幂为p，底数为b，则其算法思路为\n 1. 如果p是偶数，$b=b\\ast b$；p>>1\n 2. 如果p是奇数，那么$ans=ans\\ast b$；$b=b\\ast b$\n\n这样最后得到的结果即在ans中\n\n```c++\n#include<iostream>\nusing namespace std;\nconst long long mod =20100403;\nint n , m;\n\n// 求阶乘\nlong long fac(long long a){\n    long long ans=1;\n    for(long long i = a;i>=1;--i){\n       ans=(ans*i%mod)%mod;\n       ans=ans%mod;\n    }\n    return ans;\n}\n// 矩阵快速幂求逆元\nlong long Fpow(long long b,long long p){\n    long long ans=1;\n    while(p>0){\n        if(p%2==0){\n           b=(b*b)%mod;\n           p=p/2;\n        }else{\n           ans=(ans*b)%mod;\n           b=(b*b)%mod;\n           p=p/2;\n        }\n    }\n    return ans;\n}\n// 求组合数\nlong long C(int a,int b){\n    long long a1=fac(a);  // 求分子\n    long long b1=(fac(b)*fac(a-b))%mod; //分母\n    //求b的逆元\n    b1=Fpow(b1,mod-2);\n    return ((a1%mod)*(b1%mod))%mod;\n\n}\nint main(){\n    freopen(\"test/E.txt\",\"r\",stdin);\n    cin>>n>>m;\n    long long ans;\n    ans=(C(n+m,n)-C(n+m,n+1)+mod)%mod; // 可能会求得附属，所以先加上模再取模，因为计算结果是分别取模之后的，所以小的可能本来就比mod小\n    cout<<ans<<endl;\n}\n```\n\n\n\n\n\n\n","source":"_posts/牛客欢乐赛8E.md","raw":"---\ntitle: 牛客欢乐赛8E\ndate: 2021-07-15 07:57:06\ncategories:\n - 牛客\n - 比赛\ntags:\n - 数论\n - 组合数\n - 逆元\n - 费马里小定理\n\n\n\n---\n## [题目链接](https://ac.nowcoder.com/acm/contest/17574/B)\n\n### 题目大意\n这题给你n个1和m个0，组成一个字符串，并且对任意一个前缀，1都不能比0少。\n### 分析\n这是一道比较典型的卡特兰数题。我们可以将问题看作是求解(n+m,n-m)有多少种01字符串组合方式,n+m是字符总数，n-m是1比0多的个数。  \n从(0,0)开始，记将1放进集合记作操作1，将0放进集合记作操作2。\n* 进行操作1，集合变成(x+1,y+1),及向右上角走。\n* 进行操作2，集合变成(x+1,y-1)，即往右下角走\n\n最后目标是走到(n+m,n-m)。而如果y碰到y=-1这条线，那么就是非法的。  \n于是问题就变成了从(0,0)状态走到(n+m,n-m)状态一共有多少种合法的走法。(走：即向空字符串从头到尾填充0和1，不同的走法就实现了0和1的不同组合)\n* 如果考虑所有状况，则很明显是C(n+m,n)   （1要走n步，从n+m步中选出n步的种类，即长度为n+m的字符串中有n个为1有多少种）\n* 所有合法种类我们不好求，但是非法可求，则用合法的减去非法的种类。\n    * 非法的情况即碰过了y=-1的情况如图。 \n    {% asset_img 1.png %}\n    * 将与y=-1的最后一个交点之前的部分以y=-1为轴对折，可以发现这种情况对应了一种从(0,-2)到(n+m,n-m)的情况。实际在我们这种对折规矩下，所有从(0,0)到(n+m,n-m)的非法情况都和由从(0,-2)到(n+m,n-m)的所有情况一一对应，则所有非法情况种类可以通过求(0,-2)到(n+m,n-m)的<b>所有</b>情况求出。(合法情况是不会对应从(0,-2)到(n+m,n-m)的，因为合法情况没有与y=-1的交点，所以无法与我们规定的这种翻折对应。)\n    {% asset_img 2.png %}\n    * 非法情况是从(0,-2)到(n+m,n-m)，那么路径就要变。但是总的操作数不能变，因为横坐标还是0到n+m;\n      * 设操作1变为a种，操作2变为b种则\n      $$\n      \\begin{cases}a+b=n+m\\\\a-b=n-m+2\\end{cases}\n      $$  \n      解得 \n      $$\n      \\begin{cases}a=n+1 \\\\ b=m-1 \\end{cases}$$\n    则非法情况总数为C(n+m,n+1)\n\n最后ans=C(n+m,n)-C(n+m,n+1)\n    \n\n### 组合数求解\n\n$$C{a\\atop m}\\pmod p=\\frac{n!}{m!(n-m!)}\\pmod p$$\n可以看出，如果直接求解组合数然后再取模，那么分子或者分母会溢出。而取模分配率对加减乘成立，如对乘法有  \n\n<center>(a&nbsp;*&nbsp;b)%p&nbsp;=&nbsp;[(a%p)&nbsp;*&nbsp;(b%p)]%p</center>  \n但是对除法却不存在\n<center>(a&nbsp;/&nbsp;b)%p&nbsp;=&nbsp;[(a%p)&nbsp;/&nbsp;(b%p)]%p&nbsp;(错误)</center> \n那怎么办呢，于是科学家们扔出了逆元这个玩意。  \n#### 逆元\n<b>定理</b>：若在mod&nbsp;p意义下，对于一个整数a，有\n$$\na*x\\equiv 1\\pmod p\n$$\n那么这个整数x即为a的乘法逆元，同时a也为x的乘法逆元。  \n\n<b>充要条件</b>：a存在模p的乘法逆元的充要条件是gcd(a,p)&nbsp;=1&nbsp;，即a与p互质。  \n\n<b>应用</b>：求$\\frac{a}{b}\\%p$等同于求a * (b的逆元)%p   \n- <b>证明</b>：  \n  我们假设 \n  $$\\frac{a}{b}\\%p=m(a和b满足a\\%b=0)\\tag{1}$$ \n  由乘法逆元符合分配律对(1)式两边乘以b有\n  $$a\\%p=(m(b\\%p))\\%p\\tag{2}$$\n  即\n  $$a\\equiv m*b\\pmod p\\tag{3}$$\n  假设b的逆元是x，则(3)式两边乘以一个x有\n  $$a*x\\equiv m*b*x\\pmod p\\tag{4}$$\n  由逆元的定理有\n  $b\\ast x\\equiv 1\\pmod p$\n  则\n  $$a\\ast x\\equiv m\\pmod p\\tag{5}$$\n  证毕\n\n于是我们就可以把除法的求模运算转换为乘法的求模运算，从而可以利用分配律。\n\n\n<b>类比</b>：其实逆元可以类比于普通乘法中的倒数，即当$b*x=1$时$\\frac{1}{b}=x$，但是在求模运算中，x与$\\frac{1}{b}$只是等同，而并非就是取倒数。\n#### 费马小定理\n那么逆元怎么求解呢，可不是像普通乘法那样直接是倒数。则可以通过定义$a*x\\equiv1\\pmod p$来求解逆元。  \n由于在ACM中大多数时候p是质数，否则容易找到余数的规律，所以用费马里小定理即可求解a的逆元。  \n\n<b>定理：</b>  假如a是一个整数，p是一个质数，那么\n  1. 如果a是p的倍数，$a^p\\equiv a \\pmod p$ \n  2. 如果a不是p的倍数，$a^{p-1}\\equiv 1 \\pmod p$  \n\n由乘法逆元的充要条件是gcd(a,p)&nbsp;=1&nbsp;，所以a不会是p的倍数，所以用第二条。将第二条转化以下有\n$$\na*a^{p-2}\\equiv 1\\pmod p\n$$\n则$a^{p-2}$就是a的逆元，证明自己去百度。\n\n最后利用快速幂求解即可。\n#### 快速幂\n快速幂即求解幂的快速算法。考察$3^{10}$,有\n$$3^{10}=9^{5}=9*81^{2}=9*6561^{1}=(9*6561)*1^{0}$$\n设幂为p，底数为b，则其算法思路为\n 1. 如果p是偶数，$b=b\\ast b$；p>>1\n 2. 如果p是奇数，那么$ans=ans\\ast b$；$b=b\\ast b$\n\n这样最后得到的结果即在ans中\n\n```c++\n#include<iostream>\nusing namespace std;\nconst long long mod =20100403;\nint n , m;\n\n// 求阶乘\nlong long fac(long long a){\n    long long ans=1;\n    for(long long i = a;i>=1;--i){\n       ans=(ans*i%mod)%mod;\n       ans=ans%mod;\n    }\n    return ans;\n}\n// 矩阵快速幂求逆元\nlong long Fpow(long long b,long long p){\n    long long ans=1;\n    while(p>0){\n        if(p%2==0){\n           b=(b*b)%mod;\n           p=p/2;\n        }else{\n           ans=(ans*b)%mod;\n           b=(b*b)%mod;\n           p=p/2;\n        }\n    }\n    return ans;\n}\n// 求组合数\nlong long C(int a,int b){\n    long long a1=fac(a);  // 求分子\n    long long b1=(fac(b)*fac(a-b))%mod; //分母\n    //求b的逆元\n    b1=Fpow(b1,mod-2);\n    return ((a1%mod)*(b1%mod))%mod;\n\n}\nint main(){\n    freopen(\"test/E.txt\",\"r\",stdin);\n    cin>>n>>m;\n    long long ans;\n    ans=(C(n+m,n)-C(n+m,n+1)+mod)%mod; // 可能会求得附属，所以先加上模再取模，因为计算结果是分别取模之后的，所以小的可能本来就比mod小\n    cout<<ans<<endl;\n}\n```\n\n\n\n\n\n\n","slug":"牛客欢乐赛8E","published":1,"updated":"2021-07-15T16:38:58.271Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckr74cdtb001m40tk05osfiv3","content":"<h2 id=\"题目链接\"><a href=\"#题目链接\" class=\"headerlink\" title=\"题目链接\"></a><a href=\"https://ac.nowcoder.com/acm/contest/17574/B\">题目链接</a></h2><h3 id=\"题目大意\"><a href=\"#题目大意\" class=\"headerlink\" title=\"题目大意\"></a>题目大意</h3><p>这题给你n个1和m个0，组成一个字符串，并且对任意一个前缀，1都不能比0少。</p>\n<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p>这是一道比较典型的卡特兰数题。我们可以将问题看作是求解(n+m,n-m)有多少种01字符串组合方式,n+m是字符总数，n-m是1比0多的个数。<br>从(0,0)开始，记将1放进集合记作操作1，将0放进集合记作操作2。</p>\n<ul>\n<li>进行操作1，集合变成(x+1,y+1),及向右上角走。</li>\n<li>进行操作2，集合变成(x+1,y-1)，即往右下角走</li>\n</ul>\n<p>最后目标是走到(n+m,n-m)。而如果y碰到y=-1这条线，那么就是非法的。<br>于是问题就变成了从(0,0)状态走到(n+m,n-m)状态一共有多少种合法的走法。(走：即向空字符串从头到尾填充0和1，不同的走法就实现了0和1的不同组合)</p>\n<ul>\n<li>如果考虑所有状况，则很明显是C(n+m,n)   （1要走n步，从n+m步中选出n步的种类，即长度为n+m的字符串中有n个为1有多少种）</li>\n<li>所有合法种类我们不好求，但是非法可求，则用合法的减去非法的种类。<ul>\n<li>非法的情况即碰过了y=-1的情况如图。 <img src=\"/2021/07/15/%E7%89%9B%E5%AE%A2%E6%AC%A2%E4%B9%90%E8%B5%9B8E/1.png\" class=\"\"></li>\n<li>将与y=-1的最后一个交点之前的部分以y=-1为轴对折，可以发现这种情况对应了一种从(0,-2)到(n+m,n-m)的情况。实际在我们这种对折规矩下，所有从(0,0)到(n+m,n-m)的非法情况都和由从(0,-2)到(n+m,n-m)的所有情况一一对应，则所有非法情况种类可以通过求(0,-2)到(n+m,n-m)的<b>所有</b>情况求出。(合法情况是不会对应从(0,-2)到(n+m,n-m)的，因为合法情况没有与y=-1的交点，所以无法与我们规定的这种翻折对应。)<img src=\"/2021/07/15/%E7%89%9B%E5%AE%A2%E6%AC%A2%E4%B9%90%E8%B5%9B8E/2.png\" class=\"\"></li>\n<li>非法情况是从(0,-2)到(n+m,n-m)，那么路径就要变。但是总的操作数不能变，因为横坐标还是0到n+m;<ul>\n<li>设操作1变为a种，操作2变为b种则<script type=\"math/tex; mode=display\">\n\\begin{cases}a+b=n+m\\\\a-b=n-m+2\\end{cases}</script>解得 <script type=\"math/tex; mode=display\">\n\\begin{cases}a=n+1 \\\\ b=m-1 \\end{cases}</script>则非法情况总数为C(n+m,n+1)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>最后ans=C(n+m,n)-C(n+m,n+1)</p>\n<h3 id=\"组合数求解\"><a href=\"#组合数求解\" class=\"headerlink\" title=\"组合数求解\"></a>组合数求解</h3><script type=\"math/tex; mode=display\">C{a\\atop m}\\pmod p=\\frac{n!}{m!(n-m!)}\\pmod p</script><p>可以看出，如果直接求解组合数然后再取模，那么分子或者分母会溢出。而取模分配率对加减乘成立，如对乘法有  </p>\n<p><center>(a&nbsp;*&nbsp;b)%p&nbsp;=&nbsp;[(a%p)&nbsp;*&nbsp;(b%p)]%p</center><br>但是对除法却不存在</p>\n<p><center>(a&nbsp;/&nbsp;b)%p&nbsp;=&nbsp;[(a%p)&nbsp;/&nbsp;(b%p)]%p&nbsp;(错误)</center><br>那怎么办呢，于是科学家们扔出了逆元这个玩意。  </p>\n<h4 id=\"逆元\"><a href=\"#逆元\" class=\"headerlink\" title=\"逆元\"></a>逆元</h4><p><b>定理</b>：若在mod&nbsp;p意义下，对于一个整数a，有</p>\n<script type=\"math/tex; mode=display\">\na*x\\equiv 1\\pmod p</script><p>那么这个整数x即为a的乘法逆元，同时a也为x的乘法逆元。  </p>\n<p><b>充要条件</b>：a存在模p的乘法逆元的充要条件是gcd(a,p)&nbsp;=1&nbsp;，即a与p互质。  </p>\n<p><b>应用</b>：求$\\frac{a}{b}\\%p$等同于求a * (b的逆元)%p   </p>\n<ul>\n<li><b>证明</b>：<br>我们假设 <script type=\"math/tex; mode=display\">\\frac{a}{b}\\%p=m(a和b满足a\\%b=0)\\tag{1}</script>由乘法逆元符合分配律对(1)式两边乘以b有<script type=\"math/tex; mode=display\">a\\%p=(m(b\\%p))\\%p\\tag{2}</script>即<script type=\"math/tex; mode=display\">a\\equiv m*b\\pmod p\\tag{3}</script>假设b的逆元是x，则(3)式两边乘以一个x有<script type=\"math/tex; mode=display\">a*x\\equiv m*b*x\\pmod p\\tag{4}</script>由逆元的定理有<br>$b\\ast x\\equiv 1\\pmod p$<br>则<script type=\"math/tex; mode=display\">a\\ast x\\equiv m\\pmod p\\tag{5}</script>证毕</li>\n</ul>\n<p>于是我们就可以把除法的求模运算转换为乘法的求模运算，从而可以利用分配律。</p>\n<p><b>类比</b>：其实逆元可以类比于普通乘法中的倒数，即当$b*x=1$时$\\frac{1}{b}=x$，但是在求模运算中，x与$\\frac{1}{b}$只是等同，而并非就是取倒数。</p>\n<h4 id=\"费马小定理\"><a href=\"#费马小定理\" class=\"headerlink\" title=\"费马小定理\"></a>费马小定理</h4><p>那么逆元怎么求解呢，可不是像普通乘法那样直接是倒数。则可以通过定义$a*x\\equiv1\\pmod p$来求解逆元。<br>由于在ACM中大多数时候p是质数，否则容易找到余数的规律，所以用费马里小定理即可求解a的逆元。  </p>\n<p><b>定理：</b>  假如a是一个整数，p是一个质数，那么</p>\n<ol>\n<li>如果a是p的倍数，$a^p\\equiv a \\pmod p$ </li>\n<li>如果a不是p的倍数，$a^{p-1}\\equiv 1 \\pmod p$  </li>\n</ol>\n<p>由乘法逆元的充要条件是gcd(a,p)&nbsp;=1&nbsp;，所以a不会是p的倍数，所以用第二条。将第二条转化以下有</p>\n<script type=\"math/tex; mode=display\">\na*a^{p-2}\\equiv 1\\pmod p</script><p>则$a^{p-2}$就是a的逆元，证明自己去百度。</p>\n<p>最后利用快速幂求解即可。</p>\n<h4 id=\"快速幂\"><a href=\"#快速幂\" class=\"headerlink\" title=\"快速幂\"></a>快速幂</h4><p>快速幂即求解幂的快速算法。考察$3^{10}$,有</p>\n<script type=\"math/tex; mode=display\">3^{10}=9^{5}=9*81^{2}=9*6561^{1}=(9*6561)*1^{0}</script><p>设幂为p，底数为b，则其算法思路为</p>\n<ol>\n<li>如果p是偶数，$b=b\\ast b$；p&gt;&gt;1</li>\n<li>如果p是奇数，那么$ans=ans\\ast b$；$b=b\\ast b$</li>\n</ol>\n<p>这样最后得到的结果即在ans中</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> mod =<span class=\"number\">20100403</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n , m;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 求阶乘</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> <span class=\"title\">fac</span><span class=\"params\">(<span class=\"keyword\">long</span> <span class=\"keyword\">long</span> a)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ans=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">long</span> <span class=\"keyword\">long</span> i = a;i&gt;=<span class=\"number\">1</span>;--i)&#123;</span><br><span class=\"line\">       ans=(ans*i%mod)%mod;</span><br><span class=\"line\">       ans=ans%mod;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 矩阵快速幂求逆元</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> <span class=\"title\">Fpow</span><span class=\"params\">(<span class=\"keyword\">long</span> <span class=\"keyword\">long</span> b,<span class=\"keyword\">long</span> <span class=\"keyword\">long</span> p)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ans=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p%<span class=\"number\">2</span>==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">           b=(b*b)%mod;</span><br><span class=\"line\">           p=p/<span class=\"number\">2</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">           ans=(ans*b)%mod;</span><br><span class=\"line\">           b=(b*b)%mod;</span><br><span class=\"line\">           p=p/<span class=\"number\">2</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 求组合数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> <span class=\"title\">C</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> a1=<span class=\"built_in\">fac</span>(a);  <span class=\"comment\">// 求分子</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> b1=(<span class=\"built_in\">fac</span>(b)*<span class=\"built_in\">fac</span>(a-b))%mod; <span class=\"comment\">//分母</span></span><br><span class=\"line\">    <span class=\"comment\">//求b的逆元</span></span><br><span class=\"line\">    b1=<span class=\"built_in\">Fpow</span>(b1,mod<span class=\"number\">-2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ((a1%mod)*(b1%mod))%mod;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">freopen</span>(<span class=\"string\">&quot;test/E.txt&quot;</span>,<span class=\"string\">&quot;r&quot;</span>,stdin);</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ans;</span><br><span class=\"line\">    ans=(<span class=\"built_in\">C</span>(n+m,n)-<span class=\"built_in\">C</span>(n+m,n+<span class=\"number\">1</span>)+mod)%mod; <span class=\"comment\">// 可能会求得附属，所以先加上模再取模，因为计算结果是分别取模之后的，所以小的可能本来就比mod小</span></span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"题目链接\"><a href=\"#题目链接\" class=\"headerlink\" title=\"题目链接\"></a><a href=\"https://ac.nowcoder.com/acm/contest/17574/B\">题目链接</a></h2><h3 id=\"题目大意\"><a href=\"#题目大意\" class=\"headerlink\" title=\"题目大意\"></a>题目大意</h3><p>这题给你n个1和m个0，组成一个字符串，并且对任意一个前缀，1都不能比0少。</p>\n<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p>这是一道比较典型的卡特兰数题。我们可以将问题看作是求解(n+m,n-m)有多少种01字符串组合方式,n+m是字符总数，n-m是1比0多的个数。<br>从(0,0)开始，记将1放进集合记作操作1，将0放进集合记作操作2。</p>\n<ul>\n<li>进行操作1，集合变成(x+1,y+1),及向右上角走。</li>\n<li>进行操作2，集合变成(x+1,y-1)，即往右下角走</li>\n</ul>\n<p>最后目标是走到(n+m,n-m)。而如果y碰到y=-1这条线，那么就是非法的。<br>于是问题就变成了从(0,0)状态走到(n+m,n-m)状态一共有多少种合法的走法。(走：即向空字符串从头到尾填充0和1，不同的走法就实现了0和1的不同组合)</p>\n<ul>\n<li>如果考虑所有状况，则很明显是C(n+m,n)   （1要走n步，从n+m步中选出n步的种类，即长度为n+m的字符串中有n个为1有多少种）</li>\n<li>所有合法种类我们不好求，但是非法可求，则用合法的减去非法的种类。<ul>\n<li>非法的情况即碰过了y=-1的情况如图。 <img src=\"/2021/07/15/%E7%89%9B%E5%AE%A2%E6%AC%A2%E4%B9%90%E8%B5%9B8E/1.png\" class=\"\"></li>\n<li>将与y=-1的最后一个交点之前的部分以y=-1为轴对折，可以发现这种情况对应了一种从(0,-2)到(n+m,n-m)的情况。实际在我们这种对折规矩下，所有从(0,0)到(n+m,n-m)的非法情况都和由从(0,-2)到(n+m,n-m)的所有情况一一对应，则所有非法情况种类可以通过求(0,-2)到(n+m,n-m)的<b>所有</b>情况求出。(合法情况是不会对应从(0,-2)到(n+m,n-m)的，因为合法情况没有与y=-1的交点，所以无法与我们规定的这种翻折对应。)<img src=\"/2021/07/15/%E7%89%9B%E5%AE%A2%E6%AC%A2%E4%B9%90%E8%B5%9B8E/2.png\" class=\"\"></li>\n<li>非法情况是从(0,-2)到(n+m,n-m)，那么路径就要变。但是总的操作数不能变，因为横坐标还是0到n+m;<ul>\n<li>设操作1变为a种，操作2变为b种则<script type=\"math/tex; mode=display\">\n\\begin{cases}a+b=n+m\\\\a-b=n-m+2\\end{cases}</script>解得 <script type=\"math/tex; mode=display\">\n\\begin{cases}a=n+1 \\\\ b=m-1 \\end{cases}</script>则非法情况总数为C(n+m,n+1)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>最后ans=C(n+m,n)-C(n+m,n+1)</p>\n<h3 id=\"组合数求解\"><a href=\"#组合数求解\" class=\"headerlink\" title=\"组合数求解\"></a>组合数求解</h3><script type=\"math/tex; mode=display\">C{a\\atop m}\\pmod p=\\frac{n!}{m!(n-m!)}\\pmod p</script><p>可以看出，如果直接求解组合数然后再取模，那么分子或者分母会溢出。而取模分配率对加减乘成立，如对乘法有  </p>\n<p><center>(a&nbsp;*&nbsp;b)%p&nbsp;=&nbsp;[(a%p)&nbsp;*&nbsp;(b%p)]%p</center><br>但是对除法却不存在</p>\n<p><center>(a&nbsp;/&nbsp;b)%p&nbsp;=&nbsp;[(a%p)&nbsp;/&nbsp;(b%p)]%p&nbsp;(错误)</center><br>那怎么办呢，于是科学家们扔出了逆元这个玩意。  </p>\n<h4 id=\"逆元\"><a href=\"#逆元\" class=\"headerlink\" title=\"逆元\"></a>逆元</h4><p><b>定理</b>：若在mod&nbsp;p意义下，对于一个整数a，有</p>\n<script type=\"math/tex; mode=display\">\na*x\\equiv 1\\pmod p</script><p>那么这个整数x即为a的乘法逆元，同时a也为x的乘法逆元。  </p>\n<p><b>充要条件</b>：a存在模p的乘法逆元的充要条件是gcd(a,p)&nbsp;=1&nbsp;，即a与p互质。  </p>\n<p><b>应用</b>：求$\\frac{a}{b}\\%p$等同于求a * (b的逆元)%p   </p>\n<ul>\n<li><b>证明</b>：<br>我们假设 <script type=\"math/tex; mode=display\">\\frac{a}{b}\\%p=m(a和b满足a\\%b=0)\\tag{1}</script>由乘法逆元符合分配律对(1)式两边乘以b有<script type=\"math/tex; mode=display\">a\\%p=(m(b\\%p))\\%p\\tag{2}</script>即<script type=\"math/tex; mode=display\">a\\equiv m*b\\pmod p\\tag{3}</script>假设b的逆元是x，则(3)式两边乘以一个x有<script type=\"math/tex; mode=display\">a*x\\equiv m*b*x\\pmod p\\tag{4}</script>由逆元的定理有<br>$b\\ast x\\equiv 1\\pmod p$<br>则<script type=\"math/tex; mode=display\">a\\ast x\\equiv m\\pmod p\\tag{5}</script>证毕</li>\n</ul>\n<p>于是我们就可以把除法的求模运算转换为乘法的求模运算，从而可以利用分配律。</p>\n<p><b>类比</b>：其实逆元可以类比于普通乘法中的倒数，即当$b*x=1$时$\\frac{1}{b}=x$，但是在求模运算中，x与$\\frac{1}{b}$只是等同，而并非就是取倒数。</p>\n<h4 id=\"费马小定理\"><a href=\"#费马小定理\" class=\"headerlink\" title=\"费马小定理\"></a>费马小定理</h4><p>那么逆元怎么求解呢，可不是像普通乘法那样直接是倒数。则可以通过定义$a*x\\equiv1\\pmod p$来求解逆元。<br>由于在ACM中大多数时候p是质数，否则容易找到余数的规律，所以用费马里小定理即可求解a的逆元。  </p>\n<p><b>定理：</b>  假如a是一个整数，p是一个质数，那么</p>\n<ol>\n<li>如果a是p的倍数，$a^p\\equiv a \\pmod p$ </li>\n<li>如果a不是p的倍数，$a^{p-1}\\equiv 1 \\pmod p$  </li>\n</ol>\n<p>由乘法逆元的充要条件是gcd(a,p)&nbsp;=1&nbsp;，所以a不会是p的倍数，所以用第二条。将第二条转化以下有</p>\n<script type=\"math/tex; mode=display\">\na*a^{p-2}\\equiv 1\\pmod p</script><p>则$a^{p-2}$就是a的逆元，证明自己去百度。</p>\n<p>最后利用快速幂求解即可。</p>\n<h4 id=\"快速幂\"><a href=\"#快速幂\" class=\"headerlink\" title=\"快速幂\"></a>快速幂</h4><p>快速幂即求解幂的快速算法。考察$3^{10}$,有</p>\n<script type=\"math/tex; mode=display\">3^{10}=9^{5}=9*81^{2}=9*6561^{1}=(9*6561)*1^{0}</script><p>设幂为p，底数为b，则其算法思路为</p>\n<ol>\n<li>如果p是偶数，$b=b\\ast b$；p&gt;&gt;1</li>\n<li>如果p是奇数，那么$ans=ans\\ast b$；$b=b\\ast b$</li>\n</ol>\n<p>这样最后得到的结果即在ans中</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> mod =<span class=\"number\">20100403</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> n , m;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 求阶乘</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> <span class=\"title\">fac</span><span class=\"params\">(<span class=\"keyword\">long</span> <span class=\"keyword\">long</span> a)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ans=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">long</span> <span class=\"keyword\">long</span> i = a;i&gt;=<span class=\"number\">1</span>;--i)&#123;</span><br><span class=\"line\">       ans=(ans*i%mod)%mod;</span><br><span class=\"line\">       ans=ans%mod;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 矩阵快速幂求逆元</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> <span class=\"title\">Fpow</span><span class=\"params\">(<span class=\"keyword\">long</span> <span class=\"keyword\">long</span> b,<span class=\"keyword\">long</span> <span class=\"keyword\">long</span> p)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ans=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p&gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p%<span class=\"number\">2</span>==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">           b=(b*b)%mod;</span><br><span class=\"line\">           p=p/<span class=\"number\">2</span>;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">           ans=(ans*b)%mod;</span><br><span class=\"line\">           b=(b*b)%mod;</span><br><span class=\"line\">           p=p/<span class=\"number\">2</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 求组合数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> <span class=\"title\">C</span><span class=\"params\">(<span class=\"keyword\">int</span> a,<span class=\"keyword\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> a1=<span class=\"built_in\">fac</span>(a);  <span class=\"comment\">// 求分子</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> b1=(<span class=\"built_in\">fac</span>(b)*<span class=\"built_in\">fac</span>(a-b))%mod; <span class=\"comment\">//分母</span></span><br><span class=\"line\">    <span class=\"comment\">//求b的逆元</span></span><br><span class=\"line\">    b1=<span class=\"built_in\">Fpow</span>(b1,mod<span class=\"number\">-2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ((a1%mod)*(b1%mod))%mod;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">freopen</span>(<span class=\"string\">&quot;test/E.txt&quot;</span>,<span class=\"string\">&quot;r&quot;</span>,stdin);</span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ans;</span><br><span class=\"line\">    ans=(<span class=\"built_in\">C</span>(n+m,n)-<span class=\"built_in\">C</span>(n+m,n+<span class=\"number\">1</span>)+mod)%mod; <span class=\"comment\">// 可能会求得附属，所以先加上模再取模，因为计算结果是分别取模之后的，所以小的可能本来就比mod小</span></span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"数据离散化","date":"2021-08-10T02:41:22.000Z","_content":"### 定义\n离散化，就是当我们只关心数据的大小关系的时候，用排名代替原数据进行处理的一种预处理方法。他保持元序列大小关系的前提下把他映射成正整数。\n比如一个元素要当数组下标，但是他很大，或者是负数，就会失败，这时候就要离散化。\n\n例如我们有序列$A=[8,20,30,4,-20,4]$\n* 我们先复制一个相同的序列B\n* 然后对B进行排序，去重（去掉重复的元素）\n   \n  std::unique()会删除相邻的相同的元素，把后面的元素往前移动，并返回去重后容器中不重复序列的最后一个元素的下一个位置的地址，所以减去首地址就可以得到长度。\n  ```c++\n  sort(B,B+n);\n  int L=unique(B,B+n)-B; // L是不重复的数量\n  ```\n* 那么现在$B=[-20,4,8,20,30]$\n* 用一个数组C存储A中每个元素在B中的排名\n  lower_bound()函数返回的是数组中大于等于的一个个元素的地址\n  ```c++\n  for(int i=0;i<n;++i){\n      C[i]=lower_bound(B,B+L,A[i])-B+1\n  }\n  ```\n* 现在$C=[3,4,5,2,1,2]$,就实现了离散化\n\n完整代码\n```C++\nint B[maxn];\nint C[maxn];\nfor(int i = 0;i<n;++i){\n    B[i]=A[i];\n}\nsort(B,B+n);      // 排序\nint L=unique(B,B+n)-B;  // 去重\n// 存排名\nfor(int i = 0;i<n;++i){\n    C[i]=lower_bound(B,B+L,A[i])-B+1;\n}\n\n\n```\n\n","source":"_posts/数据离散化.md","raw":"---\ntitle: 数据离散化\ndate: 2021-08-10 10:41:22\ntags:\n- 离散化\n---\n### 定义\n离散化，就是当我们只关心数据的大小关系的时候，用排名代替原数据进行处理的一种预处理方法。他保持元序列大小关系的前提下把他映射成正整数。\n比如一个元素要当数组下标，但是他很大，或者是负数，就会失败，这时候就要离散化。\n\n例如我们有序列$A=[8,20,30,4,-20,4]$\n* 我们先复制一个相同的序列B\n* 然后对B进行排序，去重（去掉重复的元素）\n   \n  std::unique()会删除相邻的相同的元素，把后面的元素往前移动，并返回去重后容器中不重复序列的最后一个元素的下一个位置的地址，所以减去首地址就可以得到长度。\n  ```c++\n  sort(B,B+n);\n  int L=unique(B,B+n)-B; // L是不重复的数量\n  ```\n* 那么现在$B=[-20,4,8,20,30]$\n* 用一个数组C存储A中每个元素在B中的排名\n  lower_bound()函数返回的是数组中大于等于的一个个元素的地址\n  ```c++\n  for(int i=0;i<n;++i){\n      C[i]=lower_bound(B,B+L,A[i])-B+1\n  }\n  ```\n* 现在$C=[3,4,5,2,1,2]$,就实现了离散化\n\n完整代码\n```C++\nint B[maxn];\nint C[maxn];\nfor(int i = 0;i<n;++i){\n    B[i]=A[i];\n}\nsort(B,B+n);      // 排序\nint L=unique(B,B+n)-B;  // 去重\n// 存排名\nfor(int i = 0;i<n;++i){\n    C[i]=lower_bound(B,B+L,A[i])-B+1;\n}\n\n\n```\n\n","slug":"数据离散化","published":1,"updated":"2021-08-10T03:05:49.326Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5hf3nc00009ctk7ewvhj2f","content":"<h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>离散化，就是当我们只关心数据的大小关系的时候，用排名代替原数据进行处理的一种预处理方法。他保持元序列大小关系的前提下把他映射成正整数。<br>比如一个元素要当数组下标，但是他很大，或者是负数，就会失败，这时候就要离散化。</p>\n<p>例如我们有序列$A=[8,20,30,4,-20,4]$</p>\n<ul>\n<li>我们先复制一个相同的序列B</li>\n<li><p>然后对B进行排序，去重（去掉重复的元素）</p>\n<p>std::unique()会删除相邻的相同的元素，把后面的元素往前移动，并返回去重后容器中不重复序列的最后一个元素的下一个位置的地址，所以减去首地址就可以得到长度。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sort</span>(B,B+n);</span><br><span class=\"line\"><span class=\"keyword\">int</span> L=<span class=\"built_in\">unique</span>(B,B+n)-B; <span class=\"comment\">// L是不重复的数量</span></span><br></pre></td></tr></table></figure></li>\n<li>那么现在$B=[-20,4,8,20,30]$</li>\n<li>用一个数组C存储A中每个元素在B中的排名<br>lower_bound()函数返回的是数组中大于等于的一个个元素的地址<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">    C[i]=<span class=\"built_in\">lower_bound</span>(B,B+L,A[i])-B+<span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>现在$C=[3,4,5,2,1,2]$,就实现了离散化</li>\n</ul>\n<p>完整代码<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> B[maxn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> C[maxn];</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">    B[i]=A[i];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">sort</span>(B,B+n);      <span class=\"comment\">// 排序</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> L=<span class=\"built_in\">unique</span>(B,B+n)-B;  <span class=\"comment\">// 去重</span></span><br><span class=\"line\"><span class=\"comment\">// 存排名</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">    C[i]=<span class=\"built_in\">lower_bound</span>(B,B+L,A[i])-B+<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>离散化，就是当我们只关心数据的大小关系的时候，用排名代替原数据进行处理的一种预处理方法。他保持元序列大小关系的前提下把他映射成正整数。<br>比如一个元素要当数组下标，但是他很大，或者是负数，就会失败，这时候就要离散化。</p>\n<p>例如我们有序列$A=[8,20,30,4,-20,4]$</p>\n<ul>\n<li>我们先复制一个相同的序列B</li>\n<li><p>然后对B进行排序，去重（去掉重复的元素）</p>\n<p>std::unique()会删除相邻的相同的元素，把后面的元素往前移动，并返回去重后容器中不重复序列的最后一个元素的下一个位置的地址，所以减去首地址就可以得到长度。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sort</span>(B,B+n);</span><br><span class=\"line\"><span class=\"keyword\">int</span> L=<span class=\"built_in\">unique</span>(B,B+n)-B; <span class=\"comment\">// L是不重复的数量</span></span><br></pre></td></tr></table></figure></li>\n<li>那么现在$B=[-20,4,8,20,30]$</li>\n<li>用一个数组C存储A中每个元素在B中的排名<br>lower_bound()函数返回的是数组中大于等于的一个个元素的地址<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">    C[i]=<span class=\"built_in\">lower_bound</span>(B,B+L,A[i])-B+<span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>现在$C=[3,4,5,2,1,2]$,就实现了离散化</li>\n</ul>\n<p>完整代码<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> B[maxn];</span><br><span class=\"line\"><span class=\"keyword\">int</span> C[maxn];</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">    B[i]=A[i];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">sort</span>(B,B+n);      <span class=\"comment\">// 排序</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> L=<span class=\"built_in\">unique</span>(B,B+n)-B;  <span class=\"comment\">// 去重</span></span><br><span class=\"line\"><span class=\"comment\">// 存排名</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">    C[i]=<span class=\"built_in\">lower_bound</span>(B,B+L,A[i])-B+<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n"},{"title":"第一周周赛","date":"2021-07-19T08:40:02.000Z","catagories":["周赛"],"_content":"# 第一周周赛报告\n## G[2022年WUT集训计划](https://www.luogu.com.cn/contest/47145#problems)\n\n#### 大意与分析\n题目就是求所有acmer可以到达的房间有多少个。刚开始用floyd，然后成功套老鹅。\n然后用搜索，搜索每个房间知否都对所有的成员可达。进行队员与房间的一对一搜索，造成了时间浪费。\n实际上解法是每个队员把房间走一遍，然后记录每个房间被走的次数$sum[i]$，如果sum[i]为队员的总数，则这个房间可用。这样保证了每个房间只会被每个队员走一次。复杂度O(KN)。\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n#define TLE ios::sync_with_stdio(0),cin.tie(0)\nint K,N,M;\nint acm[105];\nint a[1007][1007]={0};\nbool visit[1007];\nint sum[1007]={0};\nint ans=0;\n// r存放前一个\nvoid dfs(int i){\n    for(int j = 1;j<=N;++j){\n       if(!visit[j]&&a[i][j]==1){\n           visit[j]=true;\n           sum[j]++;\n           dfs(j);\n       }\n    }\n}\nint main(){ \n    TLE;\n    //freopen(\"test/G.txt\",\"r\",stdin);\n    cin>>K>>N>>M;\n    for(int i =1;i<=K;++i){\n          cin>>acm[i];\n    }\n    for(int i = 1;i<=N;++i){\n        for(int j = 1;j<=N;++j){\n           a[i][j]=0;\n        }\n        a[i][i]=1;\n    }\n    int x,y;\n    for(int i = 1;i<=M;++i){\n        cin>>x>>y;\n        a[x][y]=1;\n    }\n    for(int i = 1;i<=K;++i){\n        for(int j = 1;j<=N;++j){\n            visit[j]=false;\n        }\n        sum[acm[i]]++;\n        visit[acm[i]]=true;\n        dfs(acm[i]); \n    }\n    for(int i = 1;i<=N;++i){\n        if(sum[i]==K){\n            ans++;\n        }\n    }\n    cout<<ans<<endl;\n}\n```\n\n## B[学园偶像祭](https://www.luogu.com.cn/problem/T186964?contestId=47145)\n\n### 分析\n题目好长，没想到用二分写，看到标签为二分的时候就跑去用2分补提。\n刚开始WA是没考虑到如果l=r-1且答案偏小的话，就会死循环，因为l=ans=l。\n考虑到这点之后还是WA WA WA，看了题解发现是要开unsign long long ,这也是做了那么久题第一次碰到这么大的数据，以后注意。\n```c++\n#include<iostream>\n#include<math.h>\nusing namespace std;\nunsigned long long n,S,L;\nunsigned long long A[200005];\nunsigned long long ans=0;\nunsigned long long u[200005];\nunsigned long long l=0;\nunsigned long long r=1e18;\n\nint main(){\n    \n    //freopen(\"test/A.txt\",\"r\",stdin);\n    cin>>n>>S>>L;\n    for(int i=0;i<n;++i){\n        cin>>A[i];\n    }\n    for(int j = 0;j<n;++j){\n        cin>>u[j];\n    }\n    while(r!=l){\n        ans=(r+l)/2;\n        unsigned long long sum=0;\n        for(int i =0;i<n;++i){\n           if(A[i]+u[i]*ans>=L){\n               sum+=A[i]+u[i]*ans;\n           }\n        }\n        if(sum>S){\n            r=ans;\n        }else if(sum<S){\n            if(r-l==1){\n                ans=r;\n                break;\n            }\n            l=ans;\n        }else{\n            break;\n        }\n    }\n\n    cout<<ans<<endl;\n}\n```\n\n## B[iyua买装备](https://www.luogu.com.cn/problem/T186977)\n\n### 分析\n题目要求在最小力量初值的前提下的最小精神初值，则可以先求最小力量初值。\n* 求最小能量初值：使用优先队列小顶堆Q1存储每个结点，结点的需求力量低的优先级高。每次将当前拥有能量值sum1和堆顶装备所需能量值a[i]比较，如果够，则穿上这个装备，如果不够，则初始能量要加上差值a[i]-sum1，一直到清空队列即可。\n* 求最小精神：建立另外一个小顶堆Q2，所需精神值小的优先级高。\n   1. 设目前有的力量为beg，则我们可以从Q1中选出当前拥有能量值的情况下所能装上的所有装备，放到Q2中。\n   2. 如果当前精神值sum2比Q2中的堆顶所需要的精神值b[i]大，则穿上这个装备，更新当前力量值beg，回到1继续看看能不能有更多的装备可选择。\n   3. 如果当前精神值sum2比Q2中的堆顶所需要的精神值小，则必须让初始精神值加上b[i]-sum2。\n   4. 重复上述步骤直到清空两个队列\n\n\n\n```c++\n#include<iostream>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nlong long  T;\nlong long n;\ntypedef struct ELE{\nlong long a;\nlong long b;\nlong long c;\nlong long d;\n}Ele;\n\n// 重写力量小根堆\ntypedef struct cmp1{\n    bool operator () (Ele a,Ele b){\n        if(a.a==b.a){\n            return a.b>b.b;\n        }\n        return a.a>b.a;\n    }\n}cmp1;\n\n// 重写智慧小根堆\ntypedef struct cmp2{\n    bool operator()(Ele a,Ele b){\n        return a.b>b.b;\n    }\n}cmp2;\nEle ele[100004];\nlong long ans1=0;\nlong long sum1=0;\nlong long ans2=0;\nlong long sum2=0;   // 记录当前精神的和\nint main(){\n    //freopen(\"test/A.txt\",\"r\",stdin);\n    cin>>T;\n    cin>>n;\n    priority_queue<Ele,vector<Ele>,cmp1> Q1 ;  // 力量从小到大的小根堆\n    priority_queue<Ele,vector<Ele>,cmp2> Q2;  // 精神从小到大的小根堆\n    for(int i =0;i<n;++i){\n        cin>>ele[i].a>>ele[i].b>>ele[i].c>>ele[i].d;\n        Q1.push(ele[i]); \n    }\n    // for(int i = 0;i<n;++i){\n    //     cout<<Q1.top().a<<\" \"<<Q1.top().b<<endl;\n    //     Q1.pop();\n    // }\n    // cout<<endl;\n    // for(int i = 0;i<n;++i){\n    //     cout<<Q2.top().a<<\" \"<<Q2.top().b<<endl;\n    //     Q2.pop();\n    // }\n    // cout<<endl;\n    \n    // 求出最小的力量值\n    while(!Q1.empty()){\n       Ele p=Q1.top();\n       Q1.pop();\n       if(sum1>=p.a){// 当前的力量够穿\n          sum1+=p.c;\n          continue;\n       }else{   // 不够穿的时候要更新初始值\n          ans1+=p.a-sum1;\n          sum1=p.a+p.c;\n       }\n    }\n\n    // Q1还要用\n    for(int i = 0;i<n;++i){\n        Q1.push(ele[i]);\n    }\n\n    long long beg=ans1;  // 记录最小初始力量\n    // 在力量最小值开始满足的情况下，争取精神最小\n    while(!Q1.empty()||!Q2.empty()){   // 全部选完之后两个队列都为空\n         Ele p;\n        // 选出当前力量值下Q1中所有可取装备 \n        while(!Q1.empty()){ \n            if(beg<Q1.top().a){  \n                break;\n            }\n            // 可以穿的放到Q2,但是这里害不能穿\n            p=Q1.top();\n            Q2.push(p);\n            Q1.pop();\n        }\n        // 尝试穿一件\n        if(!Q2.empty()){\n        p=Q2.top();\n        Q2.pop();\n        if(sum2>=p.b){ // 当前精神值够穿\n            sum2+=p.d;\n        }else{\n            ans2+=p.b-sum2;\n            sum2+=p.b-sum2+p.d;\n        }\n        beg+=p.c;  // 选了之后要加上力量\n        }\n    }\n    cout<<ans1<<\" \"<<ans2<<endl;\n    \n    \n}\n```\n\n## D[小L的测量学外业](https://www.luogu.com.cn/problem/T186968?contestId=47145)\n\n补的时候看到最短路标签就直接广搜，但是这个题要的不是步数最短，而实拐角最短，所以是先使劲往一个方向搜到墙，再往其方向搜。已经入过队的点不用再入队，但是应该能被经过多次。\n```c++\n#include<iostream>\n#include<queue>\nusing namespace std;\ntypedef struct Node{\n    int x,y;     // 当前结点的位置\n    int step=0;  // 当前的转角数\n}Node;\nbool visit[103][103];  // 某个点是否已经访问过，即已经入队\nint Move[4][2]={{0,1},{0,-1},{-1,0},{1,0}};   // 移动\nint W;\nint H;\nchar str[103][103];\nint BX;\nint BY; // 开始结点\nvoid bfs(){\n     queue<Node> Q;\n     Node p;\n     p.x=BX;\n     p.y=BY;\n     Q.push(p);\n     while(!Q.empty()){\n         p=Q.front();\n         Q.pop();\n         int lx=p.x;\n         int ly=p.y;\n         int step=p.step;\n         for(int e=0;e<4;++e){\n             int nx=lx+Move[e][0];\n             int ny=ly+Move[e][1];\n             // 沿着一条线一直走，直到撞墙\n             while(nx<W&&nx>=0&&ny<H&&ny>=0&&str[nx][ny]!='*'){\n                 if(str[nx][ny]=='C'){\n                     //cout<<e<<\" \"<<nx<<\" \"<<ny<<endl;\n                 }\n                 if(str[nx][ny]=='C'&&!(BX==nx&&BY==ny)){  // 找到了\n                     cout<<step<<endl;\n                     return ; \n                 }\n                 if(!visit[nx][ny]){  // 没遍历过的结点入队                  \n                   p.x=nx;\n                   p.y=ny;\n                   p.step=step+1;\n                   visit[nx][ny]=true;\n                   Q.push(p);\n                 }\n                 nx+=Move[e][0];\n                 ny+=Move[e][1];\n             }\n\n         }\n     }\n     \n\n    \n}\nint main(){\n    //freopen(\"test/D.txt\",\"r\",stdin);\n    cin>>H>>W;\n    for(int i = 0;i<W;++i){\n        cin>>str[i];\n    }\n    for(int i = 0;i<W;++i){\n        for(int j = 0;j<H;++j){\n            visit[i][j]=false;\n        }\n    }\n    // 选出开始结点\n    bool flag=true;\n    for(int i = 0;i<W;++i){\n        for(int j = 0;j<H;++j){\n            if(str[i][j]=='C'){\n                visit[i][j]=true;\n                BX=i;\n                BY=j;\n                flag=false;\n                break;\n            }\n        }\n        if(!flag){\n            break;\n        }\n    }\n    bfs();\n\n}\n```\n      \n\n\n\n","source":"_posts/第一周周赛.md","raw":"---\ntitle: 第一周周赛\ndate: 2021-07-19 16:40:02\ncatagories:\n - 周赛\n---\n# 第一周周赛报告\n## G[2022年WUT集训计划](https://www.luogu.com.cn/contest/47145#problems)\n\n#### 大意与分析\n题目就是求所有acmer可以到达的房间有多少个。刚开始用floyd，然后成功套老鹅。\n然后用搜索，搜索每个房间知否都对所有的成员可达。进行队员与房间的一对一搜索，造成了时间浪费。\n实际上解法是每个队员把房间走一遍，然后记录每个房间被走的次数$sum[i]$，如果sum[i]为队员的总数，则这个房间可用。这样保证了每个房间只会被每个队员走一次。复杂度O(KN)。\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n#define TLE ios::sync_with_stdio(0),cin.tie(0)\nint K,N,M;\nint acm[105];\nint a[1007][1007]={0};\nbool visit[1007];\nint sum[1007]={0};\nint ans=0;\n// r存放前一个\nvoid dfs(int i){\n    for(int j = 1;j<=N;++j){\n       if(!visit[j]&&a[i][j]==1){\n           visit[j]=true;\n           sum[j]++;\n           dfs(j);\n       }\n    }\n}\nint main(){ \n    TLE;\n    //freopen(\"test/G.txt\",\"r\",stdin);\n    cin>>K>>N>>M;\n    for(int i =1;i<=K;++i){\n          cin>>acm[i];\n    }\n    for(int i = 1;i<=N;++i){\n        for(int j = 1;j<=N;++j){\n           a[i][j]=0;\n        }\n        a[i][i]=1;\n    }\n    int x,y;\n    for(int i = 1;i<=M;++i){\n        cin>>x>>y;\n        a[x][y]=1;\n    }\n    for(int i = 1;i<=K;++i){\n        for(int j = 1;j<=N;++j){\n            visit[j]=false;\n        }\n        sum[acm[i]]++;\n        visit[acm[i]]=true;\n        dfs(acm[i]); \n    }\n    for(int i = 1;i<=N;++i){\n        if(sum[i]==K){\n            ans++;\n        }\n    }\n    cout<<ans<<endl;\n}\n```\n\n## B[学园偶像祭](https://www.luogu.com.cn/problem/T186964?contestId=47145)\n\n### 分析\n题目好长，没想到用二分写，看到标签为二分的时候就跑去用2分补提。\n刚开始WA是没考虑到如果l=r-1且答案偏小的话，就会死循环，因为l=ans=l。\n考虑到这点之后还是WA WA WA，看了题解发现是要开unsign long long ,这也是做了那么久题第一次碰到这么大的数据，以后注意。\n```c++\n#include<iostream>\n#include<math.h>\nusing namespace std;\nunsigned long long n,S,L;\nunsigned long long A[200005];\nunsigned long long ans=0;\nunsigned long long u[200005];\nunsigned long long l=0;\nunsigned long long r=1e18;\n\nint main(){\n    \n    //freopen(\"test/A.txt\",\"r\",stdin);\n    cin>>n>>S>>L;\n    for(int i=0;i<n;++i){\n        cin>>A[i];\n    }\n    for(int j = 0;j<n;++j){\n        cin>>u[j];\n    }\n    while(r!=l){\n        ans=(r+l)/2;\n        unsigned long long sum=0;\n        for(int i =0;i<n;++i){\n           if(A[i]+u[i]*ans>=L){\n               sum+=A[i]+u[i]*ans;\n           }\n        }\n        if(sum>S){\n            r=ans;\n        }else if(sum<S){\n            if(r-l==1){\n                ans=r;\n                break;\n            }\n            l=ans;\n        }else{\n            break;\n        }\n    }\n\n    cout<<ans<<endl;\n}\n```\n\n## B[iyua买装备](https://www.luogu.com.cn/problem/T186977)\n\n### 分析\n题目要求在最小力量初值的前提下的最小精神初值，则可以先求最小力量初值。\n* 求最小能量初值：使用优先队列小顶堆Q1存储每个结点，结点的需求力量低的优先级高。每次将当前拥有能量值sum1和堆顶装备所需能量值a[i]比较，如果够，则穿上这个装备，如果不够，则初始能量要加上差值a[i]-sum1，一直到清空队列即可。\n* 求最小精神：建立另外一个小顶堆Q2，所需精神值小的优先级高。\n   1. 设目前有的力量为beg，则我们可以从Q1中选出当前拥有能量值的情况下所能装上的所有装备，放到Q2中。\n   2. 如果当前精神值sum2比Q2中的堆顶所需要的精神值b[i]大，则穿上这个装备，更新当前力量值beg，回到1继续看看能不能有更多的装备可选择。\n   3. 如果当前精神值sum2比Q2中的堆顶所需要的精神值小，则必须让初始精神值加上b[i]-sum2。\n   4. 重复上述步骤直到清空两个队列\n\n\n\n```c++\n#include<iostream>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nlong long  T;\nlong long n;\ntypedef struct ELE{\nlong long a;\nlong long b;\nlong long c;\nlong long d;\n}Ele;\n\n// 重写力量小根堆\ntypedef struct cmp1{\n    bool operator () (Ele a,Ele b){\n        if(a.a==b.a){\n            return a.b>b.b;\n        }\n        return a.a>b.a;\n    }\n}cmp1;\n\n// 重写智慧小根堆\ntypedef struct cmp2{\n    bool operator()(Ele a,Ele b){\n        return a.b>b.b;\n    }\n}cmp2;\nEle ele[100004];\nlong long ans1=0;\nlong long sum1=0;\nlong long ans2=0;\nlong long sum2=0;   // 记录当前精神的和\nint main(){\n    //freopen(\"test/A.txt\",\"r\",stdin);\n    cin>>T;\n    cin>>n;\n    priority_queue<Ele,vector<Ele>,cmp1> Q1 ;  // 力量从小到大的小根堆\n    priority_queue<Ele,vector<Ele>,cmp2> Q2;  // 精神从小到大的小根堆\n    for(int i =0;i<n;++i){\n        cin>>ele[i].a>>ele[i].b>>ele[i].c>>ele[i].d;\n        Q1.push(ele[i]); \n    }\n    // for(int i = 0;i<n;++i){\n    //     cout<<Q1.top().a<<\" \"<<Q1.top().b<<endl;\n    //     Q1.pop();\n    // }\n    // cout<<endl;\n    // for(int i = 0;i<n;++i){\n    //     cout<<Q2.top().a<<\" \"<<Q2.top().b<<endl;\n    //     Q2.pop();\n    // }\n    // cout<<endl;\n    \n    // 求出最小的力量值\n    while(!Q1.empty()){\n       Ele p=Q1.top();\n       Q1.pop();\n       if(sum1>=p.a){// 当前的力量够穿\n          sum1+=p.c;\n          continue;\n       }else{   // 不够穿的时候要更新初始值\n          ans1+=p.a-sum1;\n          sum1=p.a+p.c;\n       }\n    }\n\n    // Q1还要用\n    for(int i = 0;i<n;++i){\n        Q1.push(ele[i]);\n    }\n\n    long long beg=ans1;  // 记录最小初始力量\n    // 在力量最小值开始满足的情况下，争取精神最小\n    while(!Q1.empty()||!Q2.empty()){   // 全部选完之后两个队列都为空\n         Ele p;\n        // 选出当前力量值下Q1中所有可取装备 \n        while(!Q1.empty()){ \n            if(beg<Q1.top().a){  \n                break;\n            }\n            // 可以穿的放到Q2,但是这里害不能穿\n            p=Q1.top();\n            Q2.push(p);\n            Q1.pop();\n        }\n        // 尝试穿一件\n        if(!Q2.empty()){\n        p=Q2.top();\n        Q2.pop();\n        if(sum2>=p.b){ // 当前精神值够穿\n            sum2+=p.d;\n        }else{\n            ans2+=p.b-sum2;\n            sum2+=p.b-sum2+p.d;\n        }\n        beg+=p.c;  // 选了之后要加上力量\n        }\n    }\n    cout<<ans1<<\" \"<<ans2<<endl;\n    \n    \n}\n```\n\n## D[小L的测量学外业](https://www.luogu.com.cn/problem/T186968?contestId=47145)\n\n补的时候看到最短路标签就直接广搜，但是这个题要的不是步数最短，而实拐角最短，所以是先使劲往一个方向搜到墙，再往其方向搜。已经入过队的点不用再入队，但是应该能被经过多次。\n```c++\n#include<iostream>\n#include<queue>\nusing namespace std;\ntypedef struct Node{\n    int x,y;     // 当前结点的位置\n    int step=0;  // 当前的转角数\n}Node;\nbool visit[103][103];  // 某个点是否已经访问过，即已经入队\nint Move[4][2]={{0,1},{0,-1},{-1,0},{1,0}};   // 移动\nint W;\nint H;\nchar str[103][103];\nint BX;\nint BY; // 开始结点\nvoid bfs(){\n     queue<Node> Q;\n     Node p;\n     p.x=BX;\n     p.y=BY;\n     Q.push(p);\n     while(!Q.empty()){\n         p=Q.front();\n         Q.pop();\n         int lx=p.x;\n         int ly=p.y;\n         int step=p.step;\n         for(int e=0;e<4;++e){\n             int nx=lx+Move[e][0];\n             int ny=ly+Move[e][1];\n             // 沿着一条线一直走，直到撞墙\n             while(nx<W&&nx>=0&&ny<H&&ny>=0&&str[nx][ny]!='*'){\n                 if(str[nx][ny]=='C'){\n                     //cout<<e<<\" \"<<nx<<\" \"<<ny<<endl;\n                 }\n                 if(str[nx][ny]=='C'&&!(BX==nx&&BY==ny)){  // 找到了\n                     cout<<step<<endl;\n                     return ; \n                 }\n                 if(!visit[nx][ny]){  // 没遍历过的结点入队                  \n                   p.x=nx;\n                   p.y=ny;\n                   p.step=step+1;\n                   visit[nx][ny]=true;\n                   Q.push(p);\n                 }\n                 nx+=Move[e][0];\n                 ny+=Move[e][1];\n             }\n\n         }\n     }\n     \n\n    \n}\nint main(){\n    //freopen(\"test/D.txt\",\"r\",stdin);\n    cin>>H>>W;\n    for(int i = 0;i<W;++i){\n        cin>>str[i];\n    }\n    for(int i = 0;i<W;++i){\n        for(int j = 0;j<H;++j){\n            visit[i][j]=false;\n        }\n    }\n    // 选出开始结点\n    bool flag=true;\n    for(int i = 0;i<W;++i){\n        for(int j = 0;j<H;++j){\n            if(str[i][j]=='C'){\n                visit[i][j]=true;\n                BX=i;\n                BY=j;\n                flag=false;\n                break;\n            }\n        }\n        if(!flag){\n            break;\n        }\n    }\n    bfs();\n\n}\n```\n      \n\n\n\n","slug":"第一周周赛","published":1,"updated":"2021-07-21T08:25:39.327Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cks5hf3nh00019ctk28k43fl4","content":"<h1 id=\"第一周周赛报告\"><a href=\"#第一周周赛报告\" class=\"headerlink\" title=\"第一周周赛报告\"></a>第一周周赛报告</h1><h2 id=\"G2022年WUT集训计划\"><a href=\"#G2022年WUT集训计划\" class=\"headerlink\" title=\"G2022年WUT集训计划\"></a>G<a href=\"https://www.luogu.com.cn/contest/47145#problems\">2022年WUT集训计划</a></h2><h4 id=\"大意与分析\"><a href=\"#大意与分析\" class=\"headerlink\" title=\"大意与分析\"></a>大意与分析</h4><p>题目就是求所有acmer可以到达的房间有多少个。刚开始用floyd，然后成功套老鹅。<br>然后用搜索，搜索每个房间知否都对所有的成员可达。进行队员与房间的一对一搜索，造成了时间浪费。<br>实际上解法是每个队员把房间走一遍，然后记录每个房间被走的次数$sum[i]$，如果sum[i]为队员的总数，则这个房间可用。这样保证了每个房间只会被每个队员走一次。复杂度O(KN)。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> TLE ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> K,N,M;</span><br><span class=\"line\"><span class=\"keyword\">int</span> acm[<span class=\"number\">105</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> a[<span class=\"number\">1007</span>][<span class=\"number\">1007</span>]=&#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> visit[<span class=\"number\">1007</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> sum[<span class=\"number\">1007</span>]=&#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> ans=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"comment\">// r存放前一个</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;j&lt;=N;++j)&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span>(!visit[j]&amp;&amp;a[i][j]==<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">           visit[j]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">           sum[j]++;</span><br><span class=\"line\">           <span class=\"built_in\">dfs</span>(j);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123; </span><br><span class=\"line\">    TLE;</span><br><span class=\"line\">    <span class=\"comment\">//freopen(&quot;test/G.txt&quot;,&quot;r&quot;,stdin);</span></span><br><span class=\"line\">    cin&gt;&gt;K&gt;&gt;N&gt;&gt;M;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i =<span class=\"number\">1</span>;i&lt;=K;++i)&#123;</span><br><span class=\"line\">          cin&gt;&gt;acm[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=N;++i)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;j&lt;=N;++j)&#123;</span><br><span class=\"line\">           a[i][j]=<span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        a[i][i]=<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x,y;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=M;++i)&#123;</span><br><span class=\"line\">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\">        a[x][y]=<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=K;++i)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;j&lt;=N;++j)&#123;</span><br><span class=\"line\">            visit[j]=<span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sum[acm[i]]++;</span><br><span class=\"line\">        visit[acm[i]]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(acm[i]); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=N;++i)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(sum[i]==K)&#123;</span><br><span class=\"line\">            ans++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"B学园偶像祭\"><a href=\"#B学园偶像祭\" class=\"headerlink\" title=\"B学园偶像祭\"></a>B<a href=\"https://www.luogu.com.cn/problem/T186964?contestId=47145\">学园偶像祭</a></h2><h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p>题目好长，没想到用二分写，看到标签为二分的时候就跑去用2分补提。<br>刚开始WA是没考虑到如果l=r-1且答案偏小的话，就会死循环，因为l=ans=l。<br>考虑到这点之后还是WA WA WA，看了题解发现是要开unsign long long ,这也是做了那么久题第一次碰到这么大的数据，以后注意。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;math.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> n,S,L;</span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> A[<span class=\"number\">200005</span>];</span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ans=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> u[<span class=\"number\">200005</span>];</span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> l=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> r=<span class=\"number\">1e18</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//freopen(&quot;test/A.txt&quot;,&quot;r&quot;,stdin);</span></span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;S&gt;&gt;L;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">        cin&gt;&gt;A[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j&lt;n;++j)&#123;</span><br><span class=\"line\">        cin&gt;&gt;u[j];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(r!=l)&#123;</span><br><span class=\"line\">        ans=(r+l)/<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> sum=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i =<span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span>(A[i]+u[i]*ans&gt;=L)&#123;</span><br><span class=\"line\">               sum+=A[i]+u[i]*ans;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(sum&gt;S)&#123;</span><br><span class=\"line\">            r=ans;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(sum&lt;S)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(r-l==<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                ans=r;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            l=ans;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Biyua买装备\"><a href=\"#Biyua买装备\" class=\"headerlink\" title=\"Biyua买装备\"></a>B<a href=\"https://www.luogu.com.cn/problem/T186977\">iyua买装备</a></h2><h3 id=\"分析-1\"><a href=\"#分析-1\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p>题目要求在最小力量初值的前提下的最小精神初值，则可以先求最小力量初值。</p>\n<ul>\n<li>求最小能量初值：使用优先队列小顶堆Q1存储每个结点，结点的需求力量低的优先级高。每次将当前拥有能量值sum1和堆顶装备所需能量值a[i]比较，如果够，则穿上这个装备，如果不够，则初始能量要加上差值a[i]-sum1，一直到清空队列即可。</li>\n<li>求最小精神：建立另外一个小顶堆Q2，所需精神值小的优先级高。<ol>\n<li>设目前有的力量为beg，则我们可以从Q1中选出当前拥有能量值的情况下所能装上的所有装备，放到Q2中。</li>\n<li>如果当前精神值sum2比Q2中的堆顶所需要的精神值b[i]大，则穿上这个装备，更新当前力量值beg，回到1继续看看能不能有更多的装备可选择。</li>\n<li>如果当前精神值sum2比Q2中的堆顶所需要的精神值小，则必须让初始精神值加上b[i]-sum2。</li>\n<li>重复上述步骤直到清空两个队列</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span>  T;</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> n;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ELE</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> a;</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> b;</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> c;</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> d;</span><br><span class=\"line\">&#125;Ele;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 重写力量小根堆</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cmp1</span>&#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">operator</span> <span class=\"params\">()</span> <span class=\"params\">(Ele a,Ele b)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a.a==b.a)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> a.b&gt;b.b;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.a&gt;b.a;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;cmp1;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 重写智慧小根堆</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cmp2</span>&#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(Ele a,Ele b)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.b&gt;b.b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;cmp2;</span><br><span class=\"line\">Ele ele[<span class=\"number\">100004</span>];</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ans1=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> sum1=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ans2=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> sum2=<span class=\"number\">0</span>;   <span class=\"comment\">// 记录当前精神的和</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//freopen(&quot;test/A.txt&quot;,&quot;r&quot;,stdin);</span></span><br><span class=\"line\">    cin&gt;&gt;T;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    priority_queue&lt;Ele,vector&lt;Ele&gt;,cmp1&gt; Q1 ;  <span class=\"comment\">// 力量从小到大的小根堆</span></span><br><span class=\"line\">    priority_queue&lt;Ele,vector&lt;Ele&gt;,cmp2&gt; Q2;  <span class=\"comment\">// 精神从小到大的小根堆</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i =<span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">        cin&gt;&gt;ele[i].a&gt;&gt;ele[i].b&gt;&gt;ele[i].c&gt;&gt;ele[i].d;</span><br><span class=\"line\">        Q1.<span class=\"built_in\">push</span>(ele[i]); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// for(int i = 0;i&lt;n;++i)&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//     cout&lt;&lt;Q1.top().a&lt;&lt;&quot; &quot;&lt;&lt;Q1.top().b&lt;&lt;endl;</span></span><br><span class=\"line\">    <span class=\"comment\">//     Q1.pop();</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;endl;</span></span><br><span class=\"line\">    <span class=\"comment\">// for(int i = 0;i&lt;n;++i)&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//     cout&lt;&lt;Q2.top().a&lt;&lt;&quot; &quot;&lt;&lt;Q2.top().b&lt;&lt;endl;</span></span><br><span class=\"line\">    <span class=\"comment\">//     Q2.pop();</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;endl;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 求出最小的力量值</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!Q1.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">       Ele p=Q1.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">       Q1.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">       <span class=\"keyword\">if</span>(sum1&gt;=p.a)&#123;<span class=\"comment\">// 当前的力量够穿</span></span><br><span class=\"line\">          sum1+=p.c;</span><br><span class=\"line\">          <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">       &#125;<span class=\"keyword\">else</span>&#123;   <span class=\"comment\">// 不够穿的时候要更新初始值</span></span><br><span class=\"line\">          ans1+=p.a-sum1;</span><br><span class=\"line\">          sum1=p.a+p.c;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Q1还要用</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">        Q1.<span class=\"built_in\">push</span>(ele[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> beg=ans1;  <span class=\"comment\">// 记录最小初始力量</span></span><br><span class=\"line\">    <span class=\"comment\">// 在力量最小值开始满足的情况下，争取精神最小</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!Q1.<span class=\"built_in\">empty</span>()||!Q2.<span class=\"built_in\">empty</span>())&#123;   <span class=\"comment\">// 全部选完之后两个队列都为空</span></span><br><span class=\"line\">         Ele p;</span><br><span class=\"line\">        <span class=\"comment\">// 选出当前力量值下Q1中所有可取装备 </span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!Q1.<span class=\"built_in\">empty</span>())&#123; </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(beg&lt;Q1.<span class=\"built_in\">top</span>().a)&#123;  </span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 可以穿的放到Q2,但是这里害不能穿</span></span><br><span class=\"line\">            p=Q1.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">            Q2.<span class=\"built_in\">push</span>(p);</span><br><span class=\"line\">            Q1.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 尝试穿一件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!Q2.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">        p=Q2.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">        Q2.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(sum2&gt;=p.b)&#123; <span class=\"comment\">// 当前精神值够穿</span></span><br><span class=\"line\">            sum2+=p.d;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            ans2+=p.b-sum2;</span><br><span class=\"line\">            sum2+=p.b-sum2+p.d;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        beg+=p.c;  <span class=\"comment\">// 选了之后要加上力量</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans1&lt;&lt;<span class=\"string\">&quot; &quot;</span>&lt;&lt;ans2&lt;&lt;endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"D小L的测量学外业\"><a href=\"#D小L的测量学外业\" class=\"headerlink\" title=\"D小L的测量学外业\"></a>D<a href=\"https://www.luogu.com.cn/problem/T186968?contestId=47145\">小L的测量学外业</a></h2><p>补的时候看到最短路标签就直接广搜，但是这个题要的不是步数最短，而实拐角最短，所以是先使劲往一个方向搜到墙，再往其方向搜。已经入过队的点不用再入队，但是应该能被经过多次。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> x,y;     <span class=\"comment\">// 当前结点的位置</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> step=<span class=\"number\">0</span>;  <span class=\"comment\">// 当前的转角数</span></span><br><span class=\"line\">&#125;Node;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> visit[<span class=\"number\">103</span>][<span class=\"number\">103</span>];  <span class=\"comment\">// 某个点是否已经访问过，即已经入队</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> Move[<span class=\"number\">4</span>][<span class=\"number\">2</span>]=&#123;&#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>&#125;,&#123;<span class=\"number\">0</span>,<span class=\"number\">-1</span>&#125;,&#123;<span class=\"number\">-1</span>,<span class=\"number\">0</span>&#125;,&#123;<span class=\"number\">1</span>,<span class=\"number\">0</span>&#125;&#125;;   <span class=\"comment\">// 移动</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> W;</span><br><span class=\"line\"><span class=\"keyword\">int</span> H;</span><br><span class=\"line\"><span class=\"keyword\">char</span> str[<span class=\"number\">103</span>][<span class=\"number\">103</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> BX;</span><br><span class=\"line\"><span class=\"keyword\">int</span> BY; <span class=\"comment\">// 开始结点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bfs</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">     queue&lt;Node&gt; Q;</span><br><span class=\"line\">     Node p;</span><br><span class=\"line\">     p.x=BX;</span><br><span class=\"line\">     p.y=BY;</span><br><span class=\"line\">     Q.<span class=\"built_in\">push</span>(p);</span><br><span class=\"line\">     <span class=\"keyword\">while</span>(!Q.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">         p=Q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">         Q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">         <span class=\"keyword\">int</span> lx=p.x;</span><br><span class=\"line\">         <span class=\"keyword\">int</span> ly=p.y;</span><br><span class=\"line\">         <span class=\"keyword\">int</span> step=p.step;</span><br><span class=\"line\">         <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> e=<span class=\"number\">0</span>;e&lt;<span class=\"number\">4</span>;++e)&#123;</span><br><span class=\"line\">             <span class=\"keyword\">int</span> nx=lx+Move[e][<span class=\"number\">0</span>];</span><br><span class=\"line\">             <span class=\"keyword\">int</span> ny=ly+Move[e][<span class=\"number\">1</span>];</span><br><span class=\"line\">             <span class=\"comment\">// 沿着一条线一直走，直到撞墙</span></span><br><span class=\"line\">             <span class=\"keyword\">while</span>(nx&lt;W&amp;&amp;nx&gt;=<span class=\"number\">0</span>&amp;&amp;ny&lt;H&amp;&amp;ny&gt;=<span class=\"number\">0</span>&amp;&amp;str[nx][ny]!=<span class=\"string\">&#x27;*&#x27;</span>)&#123;</span><br><span class=\"line\">                 <span class=\"keyword\">if</span>(str[nx][ny]==<span class=\"string\">&#x27;C&#x27;</span>)&#123;</span><br><span class=\"line\">                     <span class=\"comment\">//cout&lt;&lt;e&lt;&lt;&quot; &quot;&lt;&lt;nx&lt;&lt;&quot; &quot;&lt;&lt;ny&lt;&lt;endl;</span></span><br><span class=\"line\">                 &#125;</span><br><span class=\"line\">                 <span class=\"keyword\">if</span>(str[nx][ny]==<span class=\"string\">&#x27;C&#x27;</span>&amp;&amp;!(BX==nx&amp;&amp;BY==ny))&#123;  <span class=\"comment\">// 找到了</span></span><br><span class=\"line\">                     cout&lt;&lt;step&lt;&lt;endl;</span><br><span class=\"line\">                     <span class=\"keyword\">return</span> ; </span><br><span class=\"line\">                 &#125;</span><br><span class=\"line\">                 <span class=\"keyword\">if</span>(!visit[nx][ny])&#123;  <span class=\"comment\">// 没遍历过的结点入队                  </span></span><br><span class=\"line\">                   p.x=nx;</span><br><span class=\"line\">                   p.y=ny;</span><br><span class=\"line\">                   p.step=step+<span class=\"number\">1</span>;</span><br><span class=\"line\">                   visit[nx][ny]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">                   Q.<span class=\"built_in\">push</span>(p);</span><br><span class=\"line\">                 &#125;</span><br><span class=\"line\">                 nx+=Move[e][<span class=\"number\">0</span>];</span><br><span class=\"line\">                 ny+=Move[e][<span class=\"number\">1</span>];</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     </span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//freopen(&quot;test/D.txt&quot;,&quot;r&quot;,stdin);</span></span><br><span class=\"line\">    cin&gt;&gt;H&gt;&gt;W;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;W;++i)&#123;</span><br><span class=\"line\">        cin&gt;&gt;str[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;W;++i)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j&lt;H;++j)&#123;</span><br><span class=\"line\">            visit[i][j]=<span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 选出开始结点</span></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> flag=<span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;W;++i)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j&lt;H;++j)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(str[i][j]==<span class=\"string\">&#x27;C&#x27;</span>)&#123;</span><br><span class=\"line\">                visit[i][j]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">                BX=i;</span><br><span class=\"line\">                BY=j;</span><br><span class=\"line\">                flag=<span class=\"literal\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!flag)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">bfs</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"第一周周赛报告\"><a href=\"#第一周周赛报告\" class=\"headerlink\" title=\"第一周周赛报告\"></a>第一周周赛报告</h1><h2 id=\"G2022年WUT集训计划\"><a href=\"#G2022年WUT集训计划\" class=\"headerlink\" title=\"G2022年WUT集训计划\"></a>G<a href=\"https://www.luogu.com.cn/contest/47145#problems\">2022年WUT集训计划</a></h2><h4 id=\"大意与分析\"><a href=\"#大意与分析\" class=\"headerlink\" title=\"大意与分析\"></a>大意与分析</h4><p>题目就是求所有acmer可以到达的房间有多少个。刚开始用floyd，然后成功套老鹅。<br>然后用搜索，搜索每个房间知否都对所有的成员可达。进行队员与房间的一对一搜索，造成了时间浪费。<br>实际上解法是每个队员把房间走一遍，然后记录每个房间被走的次数$sum[i]$，如果sum[i]为队员的总数，则这个房间可用。这样保证了每个房间只会被每个队员走一次。复杂度O(KN)。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> TLE ios::sync_with_stdio(0),cin.tie(0)</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> K,N,M;</span><br><span class=\"line\"><span class=\"keyword\">int</span> acm[<span class=\"number\">105</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> a[<span class=\"number\">1007</span>][<span class=\"number\">1007</span>]=&#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> visit[<span class=\"number\">1007</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> sum[<span class=\"number\">1007</span>]=&#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> ans=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"comment\">// r存放前一个</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;j&lt;=N;++j)&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span>(!visit[j]&amp;&amp;a[i][j]==<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">           visit[j]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">           sum[j]++;</span><br><span class=\"line\">           <span class=\"built_in\">dfs</span>(j);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123; </span><br><span class=\"line\">    TLE;</span><br><span class=\"line\">    <span class=\"comment\">//freopen(&quot;test/G.txt&quot;,&quot;r&quot;,stdin);</span></span><br><span class=\"line\">    cin&gt;&gt;K&gt;&gt;N&gt;&gt;M;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i =<span class=\"number\">1</span>;i&lt;=K;++i)&#123;</span><br><span class=\"line\">          cin&gt;&gt;acm[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=N;++i)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;j&lt;=N;++j)&#123;</span><br><span class=\"line\">           a[i][j]=<span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        a[i][i]=<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x,y;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=M;++i)&#123;</span><br><span class=\"line\">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class=\"line\">        a[x][y]=<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=K;++i)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;j&lt;=N;++j)&#123;</span><br><span class=\"line\">            visit[j]=<span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        sum[acm[i]]++;</span><br><span class=\"line\">        visit[acm[i]]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"built_in\">dfs</span>(acm[i]); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i&lt;=N;++i)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(sum[i]==K)&#123;</span><br><span class=\"line\">            ans++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"B学园偶像祭\"><a href=\"#B学园偶像祭\" class=\"headerlink\" title=\"B学园偶像祭\"></a>B<a href=\"https://www.luogu.com.cn/problem/T186964?contestId=47145\">学园偶像祭</a></h2><h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p>题目好长，没想到用二分写，看到标签为二分的时候就跑去用2分补提。<br>刚开始WA是没考虑到如果l=r-1且答案偏小的话，就会死循环，因为l=ans=l。<br>考虑到这点之后还是WA WA WA，看了题解发现是要开unsign long long ,这也是做了那么久题第一次碰到这么大的数据，以后注意。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;math.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> n,S,L;</span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> A[<span class=\"number\">200005</span>];</span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ans=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> u[<span class=\"number\">200005</span>];</span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> l=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> r=<span class=\"number\">1e18</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//freopen(&quot;test/A.txt&quot;,&quot;r&quot;,stdin);</span></span><br><span class=\"line\">    cin&gt;&gt;n&gt;&gt;S&gt;&gt;L;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">        cin&gt;&gt;A[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j&lt;n;++j)&#123;</span><br><span class=\"line\">        cin&gt;&gt;u[j];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(r!=l)&#123;</span><br><span class=\"line\">        ans=(r+l)/<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> sum=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i =<span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span>(A[i]+u[i]*ans&gt;=L)&#123;</span><br><span class=\"line\">               sum+=A[i]+u[i]*ans;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(sum&gt;S)&#123;</span><br><span class=\"line\">            r=ans;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(sum&lt;S)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(r-l==<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                ans=r;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            l=ans;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Biyua买装备\"><a href=\"#Biyua买装备\" class=\"headerlink\" title=\"Biyua买装备\"></a>B<a href=\"https://www.luogu.com.cn/problem/T186977\">iyua买装备</a></h2><h3 id=\"分析-1\"><a href=\"#分析-1\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p>题目要求在最小力量初值的前提下的最小精神初值，则可以先求最小力量初值。</p>\n<ul>\n<li>求最小能量初值：使用优先队列小顶堆Q1存储每个结点，结点的需求力量低的优先级高。每次将当前拥有能量值sum1和堆顶装备所需能量值a[i]比较，如果够，则穿上这个装备，如果不够，则初始能量要加上差值a[i]-sum1，一直到清空队列即可。</li>\n<li>求最小精神：建立另外一个小顶堆Q2，所需精神值小的优先级高。<ol>\n<li>设目前有的力量为beg，则我们可以从Q1中选出当前拥有能量值的情况下所能装上的所有装备，放到Q2中。</li>\n<li>如果当前精神值sum2比Q2中的堆顶所需要的精神值b[i]大，则穿上这个装备，更新当前力量值beg，回到1继续看看能不能有更多的装备可选择。</li>\n<li>如果当前精神值sum2比Q2中的堆顶所需要的精神值小，则必须让初始精神值加上b[i]-sum2。</li>\n<li>重复上述步骤直到清空两个队列</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span>  T;</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> n;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ELE</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> a;</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> b;</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> c;</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> d;</span><br><span class=\"line\">&#125;Ele;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 重写力量小根堆</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cmp1</span>&#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">operator</span> <span class=\"params\">()</span> <span class=\"params\">(Ele a,Ele b)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(a.a==b.a)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> a.b&gt;b.b;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.a&gt;b.a;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;cmp1;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 重写智慧小根堆</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cmp2</span>&#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(Ele a,Ele b)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.b&gt;b.b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;cmp2;</span><br><span class=\"line\">Ele ele[<span class=\"number\">100004</span>];</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ans1=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> sum1=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ans2=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> sum2=<span class=\"number\">0</span>;   <span class=\"comment\">// 记录当前精神的和</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//freopen(&quot;test/A.txt&quot;,&quot;r&quot;,stdin);</span></span><br><span class=\"line\">    cin&gt;&gt;T;</span><br><span class=\"line\">    cin&gt;&gt;n;</span><br><span class=\"line\">    priority_queue&lt;Ele,vector&lt;Ele&gt;,cmp1&gt; Q1 ;  <span class=\"comment\">// 力量从小到大的小根堆</span></span><br><span class=\"line\">    priority_queue&lt;Ele,vector&lt;Ele&gt;,cmp2&gt; Q2;  <span class=\"comment\">// 精神从小到大的小根堆</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i =<span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">        cin&gt;&gt;ele[i].a&gt;&gt;ele[i].b&gt;&gt;ele[i].c&gt;&gt;ele[i].d;</span><br><span class=\"line\">        Q1.<span class=\"built_in\">push</span>(ele[i]); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// for(int i = 0;i&lt;n;++i)&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//     cout&lt;&lt;Q1.top().a&lt;&lt;&quot; &quot;&lt;&lt;Q1.top().b&lt;&lt;endl;</span></span><br><span class=\"line\">    <span class=\"comment\">//     Q1.pop();</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;endl;</span></span><br><span class=\"line\">    <span class=\"comment\">// for(int i = 0;i&lt;n;++i)&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//     cout&lt;&lt;Q2.top().a&lt;&lt;&quot; &quot;&lt;&lt;Q2.top().b&lt;&lt;endl;</span></span><br><span class=\"line\">    <span class=\"comment\">//     Q2.pop();</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">// cout&lt;&lt;endl;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 求出最小的力量值</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!Q1.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">       Ele p=Q1.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">       Q1.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">       <span class=\"keyword\">if</span>(sum1&gt;=p.a)&#123;<span class=\"comment\">// 当前的力量够穿</span></span><br><span class=\"line\">          sum1+=p.c;</span><br><span class=\"line\">          <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">       &#125;<span class=\"keyword\">else</span>&#123;   <span class=\"comment\">// 不够穿的时候要更新初始值</span></span><br><span class=\"line\">          ans1+=p.a-sum1;</span><br><span class=\"line\">          sum1=p.a+p.c;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Q1还要用</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">        Q1.<span class=\"built_in\">push</span>(ele[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> beg=ans1;  <span class=\"comment\">// 记录最小初始力量</span></span><br><span class=\"line\">    <span class=\"comment\">// 在力量最小值开始满足的情况下，争取精神最小</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!Q1.<span class=\"built_in\">empty</span>()||!Q2.<span class=\"built_in\">empty</span>())&#123;   <span class=\"comment\">// 全部选完之后两个队列都为空</span></span><br><span class=\"line\">         Ele p;</span><br><span class=\"line\">        <span class=\"comment\">// 选出当前力量值下Q1中所有可取装备 </span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!Q1.<span class=\"built_in\">empty</span>())&#123; </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(beg&lt;Q1.<span class=\"built_in\">top</span>().a)&#123;  </span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 可以穿的放到Q2,但是这里害不能穿</span></span><br><span class=\"line\">            p=Q1.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">            Q2.<span class=\"built_in\">push</span>(p);</span><br><span class=\"line\">            Q1.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 尝试穿一件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!Q2.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">        p=Q2.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">        Q2.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(sum2&gt;=p.b)&#123; <span class=\"comment\">// 当前精神值够穿</span></span><br><span class=\"line\">            sum2+=p.d;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            ans2+=p.b-sum2;</span><br><span class=\"line\">            sum2+=p.b-sum2+p.d;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        beg+=p.c;  <span class=\"comment\">// 选了之后要加上力量</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout&lt;&lt;ans1&lt;&lt;<span class=\"string\">&quot; &quot;</span>&lt;&lt;ans2&lt;&lt;endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"D小L的测量学外业\"><a href=\"#D小L的测量学外业\" class=\"headerlink\" title=\"D小L的测量学外业\"></a>D<a href=\"https://www.luogu.com.cn/problem/T186968?contestId=47145\">小L的测量学外业</a></h2><p>补的时候看到最短路标签就直接广搜，但是这个题要的不是步数最短，而实拐角最短，所以是先使劲往一个方向搜到墙，再往其方向搜。已经入过队的点不用再入队，但是应该能被经过多次。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;queue&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Node</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> x,y;     <span class=\"comment\">// 当前结点的位置</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> step=<span class=\"number\">0</span>;  <span class=\"comment\">// 当前的转角数</span></span><br><span class=\"line\">&#125;Node;</span><br><span class=\"line\"><span class=\"keyword\">bool</span> visit[<span class=\"number\">103</span>][<span class=\"number\">103</span>];  <span class=\"comment\">// 某个点是否已经访问过，即已经入队</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> Move[<span class=\"number\">4</span>][<span class=\"number\">2</span>]=&#123;&#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>&#125;,&#123;<span class=\"number\">0</span>,<span class=\"number\">-1</span>&#125;,&#123;<span class=\"number\">-1</span>,<span class=\"number\">0</span>&#125;,&#123;<span class=\"number\">1</span>,<span class=\"number\">0</span>&#125;&#125;;   <span class=\"comment\">// 移动</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> W;</span><br><span class=\"line\"><span class=\"keyword\">int</span> H;</span><br><span class=\"line\"><span class=\"keyword\">char</span> str[<span class=\"number\">103</span>][<span class=\"number\">103</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> BX;</span><br><span class=\"line\"><span class=\"keyword\">int</span> BY; <span class=\"comment\">// 开始结点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">bfs</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">     queue&lt;Node&gt; Q;</span><br><span class=\"line\">     Node p;</span><br><span class=\"line\">     p.x=BX;</span><br><span class=\"line\">     p.y=BY;</span><br><span class=\"line\">     Q.<span class=\"built_in\">push</span>(p);</span><br><span class=\"line\">     <span class=\"keyword\">while</span>(!Q.<span class=\"built_in\">empty</span>())&#123;</span><br><span class=\"line\">         p=Q.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">         Q.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">         <span class=\"keyword\">int</span> lx=p.x;</span><br><span class=\"line\">         <span class=\"keyword\">int</span> ly=p.y;</span><br><span class=\"line\">         <span class=\"keyword\">int</span> step=p.step;</span><br><span class=\"line\">         <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> e=<span class=\"number\">0</span>;e&lt;<span class=\"number\">4</span>;++e)&#123;</span><br><span class=\"line\">             <span class=\"keyword\">int</span> nx=lx+Move[e][<span class=\"number\">0</span>];</span><br><span class=\"line\">             <span class=\"keyword\">int</span> ny=ly+Move[e][<span class=\"number\">1</span>];</span><br><span class=\"line\">             <span class=\"comment\">// 沿着一条线一直走，直到撞墙</span></span><br><span class=\"line\">             <span class=\"keyword\">while</span>(nx&lt;W&amp;&amp;nx&gt;=<span class=\"number\">0</span>&amp;&amp;ny&lt;H&amp;&amp;ny&gt;=<span class=\"number\">0</span>&amp;&amp;str[nx][ny]!=<span class=\"string\">&#x27;*&#x27;</span>)&#123;</span><br><span class=\"line\">                 <span class=\"keyword\">if</span>(str[nx][ny]==<span class=\"string\">&#x27;C&#x27;</span>)&#123;</span><br><span class=\"line\">                     <span class=\"comment\">//cout&lt;&lt;e&lt;&lt;&quot; &quot;&lt;&lt;nx&lt;&lt;&quot; &quot;&lt;&lt;ny&lt;&lt;endl;</span></span><br><span class=\"line\">                 &#125;</span><br><span class=\"line\">                 <span class=\"keyword\">if</span>(str[nx][ny]==<span class=\"string\">&#x27;C&#x27;</span>&amp;&amp;!(BX==nx&amp;&amp;BY==ny))&#123;  <span class=\"comment\">// 找到了</span></span><br><span class=\"line\">                     cout&lt;&lt;step&lt;&lt;endl;</span><br><span class=\"line\">                     <span class=\"keyword\">return</span> ; </span><br><span class=\"line\">                 &#125;</span><br><span class=\"line\">                 <span class=\"keyword\">if</span>(!visit[nx][ny])&#123;  <span class=\"comment\">// 没遍历过的结点入队                  </span></span><br><span class=\"line\">                   p.x=nx;</span><br><span class=\"line\">                   p.y=ny;</span><br><span class=\"line\">                   p.step=step+<span class=\"number\">1</span>;</span><br><span class=\"line\">                   visit[nx][ny]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">                   Q.<span class=\"built_in\">push</span>(p);</span><br><span class=\"line\">                 &#125;</span><br><span class=\"line\">                 nx+=Move[e][<span class=\"number\">0</span>];</span><br><span class=\"line\">                 ny+=Move[e][<span class=\"number\">1</span>];</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     </span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//freopen(&quot;test/D.txt&quot;,&quot;r&quot;,stdin);</span></span><br><span class=\"line\">    cin&gt;&gt;H&gt;&gt;W;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;W;++i)&#123;</span><br><span class=\"line\">        cin&gt;&gt;str[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;W;++i)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j&lt;H;++j)&#123;</span><br><span class=\"line\">            visit[i][j]=<span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 选出开始结点</span></span><br><span class=\"line\">    <span class=\"keyword\">bool</span> flag=<span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;W;++i)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j&lt;H;++j)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(str[i][j]==<span class=\"string\">&#x27;C&#x27;</span>)&#123;</span><br><span class=\"line\">                visit[i][j]=<span class=\"literal\">true</span>;</span><br><span class=\"line\">                BX=i;</span><br><span class=\"line\">                BY=j;</span><br><span class=\"line\">                flag=<span class=\"literal\">false</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!flag)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">bfs</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"}],"PostAsset":[{"_id":"source/_posts/EducationalCodeforcesRound111/CF111_0.png","slug":"CF111_0.png","post":"ckr74cdsi000140tkchu7edu5","modified":0,"renderable":0},{"_id":"source/_posts/EducationalCodeforcesRound111/CF111_1.png","slug":"CF111_1.png","post":"ckr74cdsi000140tkchu7edu5","modified":0,"renderable":0},{"_id":"source/_posts/EducationalCodeforcesRound111/CF111_2.png","slug":"CF111_2.png","post":"ckr74cdsi000140tkchu7edu5","modified":0,"renderable":0},{"_id":"source/_posts/EducationalCodeforcesRound111/CF111_3.png","slug":"CF111_3.png","post":"ckr74cdsi000140tkchu7edu5","modified":0,"renderable":0},{"_id":"source/_posts/BestCowFences/BestCowFence.png","slug":"BestCowFence.png","post":"ckr74cdso000340tk48701fcu","modified":0,"renderable":0},{"_id":"source/_posts/MaxMedian/MaxMedian.png","slug":"MaxMedian.png","post":"ckr74cdst000840tk19k81729","modified":0,"renderable":0},{"_id":"source/_posts/Postons/Potions(Hard_version).png","slug":"Potions(Hard_version).png","post":"ckr74cdst000940tk70b1hjvy","modified":0,"renderable":0},{"_id":"source/_posts/数据备份/backUp.png","slug":"backUp.png","post":"ckr74cdt5001g40tkak32aj8x","modified":0,"renderable":0},{"_id":"source/_posts/牛客欢乐赛8E/1.png","slug":"1.png","post":"ckr74cdtb001m40tk05osfiv3","modified":0,"renderable":0},{"_id":"source/_posts/牛客欢乐赛8E/2.png","slug":"2.png","post":"ckr74cdtb001m40tk05osfiv3","modified":0,"renderable":0}],"PostCategory":[{"post_id":"ckr74cdst000940tk70b1hjvy","category_id":"ckr74cdss000740tk6a2tgh0r","_id":"ckr74cdsx000g40tk3fvm5cq3"},{"post_id":"ckr74cdso000340tk48701fcu","category_id":"ckr74cdss000740tk6a2tgh0r","_id":"ckr74cdsy000j40tkhvqe2mcy"},{"post_id":"ckr74cdsr000640tk3onpbnj5","category_id":"ckr74cdsv000c40tk6skq12cg","_id":"ckr74cdsz000n40tk7tg2dlrv"},{"post_id":"ckr74cdst000840tk19k81729","category_id":"ckr74cdss000740tk6a2tgh0r","_id":"ckr74cdsz000p40tk6lyn22as"},{"post_id":"ckr74cdsw000f40tk8zsj4wrn","category_id":"ckr74cdsz000m40tkcvpxh87g","_id":"ckr74cdt0000r40tkhxwa7ur4"},{"post_id":"ckr74cdt5001g40tkak32aj8x","category_id":"ckr74cdt9001h40tkb3bphp6y","_id":"ckr74cdt9001k40tkhtes1ke1"},{"post_id":"ckr74cdtb001m40tk05osfiv3","category_id":"ckr74cdtc001o40tk9farfti9","_id":"ckr74cdtd001u40tk45fbej20"},{"post_id":"ckr74cdtb001m40tk05osfiv3","category_id":"ckr74cdtd001r40tk94jwfkh8","_id":"ckr74cdte001w40tkh23b9zv0"}],"PostTag":[{"post_id":"ckr74cdsi000140tkchu7edu5","tag_id":"ckr74cdsp000440tkhf8x70y3","_id":"ckr74cdsx000h40tkano3hbou"},{"post_id":"ckr74cdsi000140tkchu7edu5","tag_id":"ckr74cdsu000a40tka01s4r74","_id":"ckr74cdsy000k40tk75ir960c"},{"post_id":"ckr74cdso000340tk48701fcu","tag_id":"ckr74cdsw000e40tkbb8a5vjw","_id":"ckr74cdt0000s40tk4gmt4vv0"},{"post_id":"ckr74cdso000340tk48701fcu","tag_id":"ckr74cdsz000l40tk4tmo73u1","_id":"ckr74cdt0000t40tk6jk1cooc"},{"post_id":"ckr74cdso000340tk48701fcu","tag_id":"ckr74cdsz000o40tkafp02lqb","_id":"ckr74cdt0000v40tk94kr9zpp"},{"post_id":"ckr74cdsr000640tk3onpbnj5","tag_id":"ckr74cdt0000q40tkbdmv5vdv","_id":"ckr74cdt0000w40tkh5jj9bhq"},{"post_id":"ckr74cdst000840tk19k81729","tag_id":"ckr74cdsw000e40tkbb8a5vjw","_id":"ckr74cdt1001040tk7q7hc9hb"},{"post_id":"ckr74cdst000840tk19k81729","tag_id":"ckr74cdsz000l40tk4tmo73u1","_id":"ckr74cdt2001140tk1t7kh3x3"},{"post_id":"ckr74cdst000840tk19k81729","tag_id":"ckr74cdsz000o40tkafp02lqb","_id":"ckr74cdt2001340tkea3u4t4t"},{"post_id":"ckr74cdst000940tk70b1hjvy","tag_id":"ckr74cdt1000z40tk0mtrh7m6","_id":"ckr74cdt3001640tkan71gc94"},{"post_id":"ckr74cdst000940tk70b1hjvy","tag_id":"ckr74cdt2001240tkgpu0ck72","_id":"ckr74cdt3001740tk28rt3ql0"},{"post_id":"ckr74cdst000940tk70b1hjvy","tag_id":"ckr74cdt2001440tkhj1b6nq7","_id":"ckr74cdt3001940tkdju3bgjn"},{"post_id":"ckr74cdsv000d40tkae3n4n9m","tag_id":"ckr74cdt0000q40tkbdmv5vdv","_id":"ckr74cdt4001c40tkbutkc2cm"},{"post_id":"ckr74cdsv000d40tkae3n4n9m","tag_id":"ckr74cdt3001840tk85s349a0","_id":"ckr74cdt4001d40tkgsuh87wn"},{"post_id":"ckr74cdsv000d40tkae3n4n9m","tag_id":"ckr74cdt3001a40tk7fglcnyn","_id":"ckr74cdt4001e40tk63so139r"},{"post_id":"ckr74cdsw000f40tk8zsj4wrn","tag_id":"ckr74cdt3001b40tk9nvm4sc3","_id":"ckr74cdt4001f40tk4h3tb318"},{"post_id":"ckr74cdt5001g40tkak32aj8x","tag_id":"ckr74cdt9001i40tka4xg6jeq","_id":"ckr74cdt9001j40tk5yvb3wdt"},{"post_id":"ckr74cdta001l40tkh68i216j","tag_id":"ckr74cdtc001n40tk51cvgqw2","_id":"ckr74cdtc001q40tkdpxm9qz2"},{"post_id":"ckr74cdtb001m40tk05osfiv3","tag_id":"ckr74cdtc001p40tkd8ns9kjy","_id":"ckr74cdte001x40tk4slghs56"},{"post_id":"ckr74cdtb001m40tk05osfiv3","tag_id":"ckr74cdtd001s40tkdt9ief3i","_id":"ckr74cdte001y40tker3v6hi6"},{"post_id":"ckr74cdtb001m40tk05osfiv3","tag_id":"ckr74cdtd001t40tk4ozb614l","_id":"ckr74cdte001z40tkhjbs7w58"},{"post_id":"ckr74cdtb001m40tk05osfiv3","tag_id":"ckr74cdtd001v40tk0c0ma1e3","_id":"ckr74cdte002040tkclor8joh"},{"post_id":"cks5hf3nc00009ctk7ewvhj2f","tag_id":"cks5hf3no00029ctkdslwb4rv","_id":"cks5hf3nv00039ctkenscgnrb"}],"Tag":[{"name":"暴力","_id":"ckr74cdsp000440tkhf8x70y3"},{"name":"几何","_id":"ckr74cdsu000a40tka01s4r74"},{"name":"限定长度最大子段和","_id":"ckr74cdsw000e40tkbb8a5vjw"},{"name":"思维","_id":"ckr74cdsz000l40tk4tmo73u1"},{"name":"二分答案","_id":"ckr74cdsz000o40tkafp02lqb"},{"name":"JAVA","_id":"ckr74cdt0000q40tkbdmv5vdv"},{"name":"反悔","_id":"ckr74cdt1000z40tk0mtrh7m6"},{"name":"贪心","_id":"ckr74cdt2001240tkgpu0ck72"},{"name":"优先队列","_id":"ckr74cdt2001440tkhj1b6nq7"},{"name":"SptingBoot","_id":"ckr74cdt3001840tk85s349a0"},{"name":"数据库","_id":"ckr74cdt3001a40tk7fglcnyn"},{"name":"-分治法","_id":"ckr74cdt3001b40tk9nvm4sc3"},{"name":"-贪心 -反悔 -优先队列","_id":"ckr74cdt9001i40tka4xg6jeq"},{"name":"动态规划","_id":"ckr74cdtc001n40tk51cvgqw2"},{"name":"数论","_id":"ckr74cdtc001p40tkd8ns9kjy"},{"name":"组合数","_id":"ckr74cdtd001s40tkdt9ief3i"},{"name":"逆元","_id":"ckr74cdtd001t40tk4ozb614l"},{"name":"费马里小定理","_id":"ckr74cdtd001v40tk0c0ma1e3"},{"name":"离散化","_id":"cks5hf3no00029ctkdslwb4rv"}]}}
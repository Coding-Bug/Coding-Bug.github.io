---
title: 数据备份
date: 2021-06-11 15:52:27
categories:
    -div1
tags:
    -贪心
    -反悔
    -优先队列
---
# 题目
{% asset_img backUp.png %}
### 题目简述
大概就是有n个办公楼，要找出k对，每对之间拉一个电缆，并且每个楼只能用一次，求出最小的距离之和

### 分析
- 首先要明确，找出的n对楼里面，每对肯定是相邻的，若不相邻，则令其中间的任一一对代替，能得到更优结果
- 如果每次只选择最小那对，也是不行的，如：
    - 现在有一个原始的对序列 2 1 2 5 6，要找两队。则放到优先队列中有 1 2 2 5 6，如果先选最小的，则现在选的是1，由于1中两个城市在2 2 这两队中，所以2 2 要丢掉。则优先队列中能用的只剩下 5 6，则下次应该选择5。不难发现，如果不选1的话，选2 2明显会比选1 5好。到这里不难发现，我们要后悔。、
- 那么怎么进行后悔呢？
    - 我们在选择最小的1之后，2 2 本来是要废掉的，但是我们不直接丢掉他们，而是创建一个新的数为 2+2-1=3 放入优先队列中。则优先队列中剩下的为 3 5 6，这样我们下次选3就相当于选了 2+2-1+1，即 2 2，后悔成功。

### 算法
每次取最小的一个区间，然后将这个数两边得区间合并，并减去这个数，构成后悔结点（则原区间最左边和最右边还应该加一段无穷大）。一直做下去，最终即可得到结果。
区间段用链表维护。需要注意的是链表的更新。

### 代码
```c++
#include<iostream>
#include<cstring>
#include<queue>
using namespace std;
long long s[100002];     // 每个公司到起点的距离

// 每个相邻区间作为一个结点
typedef struct Node{
      long long  Len;            // 区间的长度
      int pos;                   // 当前结点的位置c
}NODE;

// 仿函数
struct tmp{
    bool operator() (Node a,Node b){
        return a.Len>b.Len;
    }
};

bool isUsed[100002];// 判断某个结点是否已经使用过
int Next[100002];   // 存放某个结点的下一个结点
int Prio[100002];   // 存放某个节点的一个结点 
long long val[100002]; // 要得到某个位置的值信息，不能从队列里获得，要另存  

NODE sNode;
int main(){
    //freopen("test/div1C.txt","r",stdin);
    // 初始化标记数组
    memset(isUsed,false,sizeof(isUsed));
    int n,k;    // 办公楼数和可以铺设的电网数
    long long ans=0;
    cin>>n>>k;
    for(int i =0;i<n;++i){
        cin>>s[i];
    }
    priority_queue<NODE,vector<NODE>,tmp> Q;    // 设置一个小根堆存放现有结点
    
    

    // 初始化第一个结点
    sNode.Len=s[1]-s[0];
    sNode.pos=1;    // 从1开始
    Prio[1]=0;     // 第一个结点前驱为空
    Next[1]=2;       // 后继为1
    val[1]=sNode.Len;
    Q.push(sNode);  // 第一个结点入队

    // 初始化其他结点,最后一个结点的下标是n-1，因为一共有n-1个结点
    for(int i =1; i<n-1;++i){
        sNode.Len=s[i+1]-s[i];
        sNode.pos=i+1;    
        Prio[i+1]=i;     
        Next[i+1]=i+2;       
        val[i+1]=sNode.Len;
        Q.push(sNode);     
    }

    // 两端设极大
    val[0]=2e9;
    val[n]=2e9;


    // 进行贪心选择
    while(k!=0){
        // 跳过无效结点
        while(isUsed[Q.top().pos]){
            Q.pop();
        }
        sNode=Q.top();  // 取出长度最小的那个有效结点
        Q.pop();
        ans+=sNode.Len;  // 取了这个点，答案要加上
        
        // 求新的结点的长度，实现隐式反悔
        sNode.Len=val[Prio[sNode.pos]]+val[Next[sNode.pos]]-val[sNode.pos];
        val[sNode.pos]=sNode.Len;
        
      
        // 两端设置为已使用
        isUsed[Prio[sNode.pos]]=true;
        isUsed[Next[sNode.pos]]=true;
        //更新新结点的前驱后继
        Prio[sNode.pos]=Prio[Prio[sNode.pos]];
        Next[sNode.pos]=Next[Next[sNode.pos]];

        // 更新前面的前面的后继和后面的后面的前驱
        // 注意Prio[sNode.pos]和Next[sNode.pos]已经变了
        Next[Prio[sNode.pos]]=sNode.pos;
        Prio[Next[sNode.pos]]=sNode.pos;

        // 新结点入队
        Q.push(sNode);
        --k;
    }
    cout<<ans<<endl;
}
```
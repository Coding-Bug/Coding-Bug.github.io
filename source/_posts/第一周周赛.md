---
title: 第一周周赛
date: 2021-07-19 16:40:02
catagories:
 - 周赛
---
# 第一周周赛报告
## G[2022年WUT集训计划](https://www.luogu.com.cn/contest/47145#problems)

#### 大意与分析
题目就是求所有acmer可以到达的房间有多少个。刚开始用floyd，然后成功套老鹅。
然后用搜索，搜索每个房间知否都对所有的成员可达。进行队员与房间的一对一搜索，造成了时间浪费。
实际上解法是每个队员把房间走一遍，然后记录每个房间被走的次数$sum[i]$，如果sum[i]为队员的总数，则这个房间可用。这样保证了每个房间只会被每个队员走一次。复杂度O(KN)。
```c++
#include <bits/stdc++.h>
using namespace std;
#define TLE ios::sync_with_stdio(0),cin.tie(0)
int K,N,M;
int acm[105];
int a[1007][1007]={0};
bool visit[1007];
int sum[1007]={0};
int ans=0;
// r存放前一个
void dfs(int i){
    for(int j = 1;j<=N;++j){
       if(!visit[j]&&a[i][j]==1){
           visit[j]=true;
           sum[j]++;
           dfs(j);
       }
    }
}
int main(){ 
    TLE;
    //freopen("test/G.txt","r",stdin);
    cin>>K>>N>>M;
    for(int i =1;i<=K;++i){
          cin>>acm[i];
    }
    for(int i = 1;i<=N;++i){
        for(int j = 1;j<=N;++j){
           a[i][j]=0;
        }
        a[i][i]=1;
    }
    int x,y;
    for(int i = 1;i<=M;++i){
        cin>>x>>y;
        a[x][y]=1;
    }
    for(int i = 1;i<=K;++i){
        for(int j = 1;j<=N;++j){
            visit[j]=false;
        }
        sum[acm[i]]++;
        visit[acm[i]]=true;
        dfs(acm[i]); 
    }
    for(int i = 1;i<=N;++i){
        if(sum[i]==K){
            ans++;
        }
    }
    cout<<ans<<endl;
}
```

## B[学园偶像祭](https://www.luogu.com.cn/problem/T186964?contestId=47145)

### 分析
题目好长，没想到用二分写，看到标签为二分的时候就跑去用2分补提。
刚开始WA是没考虑到如果l=r-1且答案偏小的话，就会死循环，因为l=ans=l。
考虑到这点之后还是WA WA WA，看了题解发现是要开unsign long long ,这也是做了那么久题第一次碰到这么大的数据，以后注意。
```c++
#include<iostream>
#include<math.h>
using namespace std;
unsigned long long n,S,L;
unsigned long long A[200005];
unsigned long long ans=0;
unsigned long long u[200005];
unsigned long long l=0;
unsigned long long r=1e18;

int main(){
    
    //freopen("test/A.txt","r",stdin);
    cin>>n>>S>>L;
    for(int i=0;i<n;++i){
        cin>>A[i];
    }
    for(int j = 0;j<n;++j){
        cin>>u[j];
    }
    while(r!=l){
        ans=(r+l)/2;
        unsigned long long sum=0;
        for(int i =0;i<n;++i){
           if(A[i]+u[i]*ans>=L){
               sum+=A[i]+u[i]*ans;
           }
        }
        if(sum>S){
            r=ans;
        }else if(sum<S){
            if(r-l==1){
                ans=r;
                break;
            }
            l=ans;
        }else{
            break;
        }
    }

    cout<<ans<<endl;
}
```

## B[iyua买装备](https://www.luogu.com.cn/problem/T186977)

### 分析
题目要求在最小力量初值的前提下的最小精神初值，则可以先求最小力量初值。
* 求最小能量初值：使用优先队列小顶堆Q1存储每个结点，结点的需求力量低的优先级高。每次将当前拥有能量值sum1和堆顶装备所需能量值a[i]比较，如果够，则穿上这个装备，如果不够，则初始能量要加上差值a[i]-sum1，一直到清空队列即可。
* 求最小精神：建立另外一个小顶堆Q2，所需精神值小的优先级高。
   1. 设目前有的力量为beg，则我们可以从Q1中选出当前拥有能量值的情况下所能装上的所有装备，放到Q2中。
   2. 如果当前精神值sum2比Q2中的堆顶所需要的精神值b[i]大，则穿上这个装备，更新当前力量值beg，回到1继续看看能不能有更多的装备可选择。
   3. 如果当前精神值sum2比Q2中的堆顶所需要的精神值小，则必须让初始精神值加上b[i]-sum2。
   4. 重复上述步骤直到清空两个队列



```c++
#include<iostream>
#include<algorithm>
#include<queue>
using namespace std;
long long  T;
long long n;
typedef struct ELE{
long long a;
long long b;
long long c;
long long d;
}Ele;

// 重写力量小根堆
typedef struct cmp1{
    bool operator () (Ele a,Ele b){
        if(a.a==b.a){
            return a.b>b.b;
        }
        return a.a>b.a;
    }
}cmp1;

// 重写智慧小根堆
typedef struct cmp2{
    bool operator()(Ele a,Ele b){
        return a.b>b.b;
    }
}cmp2;
Ele ele[100004];
long long ans1=0;
long long sum1=0;
long long ans2=0;
long long sum2=0;   // 记录当前精神的和
int main(){
    //freopen("test/A.txt","r",stdin);
    cin>>T;
    cin>>n;
    priority_queue<Ele,vector<Ele>,cmp1> Q1 ;  // 力量从小到大的小根堆
    priority_queue<Ele,vector<Ele>,cmp2> Q2;  // 精神从小到大的小根堆
    for(int i =0;i<n;++i){
        cin>>ele[i].a>>ele[i].b>>ele[i].c>>ele[i].d;
        Q1.push(ele[i]); 
    }
    // for(int i = 0;i<n;++i){
    //     cout<<Q1.top().a<<" "<<Q1.top().b<<endl;
    //     Q1.pop();
    // }
    // cout<<endl;
    // for(int i = 0;i<n;++i){
    //     cout<<Q2.top().a<<" "<<Q2.top().b<<endl;
    //     Q2.pop();
    // }
    // cout<<endl;
    
    // 求出最小的力量值
    while(!Q1.empty()){
       Ele p=Q1.top();
       Q1.pop();
       if(sum1>=p.a){// 当前的力量够穿
          sum1+=p.c;
          continue;
       }else{   // 不够穿的时候要更新初始值
          ans1+=p.a-sum1;
          sum1=p.a+p.c;
       }
    }

    // Q1还要用
    for(int i = 0;i<n;++i){
        Q1.push(ele[i]);
    }

    long long beg=ans1;  // 记录最小初始力量
    // 在力量最小值开始满足的情况下，争取精神最小
    while(!Q1.empty()||!Q2.empty()){   // 全部选完之后两个队列都为空
         Ele p;
        // 选出当前力量值下Q1中所有可取装备 
        while(!Q1.empty()){ 
            if(beg<Q1.top().a){  
                break;
            }
            // 可以穿的放到Q2,但是这里害不能穿
            p=Q1.top();
            Q2.push(p);
            Q1.pop();
        }
        // 尝试穿一件
        if(!Q2.empty()){
        p=Q2.top();
        Q2.pop();
        if(sum2>=p.b){ // 当前精神值够穿
            sum2+=p.d;
        }else{
            ans2+=p.b-sum2;
            sum2+=p.b-sum2+p.d;
        }
        beg+=p.c;  // 选了之后要加上力量
        }
    }
    cout<<ans1<<" "<<ans2<<endl;
    
    
}
```

## D[小L的测量学外业](https://www.luogu.com.cn/problem/T186968?contestId=47145)

补的时候看到最短路标签就直接广搜，但是这个题要的不是步数最短，而实拐角最短，所以是先使劲往一个方向搜到墙，再往其方向搜。已经入过队的点不用再入队，但是应该能被经过多次。
```c++
#include<iostream>
#include<queue>
using namespace std;
typedef struct Node{
    int x,y;     // 当前结点的位置
    int step=0;  // 当前的转角数
}Node;
bool visit[103][103];  // 某个点是否已经访问过，即已经入队
int Move[4][2]={{0,1},{0,-1},{-1,0},{1,0}};   // 移动
int W;
int H;
char str[103][103];
int BX;
int BY; // 开始结点
void bfs(){
     queue<Node> Q;
     Node p;
     p.x=BX;
     p.y=BY;
     Q.push(p);
     while(!Q.empty()){
         p=Q.front();
         Q.pop();
         int lx=p.x;
         int ly=p.y;
         int step=p.step;
         for(int e=0;e<4;++e){
             int nx=lx+Move[e][0];
             int ny=ly+Move[e][1];
             // 沿着一条线一直走，直到撞墙
             while(nx<W&&nx>=0&&ny<H&&ny>=0&&str[nx][ny]!='*'){
                 if(str[nx][ny]=='C'){
                     //cout<<e<<" "<<nx<<" "<<ny<<endl;
                 }
                 if(str[nx][ny]=='C'&&!(BX==nx&&BY==ny)){  // 找到了
                     cout<<step<<endl;
                     return ; 
                 }
                 if(!visit[nx][ny]){  // 没遍历过的结点入队                  
                   p.x=nx;
                   p.y=ny;
                   p.step=step+1;
                   visit[nx][ny]=true;
                   Q.push(p);
                 }
                 nx+=Move[e][0];
                 ny+=Move[e][1];
             }

         }
     }
     

    
}
int main(){
    //freopen("test/D.txt","r",stdin);
    cin>>H>>W;
    for(int i = 0;i<W;++i){
        cin>>str[i];
    }
    for(int i = 0;i<W;++i){
        for(int j = 0;j<H;++j){
            visit[i][j]=false;
        }
    }
    // 选出开始结点
    bool flag=true;
    for(int i = 0;i<W;++i){
        for(int j = 0;j<H;++j){
            if(str[i][j]=='C'){
                visit[i][j]=true;
                BX=i;
                BY=j;
                flag=false;
                break;
            }
        }
        if(!flag){
            break;
        }
    }
    bfs();

}
```
      




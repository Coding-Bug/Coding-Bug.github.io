<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"coding-bug.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="我系菜狗">
<meta property="og:type" content="website">
<meta property="og:title" content="CJF的博客">
<meta property="og:url" content="https://coding-bug.github.io/index.html">
<meta property="og:site_name" content="CJF的博客">
<meta property="og:description" content="我系菜狗">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="CJF">
<meta property="article:tag" content="CJF">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://coding-bug.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>CJF的博客</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?<11ff1a384565ec96003abf443c3b41f8>";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">CJF的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://coding-bug.github.io/2021/07/15/%E7%89%9B%E5%AE%A2%E6%AC%A2%E4%B9%90%E8%B5%9B8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CJF">
      <meta itemprop="description" content="我系菜狗">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CJF的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/15/%E7%89%9B%E5%AE%A2%E6%AC%A2%E4%B9%90%E8%B5%9B8E/" class="post-title-link" itemprop="url">牛客欢乐赛8E</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-07-15 07:57:06 / 修改时间：20:46:26" itemprop="dateCreated datePublished" datetime="2021-07-15T07:57:06+08:00">2021-07-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%89%9B%E5%AE%A2/" itemprop="url" rel="index"><span itemprop="name">牛客</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%89%9B%E5%AE%A2/%E6%AF%94%E8%B5%9B/" itemprop="url" rel="index"><span itemprop="name">比赛</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/17574/B">题目链接</a></h2><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>这题给你n个1和m个0，组成一个字符串，并且对任意一个前缀，1都不能比0少。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这是一道比较典型的卡特兰数题。我们可以将问题看作是求解(n+m,n-m)有多少种01字符串组合方式,n+m是字符总数，n-m是1比0多的个数。<br>从(0,0)开始，记将1放进集合记作操作1，将0放进集合记作操作2。</p>
<ul>
<li>进行操作1，集合变成(x+1,y+1),及向右上角走。</li>
<li>进行操作2，集合变成(x+1,y-1)，即往右下角走</li>
</ul>
<p>最后目标是走到(n+m,n-m)。而如果y碰到y=-1这条线，那么就是非法的。<br>于是问题就变成了从(0,0)状态走到(n+m,n-m)状态一共有多少种合法的走法。(走：即向空字符串从头到尾填充0和1，不同的走法就实现了0和1的不同组合)</p>
<ul>
<li>如果考虑所有状况，则很明显是C(n+m,n)   （1要走n步，从n+m步中选出n步的种类，即长度为n+m的字符串中有n个为1有多少种）</li>
<li>所有合法种类我们不好求，但是非法可求，则用合法的减去非法的种类。<ul>
<li>非法的情况即碰过了y=-1的情况如图。 <img src="/2021/07/15/%E7%89%9B%E5%AE%A2%E6%AC%A2%E4%B9%90%E8%B5%9B8E/1.png" class=""></li>
<li>将与y=-1的最后一个交点之前的部分以y=-1为轴对折，可以发现这种情况对应了一种从(0,-2)到(n+m,n-m)的情况。实际在我们这种对折规矩下，所有从(0,0)到(n+m,n-m)的非法情况都和由从(0,-2)到(n+m,n-m)的所有情况一一对应，则所有非法情况种类可以通过求(0,-2)到(n+m,n-m)的<b>所有</b>情况求出。(合法情况是不会对应从(0,-2)到(n+m,n-m)的，因为合法情况没有与y=-1的交点，所以无法与我们规定的这种翻折对应。)<img src="/2021/07/15/%E7%89%9B%E5%AE%A2%E6%AC%A2%E4%B9%90%E8%B5%9B8E/2.png" class=""></li>
<li>非法情况是从(0,-2)到(n+m,n-m)，那么路径就要变。但是总的操作数不能变，因为横坐标还是0到n+m;<ul>
<li>设操作1变为a种，操作2变为b种则<script type="math/tex">\begin{cases}a+b=n+m\\a-b=n-m+2\end{cases}</script><br>解得 <script type="math/tex">\begin{cases}a=n+1 \\ b=m-1 \end{cases}</script><br>则非法情况总数为C(n+m,n+1)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>最后ans=C(n+m,n)-C(n+m,n+1)</p>
<h3 id="组合数求解"><a href="#组合数求解" class="headerlink" title="组合数求解"></a>组合数求解</h3><script type="math/tex; mode=display">C{a\atop m}\pmod p=\frac{n!}{m!(n-m!)}\pmod p</script><p>可以看出，如果直接求解组合数然后再取模，那么分子或者分母会溢出。而取模分配率对加减乘成立，如对乘法有  </p>
<p><center>(a&nbsp;*&nbsp;b)%p&nbsp;=&nbsp;[(a%p)&nbsp;*&nbsp;(b%p)]%p</center><br>但是对除法却不存在</p>
<p><center>(a&nbsp;/&nbsp;b)%p&nbsp;=&nbsp;[(a%p)&nbsp;/&nbsp;(b%p)]%p&nbsp;(错误)</center><br>那怎么办呢，于是科学家们扔出了逆元这个玩意。  </p>
<h4 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h4><p><b>定理</b>：若在mod&nbsp;p意义下，对于一个整数a，有<script type="math/tex">a*x\equiv 1\pmod p</script>那么这个整数x即为a的乘法逆元，同时a也为x的乘法逆元。  </p>
<p><b>充要条件</b>：a存在模p的乘法逆元的充要条件是gcd(a,p)&nbsp;=1&nbsp;，即a与p互质。  </p>
<p><b>应用</b>：求$\frac{a}{b}\%p$等同于求a * (b的逆元)%p   </p>
<ul>
<li><b>证明</b>：<br>我们假设 <script type="math/tex">\frac{a}{b}\%p=m(a和b满足a\%b=0)\tag{1}</script><br>由乘法逆元符合分配律对(1)式两边乘以b有<script type="math/tex">a\%p=(m(b\%p))\%p\tag{2}</script><br>即<script type="math/tex">a\equiv m*b\pmod p\tag{3}</script><br>假设b的逆元是x，则(3)式两边乘以一个x有<script type="math/tex; mode=display">a*x\equiv m*b*x\pmod p\tag{4}</script>由逆元的定理有$b<em>x\equiv 1\pmod p$则<br>$$a</em>x\equiv m\pmod p\tag{5}$$证毕</li>
</ul>
<p>于是我们就可以把除法的求模运算转换为乘法的求模运算，从而可以利用分配律。</p>
<p><b>类比</b>：其实逆元可以类比于普通乘法中的倒数，即当$b*x=1$时$\frac{1}{b}=x$，但是在求模运算中，x与$\frac{1}{b}$只是等同，而并非就是取倒数。</p>
<h4 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h4><p>那么逆元怎么求解呢，可不是像普通乘法那样直接是倒数。则可以通过定义$a*x\equiv1\pmod p$来求解逆元。<br>由于在ACM中大多数时候p是质数，否则容易找到余数的规律，所以用费马里小定理即可求解a的逆元。  </p>
<p><b>定理：</b>  假如a是一个整数，p是一个质数，那么</p>
<ol>
<li>如果a是p的倍数，$a^p\equiv a \pmod p$ </li>
<li>如果a不是p的倍数，$a^{p-1}\equiv 1 \pmod p$  </li>
</ol>
<p>由乘法逆元的充要条件是gcd(a,p)&nbsp;=1&nbsp;，所以a不会是p的倍数，所以用第二条。将第二条转化以下有<script type="math/tex">a*a^{p-2}\equiv 1\pmod p</script><br>则$a^{p-2}$就是a的逆元，证明自己去百度。</p>
<p>最后利用快速幂求解即可。</p>
<h4 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h4><p>快速幂即求解幂的快速算法。考察$3^{10}$,有</p>
<script type="math/tex; mode=display">3^{10}=9^{5}=9*81^{2}=9*6561^{1}=(9*6561)*1^{0}</script><p>设幂为p，底数为b，则其算法思路为</p>
<ol>
<li>如果p是偶数，b=b*b；p&gt;&gt;1</li>
<li>如果p是奇数，那么ans=ans <em> b；b=b </em> b</li>
</ol>
<p>这样最后得到的结果即在ans中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> mod =<span class="number">20100403</span>;</span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求阶乘</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fac</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i = a;i&gt;=<span class="number">1</span>;--i)&#123;</span><br><span class="line">       ans=(ans*i%mod)%mod;</span><br><span class="line">       ans=ans%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 矩阵快速幂求逆元</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Fpow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> b,<span class="keyword">long</span> <span class="keyword">long</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">           b=(b*b)%mod;</span><br><span class="line">           p=p/<span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           ans=(ans*b)%mod;</span><br><span class="line">           b=(b*b)%mod;</span><br><span class="line">           p=p/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 求组合数</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> a1=<span class="built_in">fac</span>(a);  <span class="comment">// 求分子</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> b1=(<span class="built_in">fac</span>(b)*<span class="built_in">fac</span>(a-b))%mod; <span class="comment">//分母</span></span><br><span class="line">    <span class="comment">//求b的逆元</span></span><br><span class="line">    b1=<span class="built_in">Fpow</span>(b1,mod<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">return</span> ((a1%mod)*(b1%mod))%mod;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;test/E.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line">    ans=(<span class="built_in">C</span>(n+m,n)-<span class="built_in">C</span>(n+m,n+<span class="number">1</span>)+mod)%mod; <span class="comment">// 可能会求得附属，所以先加上模再取模，因为计算结果是分别取模之后的，所以小的可能本来就比mod小</span></span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://coding-bug.github.io/2021/06/25/USST%E9%A2%98%E8%A7%A3%E6%8A%A5%E5%91%8A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CJF">
      <meta itemprop="description" content="我系菜狗">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CJF的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/25/USST%E9%A2%98%E8%A7%A3%E6%8A%A5%E5%91%8A/" class="post-title-link" itemprop="url">USST题解报告</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-25 16:44:06" itemprop="dateCreated datePublished" datetime="2021-06-25T16:44:06+08:00">2021-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-15 18:15:26" itemprop="dateModified" datetime="2021-07-15T18:15:26+08:00">2021-07-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="上海理工校赛题解报告"><a href="#上海理工校赛题解报告" class="headerlink" title="上海理工校赛题解报告"></a>上海理工校赛题解报告</h1><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>数学题，不会</p>
<h2 id="B题-Bheith-i-ngra-le"><a href="#B题-Bheith-i-ngra-le" class="headerlink" title="B题 Bheith i ngra le"></a>B题 <a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/17574/B">Bheith i ngra le</a></h2><p>当初挣扎了一下，然后不会求给定i行j列的格子有多少单调曲线，就放弃了。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>题目的核心是是求给定i行j列的格子能够构造多少调单调曲线。可以用dp或者组合求解，不喜欢数学的我毅然投奔了dp。  </li>
<li>不难发现，当给定了宽为i，高为j的格子矩阵的时候，我们分析右上角那块，如果这块不画，那么所有情况就会变成dp[i][j-1],如果这块画上，那么情况就会是dp[i-1][j]。则得到状态转移方程dp[i][j]=dp[i][j-1]+dp[i-1][j]。当然，边界条件还是值得考虑一下的。</li>
<li>算出dp数组后，性高彩烈的用n<sup>3</sup>去套老鹅。其实我们确定了山顶左边位置l之后不用去确定右边的r，dp[n-l][h]就是右边包含山顶在内的全部可能。所以ans=ans+dp[l-1][h-1]*dp[n-l][h]即可。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[<span class="number">2003</span>][<span class="number">2003</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,m;</span><br><span class="line">	cin &gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="comment">// 初始化高度为1时</span></span><br><span class="line">	dp[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		dp[i][<span class="number">1</span>]=dp[i<span class="number">-1</span>][<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 初始化宽度为1的时候</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>;j&lt;=m;++j)&#123;</span><br><span class="line">		dp[<span class="number">1</span>][j]=dp[<span class="number">1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">	&#125; </span><br><span class="line">    <span class="comment">// 求dp，i为宽，j为高</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>;j&lt;=m;++j)&#123;</span><br><span class="line">           dp[i][j]=(dp[i][j<span class="number">-1</span>]+dp[i<span class="number">-1</span>][j])%mod;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 宽度为0时答案应该为1，因为下面用的乘法</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=m;++j)&#123;</span><br><span class="line">		dp[<span class="number">0</span>][j]=<span class="number">1</span>;</span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">   <span class="comment">// 高度为0时，也应该是1，即取0</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;=n;++i)&#123;</span><br><span class="line">	   dp[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// cout&lt;&lt;dp[1][1]&lt;&lt;endl&lt;&lt;dp[2][1]&lt;&lt;endl&lt;&lt;dp[1][2]&lt;&lt;endl&lt;&lt;dp[2][2]&lt;&lt;endl&lt;&lt;dp[1][3]&lt;&lt;endl&lt;&lt;dp[2][3]&lt;&lt;endl; </span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 枚举山顶的情况,l是左边，r是右边，h是山高</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>;l&lt;=n;++l)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> h = <span class="number">1</span>;h&lt;=m;++h)&#123;</span><br><span class="line">               ans = (ans+(dp[l<span class="number">-1</span>][h<span class="number">-1</span>]*dp[n-l][h])%mod)%mod;   <span class="comment">// 是左边的情况乘以右边的情况</span></span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 加上山顶全为0的情况，只有一种</span></span><br><span class="line">	 ans=(ans+<span class="number">1</span>)%mod;</span><br><span class="line"></span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="J题-JXC-amp-JESUS"><a href="#J题-JXC-amp-JESUS" class="headerlink" title="J题 JXC&amp;JESUS"></a>J题 <a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/17574/J">JXC&amp;JESUS</a></h2><p>这是一个数学题</p>
<h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>题目大概的意思是定义了一个函数  </p>
<script type="math/tex; mode=display">f(i,m)=p_{1}^{ \lfloor\frac{a1}{m}  \rfloor}*p_{2}^{a_2} * ... * p^{k}_ {a^k}</script><p>其中p<sub>1</sub>,p<sub>2</sub> …p<sub>k</sub>为i的质因数。给定参数n,m,L求  </p>
<script type="math/tex; mode=display">\sum\limits_{i=L+1}^{L+n}-f(i,m)</script><p>这关系到i的质因数的问题，可以用线性筛求质因数。又f(i,m)只和m与其最小质因子有关，我们在线性筛的时候合数也是被其最小质因子筛掉。所以想到从线性筛的基础上进行状态转移，由小的质数推出合数的f(i,m)，从而使求答案也变成线性。另一种是求出了素数之后直接暴力，也能过。<br>根据以下算法枚举&nbsp;i&nbsp;进行计算</p>
<ul>
<li>当i是质数的时候，当m=1时，f[i]=i,否则f[i]=1。（注意：1不是质因数）  </li>
<li>枚举质数prime[j]利用i对i*prime[j]进行推算。<ul>
<li>当prime[j]不能整除i时，则prime[j]是i<em>prime[j]的最小质因子，且只有一个，cnt[i </em> prime[j]]&nbsp;=&nbsp;1。当m&nbsp;=&nbsp;1时，f[i <em> prime[j]]&nbsp;=&nbsp;i </em>prime[j],否则f[i * prime[j]]&nbsp;=&nbsp;i。(因为此时$\lfloor  \frac{a1}{m}  \rfloor$为0)</li>
<li>当prime[j]能整除i时，则prime[j]也是i的最小质因子，此时cnt[i <em> prime[j]]&nbsp;=&nbsp;cnt[i]&nbsp;+&nbsp;1。当cnt[i </em> prime[j]]%m&nbsp;=0&nbsp;时，f[i <em> prime[j]]&nbsp;=&nbsp;i </em>prime[j],否则f[i * prime[j]]&nbsp;=&nbsp;i。（此时应该枚举新的i，就如线性筛那样。）  </li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 20000003</span></span><br><span class="line"><span class="keyword">int</span> prime[MAX];   <span class="comment">// 存素数</span></span><br><span class="line"><span class="keyword">bool</span> isprime[MAX]; <span class="comment">// 判断是否素数</span></span><br><span class="line"><span class="keyword">int</span> n,m,L;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;   <span class="comment">// 存放答案</span></span><br><span class="line"><span class="keyword">int</span> cnt[MAX]; <span class="comment">// 存放最小质因数的个数</span></span><br><span class="line"><span class="keyword">int</span> CNT=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> f[MAX];  <span class="comment">// f存起来，因为可能提前求得</span></span><br><span class="line"><span class="keyword">int</span> minp[MAX]; <span class="comment">// 记录合数的最小质因子</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求素数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calPrime</span><span class="params">()</span></span>&#123;</span><br><span class="line">    prime[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    isprime[<span class="number">0</span>]=isprime[<span class="number">1</span>]=isprime[<span class="number">2</span>]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i&lt;=MAX;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isprime[i])&#123;</span><br><span class="line">            prime[CNT++]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将i的倍数标记为合数，合数只会被其最小质因子标记，所以很方便可求出最小质因子</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;CNT&amp;&amp;i*prime[j]&lt;=MAX;++j)&#123;</span><br><span class="line">            isprime[i*prime[j]]=<span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 如果i能够整除prime[j]，则退出</span></span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 直接求f</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">F</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">2</span>;i&lt;=L+n;++i)&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// i是质数的情况,其最小质因数为其本身,则根据m讨论f</span></span><br><span class="line">        <span class="keyword">if</span>(isprime[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(m==<span class="number">1</span>)&#123;</span><br><span class="line">                f[i]=i;</span><br><span class="line">                cnt[i]=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                f[i]=<span class="number">1</span>;</span><br><span class="line">                cnt[i]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// i不是质数的情况,枚举质数，不包括1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;CNT&amp;&amp;i*prime[j]&lt;=L+n;++j)&#123;</span><br><span class="line">            <span class="comment">// 如果i不能整除prime[j],此时prime[j]是i*prime[j]的最小质因子，因为i非质数</span></span><br><span class="line">           <span class="keyword">if</span>(i%prime[j]!=<span class="number">0</span>)&#123;  </span><br><span class="line">               <span class="keyword">if</span>(m==<span class="number">1</span>)&#123;</span><br><span class="line">                   f[i*prime[j]]=i*prime[j];</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;   <span class="comment">//m!=1时，最最小质因数就无贡献了</span></span><br><span class="line">                   f[i*prime[j]]=i;</span><br><span class="line">               &#125;</span><br><span class="line">               cnt[i*prime[j]]=<span class="number">1</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123; <span class="comment">// 如果prime[j]能整除当前的i，则prime[j]也是i的最小质因子</span></span><br><span class="line">               cnt[i*prime[j]]=cnt[i]+<span class="number">1</span>;</span><br><span class="line">               <span class="comment">// 只有当cnt是m的倍数的时候，prime[j]才有贡献</span></span><br><span class="line">               <span class="keyword">if</span>(cnt[i*prime[j]]%m==<span class="number">0</span>)&#123;  </span><br><span class="line">                   f[i*prime[j]]=f[i]*prime[j];</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   f[i*prime[j]]=f[i];</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">               </span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(isprime,<span class="literal">true</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(isprime));</span><br><span class="line">    <span class="built_in">memset</span>(cnt,<span class="number">1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(cnt));</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;L;</span><br><span class="line">    <span class="built_in">calPrime</span>(); <span class="comment">//求素数</span></span><br><span class="line">    <span class="built_in">F</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = L+<span class="number">1</span>;i&lt;=L+n;++i)&#123;</span><br><span class="line">        ans+=i-f[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="M题-Minecraft"><a href="#M题-Minecraft" class="headerlink" title="M题 Minecraft"></a>M题 <a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/17574/M">Minecraft</a></h2><p>这题挺简单，毕竟人家说了时签到题，不过这个输入格式确实有点费脑。</p>
<h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>根据题目，差不多重点就是下面</p>
<ul>
<li>每次从房子的每根“柱子”最底下建起方块(因为不能流沙)。</li>
<li>每次选定一个字母之后所以该字母的位置都要建方块！  </li>
<li>最后要以最大字典序输出！  </li>
</ul>
<p>可以通过有向图和拓扑排序解决，先填充入度为0的字母，然后更新图，如果全部入度为0的都已经访问了还有入度不为0，就重建失败。<br>对于字典序问题，没有用优先队列，直接在while里面套一个for即可，并且要从字母Z遍历到A，特别注意的是，一旦找到一个字母后，要重新进行for循环，不然达不到字典序。就因为这个卡88.9%给我整吐了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 27     </span></span><br><span class="line"><span class="keyword">int</span> t;   <span class="comment">// 测试数</span></span><br><span class="line"><span class="keyword">int</span> n,m,h;  <span class="comment">// 长宽高</span></span><br><span class="line"><span class="keyword">int</span> let[<span class="number">35</span>][<span class="number">35</span>][<span class="number">35</span>];   <span class="comment">// 在房子某个坐标的字母,用int存</span></span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">NODE</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> in=<span class="number">0</span>;   <span class="comment">// 入度</span></span><br><span class="line">    <span class="keyword">int</span> out=<span class="number">0</span>;  <span class="comment">// 出度</span></span><br><span class="line">    <span class="keyword">int</span> next[<span class="number">30000</span>];  <span class="comment">// 连接的下一个点，注意点的个数</span></span><br><span class="line">    <span class="keyword">bool</span> isused=<span class="literal">false</span>;  <span class="comment">// 记录是否已经访问过 </span></span><br><span class="line">    <span class="keyword">bool</span> isExit=<span class="literal">false</span>;</span><br><span class="line">&#125;NODE;</span><br><span class="line"><span class="keyword">char</span> ans[MAX]; <span class="comment">// 存放答案的字母</span></span><br><span class="line"><span class="keyword">int</span>  cnt=<span class="number">0</span>;   <span class="comment">// 答案中共有多少个字母</span></span><br><span class="line">NODE Node[MAX];    <span class="comment">// 设置结点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;test/USSTM.txt&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="comment">// 每次开始的时候记得还原</span></span><br><span class="line"></span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">        c=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;MAX;++i)&#123;</span><br><span class="line">            Node[i].in=<span class="number">0</span>;</span><br><span class="line">            Node[i].isExit=<span class="literal">false</span>;</span><br><span class="line">            Node[i].isused=<span class="literal">false</span>;</span><br><span class="line">            Node[i].out=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;m&gt;&gt;h;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>||m==<span class="number">0</span>||h==<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;-1&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 输入考了一波理解</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = h<span class="number">-1</span>;k&gt;=<span class="number">0</span>;--k)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;m;++j)&#123;</span><br><span class="line">                </span><br><span class="line">                cin&gt;&gt;c;</span><br><span class="line">               let[i][j][k]=(<span class="keyword">int</span>)c-<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">               Node[let[i][j][k]].isExit=<span class="literal">true</span>;</span><br><span class="line">               </span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始构造图</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>;k&lt;h;++k)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;m;++j)&#123;</span><br><span class="line">                <span class="comment">// 如果和下面的不相等，则要生成边</span></span><br><span class="line">                <span class="keyword">if</span>(let[i][j][k]!=let[i][j][k<span class="number">-1</span>])&#123;</span><br><span class="line">                    <span class="keyword">int</span> tempU=let[i][j][k];</span><br><span class="line">                    <span class="keyword">int</span> tempL=let[i][j][k<span class="number">-1</span>];</span><br><span class="line">                    Node[tempU].in++;</span><br><span class="line">                    Node[tempL].next[Node[tempL].out++]=tempU;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> canUsed=<span class="literal">true</span>;    <span class="comment">// 记录能否找到入度为0且没有访问过的结点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(canUsed)&#123;</span><br><span class="line">        canUsed=<span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 从字母大的找起,这里就不用优先队列了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">25</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">           <span class="comment">// 本来有这个点才去判断</span></span><br><span class="line">           <span class="keyword">if</span>(Node[i].isExit)&#123;</span><br><span class="line">                <span class="comment">// 入度为0且没有访问过</span></span><br><span class="line">                <span class="keyword">if</span>(Node[i].in==<span class="number">0</span>&amp;&amp;!Node[i].isused)&#123;</span><br><span class="line">                    canUsed=<span class="literal">true</span>;</span><br><span class="line">                    ans[cnt++]=<span class="built_in"><span class="keyword">char</span></span>(i+<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">                    <span class="comment">// 更新结点状态,并更新其连接的边的状态</span></span><br><span class="line">                     Node[i].isused=<span class="literal">true</span>; </span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;Node[i].out;++j)&#123;</span><br><span class="line">                         Node[Node[i].next[j]].in--;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 找到一个之后，一定要重新再来，不然达不到字典序</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否还有没有访问过的本来存在的点</span></span><br><span class="line">        <span class="keyword">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">25</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">           <span class="comment">// 本来有这个点才去判断</span></span><br><span class="line">           <span class="keyword">if</span>(Node[i].isExit)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!Node[i].isused)&#123;</span><br><span class="line">                    flag =<span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;-1&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;cnt;++i)&#123;</span><br><span class="line">                cout&lt;&lt;ans[i];</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://coding-bug.github.io/2021/06/13/MaxMedian/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CJF">
      <meta itemprop="description" content="我系菜狗">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CJF的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/13/MaxMedian/" class="post-title-link" itemprop="url">MaxMedian</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-13 11:57:10" itemprop="dateCreated datePublished" datetime="2021-06-13T11:57:10+08:00">2021-06-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-15 18:15:26" itemprop="dateModified" datetime="2021-07-15T18:15:26+08:00">2021-07-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/div1/" itemprop="url" rel="index"><span itemprop="name">div1</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><img src="/2021/06/13/MaxMedian/MaxMedian.png" class="">
<h3 id="题目简述"><a href="#题目简述" class="headerlink" title="题目简述"></a>题目简述</h3><p>这题是长度不小于k连续子序列排队后的最大中位数。其中排序后+中位数定义下标为$\lfloor(r-l+1)/2\rfloor$.</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这是一道求长度不小于k的连续子序列问题，但它又不是简单求连续子序列的问题。而是求中位数，而且是子序列排序后的中位数，并且要中位数最大。这种场景很难不让人想到二分答案+问题转化。<br>通过观察不难发现</p>
<ul>
<li>如果连续子序列长度是偶数，如[1,2,3,4,5,6],那么大于等于中位数的数会比小于中位数的数多两个。</li>
<li>如果连续子序列的长度是奇数，如[1,2,3,4,5]那么大于等于中位数的数会比小于中位数的数一两个。<br>除上面所述两中情况之外不会有其他情况。</li>
</ul>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>根据分析可以巧妙设计算法，假设答案ans，如果序列中的值大于等于ans，令其等于1，否等于-1。如果变换后的序列中长度不小于k的最大连续子序列的值小于0，就说明中位数ans设大了，则答案往小取，否则答案往大取，直到二分区间无穷小。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">200002</span>];</span><br><span class="line"><span class="keyword">int</span> sum[<span class="number">200002</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="comment">//freopen(&quot;test/div1C.txt&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="comment">// 关同步流</span></span><br><span class="line">     ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">     cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> l=<span class="number">-1e9</span>;   <span class="comment">// 答案左区间</span></span><br><span class="line">    <span class="keyword">double</span> r=<span class="number">1e9</span>;    <span class="comment">// 答案右区间</span></span><br><span class="line">    <span class="keyword">while</span>(r-l&gt;<span class="number">1e-5</span>)&#123;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;l&lt;&lt;&quot; &quot;&lt;&lt;r&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">double</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//求变形之后地前缀和</span></span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">0</span>]&gt;=mid)&#123;</span><br><span class="line">            sum[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            sum[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;n;++j)&#123;</span><br><span class="line">           <span class="keyword">if</span>(a[j]&gt;=mid)&#123;</span><br><span class="line">               sum[j]=sum[j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               sum[j]=sum[j<span class="number">-1</span>]<span class="number">-1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 求最大子段和</span></span><br><span class="line">       <span class="keyword">int</span> Min=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> Max=<span class="number">-1e9</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = k;i&lt;n;++i)&#123;</span><br><span class="line">           Min=<span class="built_in">min</span>(Min,sum[i-k]);</span><br><span class="line">           Max=<span class="built_in">max</span>(Max,sum[i]-Min);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Max=<span class="built_in">max</span>(Max,sum[k<span class="number">-1</span>]);</span><br><span class="line">       <span class="keyword">if</span>(Max&gt;<span class="number">0</span>)&#123;</span><br><span class="line">           l=mid;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           r=mid;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;(<span class="keyword">int</span>)r&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://coding-bug.github.io/2021/06/13/BestCowFences/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CJF">
      <meta itemprop="description" content="我系菜狗">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CJF的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/13/BestCowFences/" class="post-title-link" itemprop="url">BestCowFences</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-13 00:35:27" itemprop="dateCreated datePublished" datetime="2021-06-13T00:35:27+08:00">2021-06-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-15 18:15:26" itemprop="dateModified" datetime="2021-07-15T18:15:26+08:00">2021-07-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/div1/" itemprop="url" rel="index"><span itemprop="name">div1</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><img src="/2021/06/13/BestCowFences/BestCowFence.png" class="">
<h3 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h3><p>题目大概就是围起连续不小于f的数，使他们的平均值最大，求出这个最大值。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p> 如果是求连续子序列最大和，那么问题就很简单。但是他这里要求的是最大平均数，由于最大平均数不仅和连续子序列的和有关，还和连续子序列的长度有关。即average=sum/length。则事情就变得不那么简单了。</p>
<h5 id="二分答案"><a href="#二分答案" class="headerlink" title="二分答案"></a>二分答案</h5><p>这里用到二分答案策略，所谓的二分答案，就是假设所求的值刚开始在一个区间段[l,r]，然后选取这个区间段的中间值mid作为答案，如果算出这个中间值取大了，就从左半区间[l,mid],否则从[mid,r]找最后直到区间缩到无穷小，则此时区间的逼近值即为正确答案。这个其实在数值分析里面学过。</p>
<h5 id="变向思维"><a href="#变向思维" class="headerlink" title="变向思维"></a>变向思维</h5><p>我们要求连续区间的最大平均值，很困难，因为这个平均值不仅和连续区间和sum有关，还与区间长度length有关，这就需要我们将问题进行转换。</p>
<p>假设最大平均值为ans，则对于平均值最大的那段区间[i,j]有(a<sub>i</sub>+a<sub>i+1</sub>+…+a<sub>j</sub>)/length=ans。即(a<sub>i</sub>+a<sub>i+1</sub>+…+a<sub>j</sub>)-ans*length=0。</p>
<ul>
<li><p>如果有大于ans的区间段平均值，则对于最大的区间段[p,q],有(a<sub>p</sub>+a<sub>p+1</sub>+…+a<sub>q</sub>)/length&gt;ans，即(a<sub>p</sub>+a<sub>p+1</sub>+…+a<sub>q</sub>)-ans*length&gt;0。那么我们的ans就偏小了。这就是一个二分的判断偏小依据。</p>
</li>
<li><p>如果全部的区间段平均值都小于ans，则对于最大的区间段，有(a<sub>p</sub>+a<sub>p+1</sub>+…+a<sub>q</sub>)/length<ans,即(a<sub>p&lt;/sub&gt;+a<sub>p+1</sub>+…+a<sub>q</sub>)-ans*length&lt;0,则此时ans偏大了。得到一个二分偏大的判断。</p>
</li>
</ul>
<p>那么问题就从求连续子序列最大平均值，转换成了求(a<sub>i</sub>+a<sub>i+1</sub>+…+a<sub>j</sub>)-ans <em> length的值。我们将整个区间段[0,n-1]的值全部减去ans，那么我们在求连续子序列的和时，就相当于求a<sub>i</sub>+a<sub>i+1</sub>+…+a<sub>j</sub>-ans </em> lengths的值。则问题最终变成了一个连续子序列求和问题。</p>
<h5 id="长度不小于f的最大连续子序列问题"><a href="#长度不小于f的最大连续子序列问题" class="headerlink" title="长度不小于f的最大连续子序列问题"></a>长度不小于f的最大连续子序列问题</h5><p>我们可以先求出[0,n]的前缀和sum[i] i=0,1,2…n。由于子序列的长度不能小于f，则以i结尾的连续子序列dp[i] (i&gt;=f)，前f个数一定是要的。先让dp[i]=sum[i],则sum[i]-sum[i-k-1]这段肯定要留在dp[i]里面。所以只需要找到sum[0] ~ sum[i-k]中小于0的最小值sum[m]，然后令dp=sum[i]-sum[m]即为以i结尾的连续子序列的最大值（就是把前面连续的最自己没有正作用的子序列干掉）。则我们要维护从sum[0]~sum[i-k]的最小值，并且每次用dp[i]更新整个区间内连续子序列的最大值即可。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=f;i&lt;n;++i)&#123;</span><br><span class="line">           Min=<span class="built_in">min</span>(Min,sum[i-f]);   </span><br><span class="line">           Max=<span class="built_in">max</span>(Max,sum[i]-Min);   <span class="comment">// sum[i]-Min是以i结尾的最大连续子段和，Max是之前求出的最大连续子段和</span></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>先假定二分区间为很大，然后二分假设答案mid，令原数组所有的数减去mid得到新数组。求新数组中长度不小于k的连续子序列的最大和，如果结果大于0，说明ans设小了，区间往右边分，否则区间往左边分。直到最后区间逼近一个数为止。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">double</span> a[<span class="number">100002</span>];</span><br><span class="line"><span class="keyword">double</span> b[<span class="number">100002</span>];</span><br><span class="line"><span class="keyword">double</span> sum[<span class="number">100002</span>]; <span class="comment">// 记录第i个数之前的和</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> f;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;test/div1A.txt&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">double</span> mid;       <span class="comment">// 假设的答案 </span></span><br><span class="line">    cin&gt;&gt;n&gt;&gt;f;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="comment">//scanf(&quot;%lf&quot;,&amp;a[i]);  // 用cin会套老鹅</span></span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> l=<span class="number">-1e6</span>;    <span class="comment">// 答案区间的左边</span></span><br><span class="line">    <span class="keyword">double</span> r=<span class="number">1e6</span>;     <span class="comment">// 答案区间的右边</span></span><br><span class="line">    <span class="keyword">while</span>(r-l&gt;<span class="number">1e-4</span>)&#123;</span><br><span class="line">       mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">       <span class="comment">// 先求出减去平均值后的数组</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">           b[i]=a[i]-mid;   </span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       sum[<span class="number">0</span>]=b[<span class="number">0</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">            sum[i]=sum[i<span class="number">-1</span>]+b[i];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">double</span> Min=<span class="number">0</span>;     <span class="comment">// 记录以j(0&lt;=j&lt;i-f)结尾大子段和的最小值，初始值应该为0，因为比0小的我们才不要</span></span><br><span class="line">                         <span class="comment">// 如果这里初始化为一个很大的值，那么若sum[0]大于0，就会被认为是要被抛弃的，然而我们只需要抛弃小于0的</span></span><br><span class="line">       <span class="keyword">double</span> Max=<span class="number">-1e9</span>;      <span class="comment">// 记录长度大于f的最大子段和</span></span><br><span class="line">       <span class="comment">// 求限定长度为f的最大连续子段和</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=f;i&lt;n;++i)&#123;</span><br><span class="line">           Min=<span class="built_in">min</span>(Min,sum[i-f]);   </span><br><span class="line">           Max=<span class="built_in">max</span>(Max,sum[i]-Min);   <span class="comment">// sum[i]-Min是以i结尾的最大连续子段和，Max是之前求出的最大连续子段和</span></span><br><span class="line">       &#125;</span><br><span class="line">       Max=<span class="built_in">max</span>(Max,sum[f<span class="number">-1</span>]);   <span class="comment">// 观察可知上面没有判断sum[f-1]的情况</span></span><br><span class="line">       <span class="keyword">if</span>(Max&gt;<span class="number">0</span>)&#123;  <span class="comment">// Max&gt;0说明答案不够大</span></span><br><span class="line">         l=mid;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;      <span class="comment">// 否则就是答案不够小</span></span><br><span class="line">         r=mid;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;(<span class="keyword">int</span>)(<span class="number">1000</span>*r)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://coding-bug.github.io/2021/06/11/%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CJF">
      <meta itemprop="description" content="我系菜狗">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CJF的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/11/%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/" class="post-title-link" itemprop="url">数据备份</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-11 15:52:27" itemprop="dateCreated datePublished" datetime="2021-06-11T15:52:27+08:00">2021-06-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-15 18:15:26" itemprop="dateModified" datetime="2021-07-15T18:15:26+08:00">2021-07-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/div1/" itemprop="url" rel="index"><span itemprop="name">-div1</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><img src="/2021/06/11/%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD/backUp.png" class="">
<h3 id="题目简述"><a href="#题目简述" class="headerlink" title="题目简述"></a>题目简述</h3><p>大概就是有n个办公楼，要找出k对，每对之间拉一个电缆，并且每个楼只能用一次，求出最小的距离之和</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul>
<li>首先要明确，找出的n对楼里面，每对肯定是相邻的，若不相邻，则令其中间的任一一对代替，能得到更优结果</li>
<li>如果每次只选择最小那对，也是不行的，如：<ul>
<li>现在有一个原始的对序列 2 1 2 5 6，要找两队。则放到优先队列中有 1 2 2 5 6，如果先选最小的，则现在选的是1，由于1中两个城市在2 2 这两队中，所以2 2 要丢掉。则优先队列中能用的只剩下 5 6，则下次应该选择5。不难发现，如果不选1的话，选2 2明显会比选1 5好。到这里不难发现，我们要后悔。、</li>
</ul>
</li>
<li>那么怎么进行后悔呢？<ul>
<li>我们在选择最小的1之后，2 2 本来是要废掉的，但是我们不直接丢掉他们，而是创建一个新的数为 2+2-1=3 放入优先队列中。则优先队列中剩下的为 3 5 6，这样我们下次选3就相当于选了 2+2-1+1，即 2 2，后悔成功。</li>
</ul>
</li>
</ul>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>每次取最小的一个区间，然后将这个数两边得区间合并，并减去这个数，构成后悔结点（则原区间最左边和最右边还应该加一段无穷大）。一直做下去，最终即可得到结果。<br>区间段用链表维护。需要注意的是链表的更新。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> s[<span class="number">100002</span>];     <span class="comment">// 每个公司到起点的距离</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个相邻区间作为一个结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">      <span class="keyword">long</span> <span class="keyword">long</span>  Len;            <span class="comment">// 区间的长度</span></span><br><span class="line">      <span class="keyword">int</span> pos;                   <span class="comment">// 当前结点的位置c</span></span><br><span class="line">&#125;NODE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仿函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(Node a,Node b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.Len&gt;b.Len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> isUsed[<span class="number">100002</span>];<span class="comment">// 判断某个结点是否已经使用过</span></span><br><span class="line"><span class="keyword">int</span> Next[<span class="number">100002</span>];   <span class="comment">// 存放某个结点的下一个结点</span></span><br><span class="line"><span class="keyword">int</span> Prio[<span class="number">100002</span>];   <span class="comment">// 存放某个节点的一个结点 </span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> val[<span class="number">100002</span>]; <span class="comment">// 要得到某个位置的值信息，不能从队列里获得，要另存  </span></span><br><span class="line"></span><br><span class="line">NODE sNode;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;test/div1C.txt&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="comment">// 初始化标记数组</span></span><br><span class="line">    <span class="built_in">memset</span>(isUsed,<span class="literal">false</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(isUsed));</span><br><span class="line">    <span class="keyword">int</span> n,k;    <span class="comment">// 办公楼数和可以铺设的电网数</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        cin&gt;&gt;s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    priority_queue&lt;NODE,vector&lt;NODE&gt;,tmp&gt; Q;    <span class="comment">// 设置一个小根堆存放现有结点</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化第一个结点</span></span><br><span class="line">    sNode.Len=s[<span class="number">1</span>]-s[<span class="number">0</span>];</span><br><span class="line">    sNode.pos=<span class="number">1</span>;    <span class="comment">// 从1开始</span></span><br><span class="line">    Prio[<span class="number">1</span>]=<span class="number">0</span>;     <span class="comment">// 第一个结点前驱为空</span></span><br><span class="line">    Next[<span class="number">1</span>]=<span class="number">2</span>;       <span class="comment">// 后继为1</span></span><br><span class="line">    val[<span class="number">1</span>]=sNode.Len;</span><br><span class="line">    Q.<span class="built_in">push</span>(sNode);  <span class="comment">// 第一个结点入队</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化其他结点,最后一个结点的下标是n-1，因为一共有n-1个结点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>; i&lt;n<span class="number">-1</span>;++i)&#123;</span><br><span class="line">        sNode.Len=s[i+<span class="number">1</span>]-s[i];</span><br><span class="line">        sNode.pos=i+<span class="number">1</span>;    </span><br><span class="line">        Prio[i+<span class="number">1</span>]=i;     </span><br><span class="line">        Next[i+<span class="number">1</span>]=i+<span class="number">2</span>;       </span><br><span class="line">        val[i+<span class="number">1</span>]=sNode.Len;</span><br><span class="line">        Q.<span class="built_in">push</span>(sNode);     </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两端设极大</span></span><br><span class="line">    val[<span class="number">0</span>]=<span class="number">2e9</span>;</span><br><span class="line">    val[n]=<span class="number">2e9</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行贪心选择</span></span><br><span class="line">    <span class="keyword">while</span>(k!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 跳过无效结点</span></span><br><span class="line">        <span class="keyword">while</span>(isUsed[Q.<span class="built_in">top</span>().pos])&#123;</span><br><span class="line">            Q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        sNode=Q.<span class="built_in">top</span>();  <span class="comment">// 取出长度最小的那个有效结点</span></span><br><span class="line">        Q.<span class="built_in">pop</span>();</span><br><span class="line">        ans+=sNode.Len;  <span class="comment">// 取了这个点，答案要加上</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 求新的结点的长度，实现隐式反悔</span></span><br><span class="line">        sNode.Len=val[Prio[sNode.pos]]+val[Next[sNode.pos]]-val[sNode.pos];</span><br><span class="line">        val[sNode.pos]=sNode.Len;</span><br><span class="line">        </span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 两端设置为已使用</span></span><br><span class="line">        isUsed[Prio[sNode.pos]]=<span class="literal">true</span>;</span><br><span class="line">        isUsed[Next[sNode.pos]]=<span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//更新新结点的前驱后继</span></span><br><span class="line">        Prio[sNode.pos]=Prio[Prio[sNode.pos]];</span><br><span class="line">        Next[sNode.pos]=Next[Next[sNode.pos]];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新前面的前面的后继和后面的后面的前驱</span></span><br><span class="line">        <span class="comment">// 注意Prio[sNode.pos]和Next[sNode.pos]已经变了</span></span><br><span class="line">        Next[Prio[sNode.pos]]=sNode.pos;</span><br><span class="line">        Prio[Next[sNode.pos]]=sNode.pos;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新结点入队</span></span><br><span class="line">        Q.<span class="built_in">push</span>(sNode);</span><br><span class="line">        --k;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://coding-bug.github.io/2021/06/09/Postons/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CJF">
      <meta itemprop="description" content="我系菜狗">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CJF的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/09/Postons/" class="post-title-link" itemprop="url">Postons</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-09 14:44:47" itemprop="dateCreated datePublished" datetime="2021-06-09T14:44:47+08:00">2021-06-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-15 18:15:26" itemprop="dateModified" datetime="2021-07-15T18:15:26+08:00">2021-07-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/div1/" itemprop="url" rel="index"><span itemprop="name">div1</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><img src="/2021/06/09/Postons/Potions(Hard_version).png" class="">
<h4 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h4><p>题目大概意思就是给出n个药水，每种药水会让生命值变化，你从左到右走，经过这个位置的时候可以拿起这瓶药水也可以忽略这瓶药水。你的初始生命值为0，并且整个过程中你的生命值不能低于0，问你最多能拿多少药水。</p>
<h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><p>这个题目和最大连续子序列不同，这个是可以不连续的。</p>
<ul>
<li><p>贪心：使用贪心的策略，每次只要生命值允许，就拿这瓶药，并且记录自己拿了那些药。</p>
</li>
<li><p>反悔：如果走到一个地方，拿了这瓶药之后，自己的生命会比0小，则比较：</p>
<ul>
<li>若将之前所有药中生命值最小的一瓶比现在碰到的这瓶还小，那么丢弃之前那瓶药，而选择这瓶药，即反悔。</li>
<li>否则跳过这瓶药</li>
</ul>
</li>
<li><p>优先队列：由于每次都要比较之前已经拿了的药最小的，所以要用小根堆来记录之前已经喝过的药。</p>
</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> Now=<span class="number">0</span>;    <span class="comment">// 当前生命值</span></span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;    <span class="comment">// 能够捡起的数量 </span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">200004</span>];</span><br><span class="line"><span class="keyword">int</span> n;     <span class="comment">// position数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;test/div1A.txt&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt; Q;   <span class="comment">// 小根堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Now+a[i]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!Q.<span class="built_in">empty</span>()&amp;&amp;Q.<span class="built_in">top</span>()&lt;a[i])&#123;</span><br><span class="line">                <span class="comment">// 将小根堆顶部替换掉，由于Now本来就大于0，所以反悔后Now也大于0</span></span><br><span class="line">                Now=Now+a[i]-Q.<span class="built_in">top</span>();</span><br><span class="line">                Q.<span class="built_in">pop</span>();</span><br><span class="line">                Q.<span class="built_in">push</span>(a[i]);</span><br><span class="line">                </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Now+=a[i];</span><br><span class="line">            Q.<span class="built_in">push</span>(a[i]);    <span class="comment">// 把之前要的记录下来</span></span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://coding-bug.github.io/2021/04/18/%E5%85%B3%E4%BA%8E%E5%AF%B9floyd%E7%AE%97%E6%B3%95%E7%9A%84%E8%B4%A8%E7%96%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CJF">
      <meta itemprop="description" content="我系菜狗">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CJF的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/18/%E5%85%B3%E4%BA%8E%E5%AF%B9floyd%E7%AE%97%E6%B3%95%E7%9A%84%E8%B4%A8%E7%96%91/" class="post-title-link" itemprop="url">关于对floyd算法的质疑</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-18 00:24:38" itemprop="dateCreated datePublished" datetime="2021-04-18T00:24:38+08:00">2021-04-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-15 18:15:26" itemprop="dateModified" datetime="2021-07-15T18:15:26+08:00">2021-07-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="floyd算法"><a href="#floyd算法" class="headerlink" title="floyd算法"></a>floyd算法</h1><p>所谓floyd算法，就是求图的每两个顶点的最短路径问题。算法用的是动态规划。<br>循环N次，每次选取一个顶点K，比较图的每个顶点经过K到达其他顶点的距离和本来该顶点到达其他顶点的距离，并进行距离的更新。最后可求出每两个点的最短距离。</p>
<h4 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a>疑惑</h4><p>例如一个有向图，只有1-&gt;2和1-&gt;0-&gt;4-&gt;3-&gt;2这两条路径。前者长度8，后者总长度6。那么在选取0作起始点的时候，0-&gt;2没有更新成为最短路径，并且后来会把0抛弃掉，不考虑经过0，所以在选择经过0的时候，我们就没能求出1经过0到达2的最短路径。那么怎么还能算出1-&gt;2的最短路径？</p>
<h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><p>在对0进行考虑的时候，我们已经更新了1-&gt;4的路径，而这条路径是从1经过0到达2的最短路径的一部分。所以其实经过0到达2的最短路径就已经被求出了一部分，所以接下来和0就没关系了。接下来的求法也同理。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://coding-bug.github.io/2021/04/10/%E5%9C%A8O-logn-%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8B%E4%B8%A4%E6%95%B0%E7%BB%84%E7%9A%84%E6%B7%B7%E5%90%88%E4%B8%AD%E4%BD%8D%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CJF">
      <meta itemprop="description" content="我系菜狗">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CJF的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/10/%E5%9C%A8O-logn-%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8B%E4%B8%A4%E6%95%B0%E7%BB%84%E7%9A%84%E6%B7%B7%E5%90%88%E4%B8%AD%E4%BD%8D%E6%95%B0/" class="post-title-link" itemprop="url">在O(logn)的复杂度下两数组的混合中位数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-10 23:32:41" itemprop="dateCreated datePublished" datetime="2021-04-10T23:32:41+08:00">2021-04-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-15 18:15:26" itemprop="dateModified" datetime="2021-07-15T18:15:26+08:00">2021-07-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">-算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>设X[ 0 : n - 1]和Y[ 0 : n – 1 ]为两个数组，每个数组中含有n个已排好序的数。找出X和Y的2n个数的中位数。要求：O(logn)时间内</p>
<h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><p>要在O(logn)时间内求解，则自然想到分治算法。求解思路与如下：<br>先分别求数组X和Y的两个中位数MedX和MedY。则会有以下情况</p>
<ul>
<li><p>（1）MedX==MedY。则很明显MedX即是2n个数的中位数。因为两个数组是完全等长的，所以两个数组中位数两边的数的个数，也是完全一样的。</p>
</li>
<li><p>（2）MedX&gt;MedY</p>
<ul>
<li>如果n是奇数<br>这种情况下，比X<sub>(n-1)/2+1</sub>,X<sub>(n-1)/2+2</sub>,…,X<sub>n-1</sub>小的数至少有n+1个，所以X<sub>(n-1)/2+1</sub>,X<sub>(n-1)/2+2</sub>,…,X<sub>n-1</sub>一定比中位数大。所以中位数不会在X<sub>(n-1)/2+1</sub>,X(n-1)/2+2&lt;/sub&gt;,…,X<sub>n-1</sub>中。同样Y<sub>0</sub>,Y<sub>1</sub>,…,Y<sub>(n-1)/2-1</sub>一定比中位数小。所以中位数在X<sub>0</sub>,X<sub>1</sub>,…,X<sub>(n-1)/2</sub>和Y<sub>(n-1)/2</sub>,Y<sub>n/2+2</sub>,…,Y<sub>n-1</sub>中。则只需要考察X[0:(n-1)/2:n-1]和Y[0:(n-1)/2]。</li>
<li>如果n是偶数<br>则X<sub>(n-1)/2+2</sub>,X<sub>(n-1)/2+3</sub>,…,X<sub>n-1</sub>小的数至少有n+1个，所以X<sub>(n-1)/2+2</sub>,X<sub>(n-1)/2+3</sub>,…,X<sub>n-1</sub>一定比中位数大。同样Y<sub>0</sub>,Y<sub>1</sub>,…,Y<sub>(n-)/2-2</sub>一定比中位数小。则只需要考察X[0:(n-1)/2+1]和Y[(n-1)/2-1:n-1]。</li>
</ul>
</li>
</ul>
<p>由于在中位数两边加上或减去任意等数量的数并不影响中位数的取值,所以上述方法成立。</p>
<ul>
<li>（3）MedX&lt;MedY<br>这种情况和上面的同理</li>
</ul>
<p>分到最后每个数组只有两个元素，则不可以再分下去，利用X和Y的中位数用直接方法求解。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数名：FindMedian</span></span><br><span class="line"><span class="comment">功能：  求数组的某一区间的中位数</span></span><br><span class="line"><span class="comment">参数：  double Z[]-所求数组，int zl-数组的最小下标，int zr-数组的最大下标</span></span><br><span class="line"><span class="comment">返回值：double-中位数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">FindMedian</span><span class="params">(<span class="keyword">double</span> Z[],<span class="keyword">int</span> zl,<span class="keyword">int</span> zr)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>((zr-zl)%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> Z[(zr+zl)/<span class="number">2</span>];</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="built_in"><span class="keyword">return</span></span> (Z[(zr+zl)/<span class="number">2</span>]+Z[(zr+zl)/<span class="number">2</span>+<span class="number">1</span>])/<span class="number">2</span>;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数名：FindMedian</span></span><br><span class="line"><span class="comment">功能：  求分别有序数组X某一区间和有序数组Y某一区间的混合中位数</span></span><br><span class="line"><span class="comment">参数：  int X[]-数组X，int xl-数组X要考察的最小下标，int xr-数组x要考察的最大下标</span></span><br><span class="line"><span class="comment">返回值：double-混合中位数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">FindMixMedian</span><span class="params">(<span class="keyword">double</span> X[],<span class="keyword">int</span> xl,<span class="keyword">int</span> xr,<span class="keyword">double</span> Y[],<span class="keyword">int</span> yl,<span class="keyword">int</span> yr)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">double</span> MedX=<span class="built_in">FindMedian</span>(X,xl,xr);<span class="comment">// 求X考察区域的中位数</span></span><br><span class="line">    <span class="keyword">double</span> MedY=<span class="built_in">FindMedian</span>(Y,yl,yr);<span class="comment">// 求y所考察区域的中位数</span></span><br><span class="line">    <span class="comment">// 若两个中位数相等，则所求便是混合区间的中位数</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">abs</span>(MedX-MedY)&lt;<span class="number">0.00001</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> MedY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若两边都只剩一个了，就取平均</span></span><br><span class="line">    <span class="keyword">if</span>(xl==xr&amp;&amp;yl==yr)&#123;</span><br><span class="line">        <span class="keyword">return</span> (X[xl]+Y[xl])/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若每个数组只剩两个，则讨论求出中位数</span></span><br><span class="line">    <span class="keyword">if</span>(xr-xl+<span class="number">1</span>==<span class="number">2</span>&amp;&amp;yr-yl+<span class="number">1</span>==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="comment">// 若MedX大，则X[xr]大于X[xl]和Y[YL],则判断X[xr]和Y[yr]</span></span><br><span class="line">        <span class="keyword">if</span>(MedX&gt;MedY)&#123;    </span><br><span class="line">            <span class="keyword">if</span>(X[xr]&gt;=Y[yr])&#123;     <span class="comment">// 若X[xr]&gt;=Y[yr],则可以确定地关系是Y[yl]&lt;=Y[yr]&lt;=X[xr]</span></span><br><span class="line">                <span class="keyword">if</span>(X[xl]&lt;Y[yl])&#123;  <span class="comment">// X[xl]&lt;Y[yl]&lt;=Y[yr]&lt;=X[xr] </span></span><br><span class="line">                    <span class="keyword">return</span> ((Y[yl]+Y[yr])/<span class="number">2</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;            <span class="comment">// Y[yl]&lt;=Y[yr]&lt;X[xl]&lt;=X[xr]或 Y[yl]&lt;=X[xl]&lt;=Y[yr]&lt;=X[xr]</span></span><br><span class="line">                    <span class="built_in"><span class="keyword">return</span></span> ((X[xl]+Y[yr])/<span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">// 如果X[xr]比Y[Yr]小，则X[xl]一定比Y[yl]大,则 Y[yl]&lt;X[xl]&lt;=X[xr]&lt;Y[yr]</span></span><br><span class="line">             <span class="keyword">return</span> MedX;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若MedY大，则与上面的对称</span></span><br><span class="line">        <span class="keyword">if</span>(MedX&lt;MedY)&#123;     </span><br><span class="line">            <span class="keyword">if</span>(Y[yr]&gt;=X[xr])&#123;</span><br><span class="line">                <span class="keyword">if</span>(Y[yl]&lt;X[xl])&#123;</span><br><span class="line">                    <span class="keyword">return</span> ((X[xl]+X[xr])/<span class="number">2</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;    </span><br><span class="line">                    <span class="built_in"><span class="keyword">return</span></span> ((Y[yl]+X[xr])/<span class="number">2</span>);</span><br><span class="line">                &#125;  </span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> MedY;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间划分</span></span><br><span class="line">    <span class="keyword">if</span>(MedX&gt;MedY)&#123;   <span class="comment">// MedX大时，X取小的部分，Y取大的部分</span></span><br><span class="line">        <span class="keyword">if</span>((xl-xr+<span class="number">1</span>)%<span class="number">2</span>!=<span class="number">0</span>)&#123;    <span class="comment">// 若区间个数为奇数</span></span><br><span class="line">           <span class="keyword">return</span> <span class="built_in">FindMixMedian</span>(X,xl,(xl+xr)/<span class="number">2</span>,Y,(yl+yr)/<span class="number">2</span>,yr);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="built_in">FindMixMedian</span>(X,xl,(xl+xr)/<span class="number">2</span>+<span class="number">1</span>,Y,(yl+yr)/<span class="number">2</span>,yr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;           <span class="comment">// MedX小时，X取大的部分，Y取小的部分</span></span><br><span class="line">        <span class="keyword">if</span>((xl-xr+<span class="number">1</span>)%<span class="number">2</span>!=<span class="number">0</span>)&#123;    <span class="comment">// 若区间个数为奇数</span></span><br><span class="line">           <span class="keyword">return</span> <span class="built_in">FindMixMedian</span>(X,(xl+xr)/<span class="number">2</span>,xr,Y,yl,(yl+yr)/<span class="number">2</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="built_in">FindMixMedian</span>(X,(xl+xr)/<span class="number">2</span>,xr,Y,yl,(yl+yr)/<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;input1.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;output1.txt&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="keyword">int</span> n;     <span class="comment">// 数组X和Y中每个数组所含有的元素个数   </span></span><br><span class="line">    <span class="keyword">double</span> X[<span class="number">202</span>]; </span><br><span class="line">    <span class="keyword">double</span> Y[<span class="number">202</span>];</span><br><span class="line">    <span class="keyword">double</span> ans;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        cin&gt;&gt;X[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        cin&gt;&gt;Y[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ans = <span class="built_in">FindMixMedian</span>(X,<span class="number">0</span>,n<span class="number">-1</span>,Y,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://coding-bug.github.io/2021/03/30/sptingboot%E9%9B%86%E6%88%90mybatis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CJF">
      <meta itemprop="description" content="我系菜狗">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CJF的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/30/sptingboot%E9%9B%86%E6%88%90mybatis/" class="post-title-link" itemprop="url">sptingboot集成mybatis</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-30 12:23:17" itemprop="dateCreated datePublished" datetime="2021-03-30T12:23:17+08:00">2021-03-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-15 18:15:26" itemprop="dateModified" datetime="2021-07-15T18:15:26+08:00">2021-07-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="SpringBoot集成mybatis"><a href="#SpringBoot集成mybatis" class="headerlink" title="SpringBoot集成mybatis"></a>SpringBoot集成mybatis</h1><blockquote>
<h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3></blockquote>
<p>&emsp;&emsp;在pom.xml文件中添加MySQL驱动依赖和mybatis依赖,MySQL不用加版本号，继承了父类的版本号，也可以自己指定版本号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--MySQL驱动--&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!--MyBatis整合springboot框架的起步依赖--&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;version&gt;2.0.0&lt;&#x2F;version&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<h3 id="属性设置"><a href="#属性设置" class="headerlink" title="属性设置"></a>属性设置</h3><p>&emsp;&emsp;在GeneratorMapper.xml文件中进行连接数据库的属性设置，设置完成后生成即可。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://coding-bug.github.io/2021/03/22/IDEApush%E5%88%B0github%E8%A2%AB%E6%8B%92%E7%BB%9D%E7%9A%84%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="CJF">
      <meta itemprop="description" content="我系菜狗">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CJF的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/22/IDEApush%E5%88%B0github%E8%A2%AB%E6%8B%92%E7%BB%9D%E7%9A%84%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">IDEApush到github被拒绝的问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-22 22:49:21" itemprop="dateCreated datePublished" datetime="2021-03-22T22:49:21+08:00">2021-03-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-15 18:15:26" itemprop="dateModified" datetime="2021-07-15T18:15:26+08:00">2021-07-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Diary/" itemprop="url" rel="index"><span itemprop="name">Diary</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="上传时被拒绝"><a href="#上传时被拒绝" class="headerlink" title="上传时被拒绝"></a>上传时被拒绝</h2><p>上传代码到github出现rejected的问题是因为新传的文件和原来的不是同一时间上传等，解决办法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull --rebase origin master</span><br><span class="line">git push -u origin master -f     &#x2F;&#x2F;这句不一定要</span><br></pre></td></tr></table></figure>
<h2 id="删除Github上面的文件夹"><a href="#删除Github上面的文件夹" class="headerlink" title="删除Github上面的文件夹"></a>删除Github上面的文件夹</h2><p>先pull（把github上的文件pull下来）<br>再执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached -r &quot;要删除的文件夹&quot;</span><br></pre></td></tr></table></figure><br>然后再commit，再push就行了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="CJF"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">CJF</p>
  <div class="site-description" itemprop="description">我系菜狗</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = 'true';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
